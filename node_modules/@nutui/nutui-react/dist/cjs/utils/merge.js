"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    clone: function() {
        return clone;
    },
    isPlainObject: function() {
        return isPlainObject;
    },
    main: function() {
        return main;
    },
    merge: function() {
        return merge;
    },
    recursive: function() {
        return recursive;
    }
});
var _to_consumable_array = require("@swc/helpers/_/_to_consumable_array");
var _type_of = require("@swc/helpers/_/_type_of");
function main() {
    for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
        items[_key] = arguments[_key];
    }
    return merge.apply(void 0, (0, _to_consumable_array._)(items));
}
main.clone = clone;
main.isPlainObject = isPlainObject;
main.recursive = recursive;
function merge() {
    for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
        items[_key] = arguments[_key];
    }
    return _merge(items[0] === true, false, items);
}
function recursive() {
    for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
        items[_key] = arguments[_key];
    }
    return _merge(items[0] === true, true, items);
}
function clone(input) {
    if (Array.isArray(input)) {
        var output = [];
        for(var index = 0; index < input.length; ++index)output.push(clone(input[index]));
        return output;
    }
    if (isPlainObject(input)) {
        var output1 = {};
        // eslint-disable-next-line guard-for-in
        for(var index1 in input)output1[index1] = clone(input[index1]);
        return output1;
    }
    return input;
}
function isPlainObject(input) {
    if (input === null || (typeof input === "undefined" ? "undefined" : (0, _type_of._)(input)) !== 'object') return false;
    if (Object.getPrototypeOf(input) === null) return true;
    var ref = input;
    while(Object.getPrototypeOf(ref) !== null)ref = Object.getPrototypeOf(ref);
    return Object.getPrototypeOf(input) === ref;
}
function _recursiveMerge(base, extend) {
    if (!isPlainObject(base) || !isPlainObject(extend)) return extend;
    for(var key in extend){
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
        base[key] = isPlainObject(base[key]) && isPlainObject(extend[key]) ? _recursiveMerge(base[key], extend[key]) : extend[key];
    }
    return base;
}
function _merge(isClone, isRecursive, items) {
    var result;
    if (isClone || !isPlainObject(result = items.shift())) result = {};
    for(var index = 0; index < items.length; ++index){
        var item = items[index];
        // eslint-disable-next-line no-continue
        if (!isPlainObject(item)) continue;
        for(var key in item){
            if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
            var value = isClone ? clone(item[key]) : item[key];
            result[key] = isRecursive ? _recursiveMerge(result[key], value) : value;
        }
    }
    return result;
}
