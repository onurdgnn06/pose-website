"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    simulateTouchMove: function() {
        return simulateTouchMove;
    },
    simulateTouchZoom: function() {
        return simulateTouchZoom;
    },
    sleep: function() {
        return sleep;
    },
    trigger: function() {
        return trigger;
    },
    triggerDrag: function() {
        return triggerDrag;
    }
});
var _async_to_generator = require("@swc/helpers/_/_async_to_generator");
var _ts_generator = require("@swc/helpers/_/_ts_generator");
function getTouch(el, x, y) {
    return {
        identifier: Date.now(),
        target: el,
        pageX: x,
        pageY: y,
        clientX: x,
        clientY: y,
        radiusX: 2.5,
        radiusY: 2.5,
        rotationAngle: 10,
        force: 0.5
    };
}
function trigger(wrapper, eventName) {
    var x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    var el = 'element' in wrapper ? wrapper.element : wrapper;
    var touchList = options.touchList || [
        getTouch(el, x, y)
    ];
    if (options.x || options.y) {
        touchList.push(getTouch(el, options.x, options.y));
    }
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, {});
    Object.assign(event, {
        clientX: x,
        clientY: y,
        touches: touchList,
        targetTouches: touchList,
        changedTouches: touchList
    });
    el.dispatchEvent(event);
}
function sleep() {
    var delay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return new Promise(function(resolve) {
        setTimeout(resolve, delay);
    });
}
function triggerDrag(el) {
    var relativeX = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, relativeY = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var x = relativeX;
    var y = relativeY;
    var startX = 0;
    var startY = 0;
    if (relativeX < 0) {
        startX = Math.abs(relativeX);
        x = 0;
    }
    if (relativeY < 0) {
        startY = Math.abs(relativeY);
        y = 0;
    }
    trigger(el, 'touchstart', startX, startY);
    trigger(el, 'touchmove', x / 4, y / 4);
    trigger(el, 'touchmove', x / 3, y / 3);
    trigger(el, 'touchmove', x / 2, y / 2);
    trigger(el, 'touchmove', x, y);
    trigger(el, 'touchend', x, y);
}
function simulateTouchMove(element, startX, startY, endX, endY, duration) {
    return _simulateTouchMove.apply(this, arguments);
}
function _simulateTouchMove() {
    _simulateTouchMove = (0, _async_to_generator._)(function(element, startX, startY, endX, endY, duration) {
        var touch, touchList, distanceX, distanceY, startTime, elapsed, progress, currentX, currentY, currentTouch, currentTouchList;
        return (0, _ts_generator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    touch = getTouch(element, startX, startY);
                    touchList = [
                        touch
                    ];
                    // 触摸开始事件
                    trigger(element, 'touchstart', startX, startY, {
                        touchList: touchList
                    });
                    distanceX = endX - startX;
                    distanceY = endY - startY;
                    startTime = Date.now();
                    _state.label = 1;
                case 1:
                    if (!(Date.now() - startTime < duration)) return [
                        3,
                        3
                    ];
                    elapsed = Date.now() - startTime;
                    progress = elapsed / duration;
                    currentX = startX + distanceX * progress;
                    currentY = startY + distanceY * progress;
                    currentTouch = getTouch(element, currentX, currentY);
                    currentTouchList = [
                        currentTouch
                    ];
                    trigger(element, 'touchmove', currentX, currentY, {
                        touchList: currentTouchList
                    });
                    return [
                        4,
                        sleep(duration / 100)
                    ];
                case 2:
                    _state.sent();
                    return [
                        3,
                        1
                    ];
                case 3:
                    // 触摸结束事件
                    trigger(element, 'touchend', endX, endY, {
                        touchList: touchList
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return _simulateTouchMove.apply(this, arguments);
}
function simulateTouchZoom(element, startDistance, endDistance, duration) {
    return _simulateTouchZoom.apply(this, arguments);
}
function _simulateTouchZoom() {
    _simulateTouchZoom = (0, _async_to_generator._)(function(element, startDistance, endDistance, duration) {
        var centerX, centerY, startScale, endScale, startTouches, endTouches, progress, currentScale, currentDistance, currentTouches;
        return (0, _ts_generator._)(this, function(_state) {
            switch(_state.label){
                case 0:
                    centerX = element.clientWidth / 2;
                    centerY = element.clientHeight / 2;
                    startScale = startDistance / endDistance;
                    endScale = 1;
                    startTouches = [
                        getTouch(element, centerX - startDistance / 2, centerY),
                        getTouch(element, centerX + startDistance / 2, centerY)
                    ];
                    endTouches = [
                        getTouch(element, centerX - endDistance / 2, centerY),
                        getTouch(element, centerX + endDistance / 2, centerY)
                    ];
                    // 触摸开始事件
                    trigger(element, 'touchstart', centerX, centerY, {
                        touchList: startTouches
                    });
                    progress = 0;
                    _state.label = 1;
                case 1:
                    if (!(progress < 1)) return [
                        3,
                        4
                    ];
                    currentScale = startScale + (endScale - startScale) * progress;
                    currentDistance = startDistance / currentScale;
                    currentTouches = [
                        getTouch(element, centerX - currentDistance / 2, centerY),
                        getTouch(element, centerX + currentDistance / 2, centerY)
                    ];
                    trigger(element, 'touchmove', centerX, centerY, {
                        touchList: currentTouches
                    });
                    return [
                        4,
                        sleep(duration / 100)
                    ];
                case 2:
                    _state.sent();
                    _state.label = 3;
                case 3:
                    progress += 0.01;
                    return [
                        3,
                        1
                    ];
                case 4:
                    // 触摸结束事件
                    trigger(element, 'touchend', centerX, centerY, {
                        touchList: endTouches
                    });
                    return [
                        2
                    ];
            }
        });
    });
    return _simulateTouchZoom.apply(this, arguments);
}
