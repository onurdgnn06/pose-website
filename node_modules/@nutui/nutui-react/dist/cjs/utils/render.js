"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    render: function() {
        return render;
    },
    unmount: function() {
        return unmount;
    }
});
var _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
var _async_to_generator = require("@swc/helpers/_/_async_to_generator");
var _object_spread = require("@swc/helpers/_/_object_spread");
var _type_of = require("@swc/helpers/_/_type_of");
var _ts_generator = require("@swc/helpers/_/_ts_generator");
var _reactdom = /*#__PURE__*/ _interop_require_wildcard._(require("react-dom"));
// Let compiler not to search module usage
var fullClone = (0, _object_spread._)({}, _reactdom);
var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
    var mainVersion = Number((version || '').split('.')[0]);
    if (mainVersion >= 18 && fullClone.createRoot) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        createRoot = fullClone.createRoot;
    }
} catch (e) {
// Do nothing;
}
function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && (typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "undefined" ? "undefined" : (0, _type_of._)(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) === 'object') {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
}
var MARK = '__nutui_react_root__';
function legacyRender(node, container) {
    reactRender(node, container);
}
function concurrentRender(node, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node);
    container[MARK] = root;
}
function render(node, container) {
    if (createRoot) {
        concurrentRender(node, container);
        return;
    }
    legacyRender(node, container);
}
// ========================== Unmount =========================
function legacyUnmount(container) {
    return unmountComponentAtNode(container);
}
function concurrentUnmount(container) {
    return _concurrentUnmount.apply(this, arguments);
}
function _concurrentUnmount() {
    _concurrentUnmount = (0, _async_to_generator._)(function(container) {
        return (0, _ts_generator._)(this, function(_state) {
            // Delay to unmount to avoid React 18 sync warning
            return [
                2,
                Promise.resolve().then(function() {
                    var _container_MARK;
                    (_container_MARK = container[MARK]) === null || _container_MARK === void 0 ? void 0 : _container_MARK.unmount();
                    delete container[MARK];
                })
            ];
        });
    });
    return _concurrentUnmount.apply(this, arguments);
}
function unmount(container) {
    if (createRoot) {
        return concurrentUnmount(container);
    }
    return legacyUnmount(container);
}
