"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useLockScroll", {
    enumerable: true,
    get: function() {
        return useLockScroll;
    }
});
var _react = require("react");
var _usetouch = require("./use-touch");
var _getscrollparent = require("../utils/get-scroll-parent");
var _supportspassive = require("../utils/supports-passive");
var totalLockCount = 0;
var BODY_LOCK_CLASS = 'nut-overflow-hidden';
function getScrollableElement(el) {
    var current = el === null || el === void 0 ? void 0 : el.parentElement;
    while(current){
        if (current.clientHeight < current.scrollHeight) {
            return current;
        }
        current = current.parentElement;
    }
    return null;
}
function useLockScroll(rootRef, shouldLock) {
    var touch = (0, _usetouch.useTouch)();
    var onTouchMove = function onTouchMove(event) {
        touch.move(event);
        var direction = touch.deltaY.current > 0 ? '10' : '01';
        var el = (0, _getscrollparent.getScrollParent)(event.target, rootRef.current);
        if (!el) return;
        // This has perf cost but we have to compatible with iOS 12
        if (shouldLock === 'strict') {
            var scrollableParent = getScrollableElement(event.target);
            if (scrollableParent === document.body || scrollableParent === document.documentElement) {
                event.preventDefault();
                return;
            }
        }
        var scrollHeight = el.scrollHeight, offsetHeight = el.offsetHeight, scrollTop = el.scrollTop;
        var status = '11';
        if (scrollTop === 0) {
            status = offsetHeight >= scrollHeight ? '00' : '01';
        } else if (scrollTop + offsetHeight >= scrollHeight) {
            status = '10';
        }
        if (status !== '11' && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
            if (event.cancelable) {
                event.preventDefault();
            }
        }
    };
    var lock = function lock() {
        document.addEventListener('touchstart', touch.start);
        document.addEventListener('touchmove', onTouchMove, _supportspassive.passiveSupported ? {
            passive: false
        } : false);
        if (!totalLockCount) {
            document.body.classList.add(BODY_LOCK_CLASS);
        }
        totalLockCount++;
    };
    var unlock = function unlock() {
        if (totalLockCount) {
            document.removeEventListener('touchstart', touch.start);
            document.removeEventListener('touchmove', onTouchMove);
            totalLockCount--;
            if (!totalLockCount) {
                document.body.classList.remove(BODY_LOCK_CLASS);
            }
        }
    };
    (0, _react.useEffect)(function() {
        if (shouldLock) {
            lock();
            return function() {
                unlock();
            };
        }
    }, [
        shouldLock
    ]);
}
