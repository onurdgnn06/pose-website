"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _call_super = require("@swc/helpers/_/_call_super");
var _class_call_check = require("@swc/helpers/_/_class_call_check");
var _inherits = require("@swc/helpers/_/_inherits");
var _sliced_to_array = require("@swc/helpers/_/_sliced_to_array");
var _to_consumable_array = require("@swc/helpers/_/_to_consumable_array");
var _wrap_native_super = require("@swc/helpers/_/_wrap_native_super");
var _merge = require("../../../utils/merge");
describe('merge', function() {
    it('merges two objects', function() {
        expect((0, _merge.merge)({
            a: 1
        }, {
            b: 2
        })).toStrictEqual({
            a: 1,
            b: 2
        });
    });
    it('merges nested levels', function() {
        expect((0, _merge.merge)({
            a: 1
        }, {
            b: {
                c: {
                    d: 2
                }
            }
        })).toStrictEqual({
            a: 1,
            b: {
                c: {
                    d: 2
                }
            }
        });
    });
    it('clones the target', function() {
        var input = {
            a: 1,
            b: {
                c: {
                    d: 2,
                    e: [
                        'x',
                        'y',
                        {
                            z: {
                                w: [
                                    'k'
                                ]
                            }
                        }
                    ]
                }
            },
            f: null,
            g: undefined,
            h: true
        };
        var original = {
            a: 1,
            b: {
                c: {
                    d: 2,
                    e: [
                        'x',
                        'y',
                        {
                            z: {
                                w: [
                                    'k'
                                ]
                            }
                        }
                    ]
                }
            },
            f: null,
            g: undefined,
            h: true
        };
        var output = (0, _merge.merge)(true, input);
        input.b.c.d++;
        input.b.c.e[2].z.w = null;
        input.h = null;
        expect(output).toStrictEqual(original);
        input = original;
        output = (0, _merge.merge)(true, input, {
            a: 2
        });
        expect(output.a).toBe(2);
        expect(input.a).toBe(1);
    });
    it('ignores the sources', function() {
        var values = createNonPlainObjects();
        var $merge = vi.fn().mockImplementation(_merge.merge);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var value = _step.value;
                expect($merge(value)).toStrictEqual({});
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        expect(values.length).toBeGreaterThan(0);
        expect($merge).toBeCalledTimes(values.length);
        expect(_merge.merge.apply(void 0, (0, _to_consumable_array._)(values).concat([
            [
                0,
                1,
                2
            ]
        ], (0, _to_consumable_array._)(values), [
            {
                a: 1
            }
        ], (0, _to_consumable_array._)(values), [
            {
                b: 2
            }
        ]))).toStrictEqual({
            a: 1,
            b: 2
        });
    });
    it('does not merge non plain objects', function() {
        var values = createNonPlainObjects();
        expect(values.length).toBeGreaterThan(0);
        var input = {};
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = Object.entries(values)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var _step_value = (0, _sliced_to_array._)(_step.value, 2), index = _step_value[0], value = _step_value[1];
                input["value".concat(index)] = value;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        var output = (0, _merge.merge)({}, input);
        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
        try {
            for(var _iterator1 = Object.entries(values)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                var _step_value1 = (0, _sliced_to_array._)(_step1.value, 1), index1 = _step_value1[0];
                var key = "value".concat(index1);
                var inputValue = input[key];
                var outputValue = output[key];
                // eslint-disable-next-line no-restricted-globals
                if (typeof outputValue === 'number' && isNaN(outputValue)) {
                    // eslint-disable-next-line no-restricted-globals
                    expect(isNaN(inputValue), key).toBeTruthy();
                } else {
                    expect(inputValue === outputValue, key).toBeTruthy();
                }
            }
        } catch (err) {
            _didIteratorError1 = true;
            _iteratorError1 = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                    _iterator1.return();
                }
            } finally{
                if (_didIteratorError1) {
                    throw _iteratorError1;
                }
            }
        }
    });
    it('is safe', function() {
        expect((0, _merge.merge)({}, JSON.parse('{"__proto__": {"evil": true}}'))).toStrictEqual({});
        expect({}.evil).toBeUndefined();
    });
});
describe('clone', function() {
    it('clones the input', function() {
        var object1 = {
            a: 1,
            b: {
                c: 2
            }
        };
        var object2 = (0, _merge.clone)(object1);
        expect(object1).toStrictEqual(object2);
        expect(object1 === object2).toBeFalsy();
        expect(object1.b === object2.b).toBeFalsy();
    });
    it('clones each item of the array', function() {
        var object1 = [
            {
                a: 1,
                b: {
                    c: 2
                }
            }
        ];
        var object2 = (0, _merge.clone)(object1);
        expect(object1).toStrictEqual(object2);
        expect(object1 === object2).toBeFalsy();
        expect(object1[0] === object2[0]).toBeFalsy();
        expect(object1[0].b === object2[0].b).toBeFalsy();
    });
    it('returns the same input', function() {
        var values = createNonPlainObjects();
        var $clone = vi.fn().mockImplementation(_merge.clone);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var value = _step.value;
                var cloned = $clone(value);
                // eslint-disable-next-line no-restricted-globals
                if (typeof cloned === 'number' && isNaN(cloned)) {
                    // eslint-disable-next-line no-restricted-globals
                    expect(isNaN(value)).toBeTruthy();
                } else if (Array.isArray(cloned)) {
                    expect(Array.isArray(value)).toBeTruthy();
                } else {
                    expect(cloned === value).toBeTruthy();
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        expect(values.length).toBeGreaterThan(0);
        expect($clone).toBeCalledTimes(values.length);
    });
});
describe('recursive', function() {
    it('merges recursively', function() {
        expect((0, _merge.recursive)({
            a: {
                b: 1
            }
        }, {
            a: {
                c: 1
            }
        })).toStrictEqual({
            a: {
                b: 1,
                c: 1
            }
        });
        expect((0, _merge.recursive)({
            a: {
                b: 1,
                c: 1
            }
        }, {
            a: {
                b: 2
            }
        })).toStrictEqual({
            a: {
                b: 2,
                c: 1
            }
        });
        expect((0, _merge.recursive)({
            a: {
                b: [
                    1,
                    2,
                    3
                ],
                c: 1
            }
        }, {
            a: {
                b: [
                    'a'
                ]
            }
        })).toStrictEqual({
            a: {
                b: [
                    'a'
                ],
                c: 1
            }
        });
        expect((0, _merge.recursive)({
            a: {
                b: {
                    b: 2
                },
                c: 1
            }
        }, {
            a: {
                b: 2
            }
        })).toStrictEqual({
            a: {
                b: 2,
                c: 1
            }
        });
    });
    it('clones recursively', function() {
        var test1 = {
            a: {
                b: 1
            }
        };
        expect((0, _merge.recursive)(true, test1, {
            a: {
                c: 1
            }
        })).toStrictEqual({
            a: {
                b: 1,
                c: 1
            }
        });
        expect(test1).toStrictEqual({
            a: {
                b: 1
            }
        });
        var test2 = {
            a: {
                b: 1,
                c: 1
            }
        };
        expect((0, _merge.recursive)(true, test2, {
            a: {
                b: 2
            }
        })).toStrictEqual({
            a: {
                b: 2,
                c: 1
            }
        });
        expect(test2).toStrictEqual({
            a: {
                b: 1,
                c: 1
            }
        });
        var test3 = {
            a: {
                b: [
                    1,
                    2,
                    3
                ],
                c: 1
            }
        };
        expect((0, _merge.recursive)(true, test3, {
            a: {
                b: [
                    'a'
                ]
            }
        })).toStrictEqual({
            a: {
                b: [
                    'a'
                ],
                c: 1
            }
        });
        expect(test3).toStrictEqual({
            a: {
                b: [
                    1,
                    2,
                    3
                ],
                c: 1
            }
        });
        var test4 = {
            a: {
                b: {
                    b: 2
                },
                c: 1
            }
        };
        expect((0, _merge.recursive)(true, test4, {
            a: {
                b: 2
            }
        })).toStrictEqual({
            a: {
                b: 2,
                c: 1
            }
        });
        expect(test4).toStrictEqual({
            a: {
                b: {
                    b: 2
                },
                c: 1
            }
        });
    });
    it('does not merge non plain objects', function() {
        var object = (0, _merge.recursive)({
            map: {
                length: 1
            }
        }, {
            map: new Map()
        });
        expect(object.map).toBeInstanceOf(Map);
    });
    it('is safe', function() {
        var payload = '{"__proto__": {"a": true}}';
        expect((0, _merge.recursive)({}, JSON.parse(payload))).toStrictEqual({});
        expect({}.a).toBeUndefined();
        expect((0, _merge.recursive)({
            deep: {}
        }, JSON.parse(payload))).toStrictEqual({
            deep: {}
        });
        expect({}.b).toBeUndefined();
    });
});
describe('isPlainObject', function() {
    it('returns true', function() {
        expect((0, _merge.isPlainObject)({})).toBeTruthy();
        expect((0, _merge.isPlainObject)({
            v: 1
        })).toBeTruthy();
        expect((0, _merge.isPlainObject)(Object.create(null))).toBeTruthy();
        expect((0, _merge.isPlainObject)({})).toBeTruthy();
    });
    it('returns false', function() {
        var values = createNonPlainObjects();
        var $isPlainObject = vi.fn().mockImplementation(_merge.isPlainObject);
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var value = _step.value;
                expect($isPlainObject(value)).toBeFalsy();
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        expect(values.length).toBeGreaterThan(0);
        expect($isPlainObject).toBeCalledTimes(values.length);
    });
});
function createNonPlainObjects() {
    var SubObject = /*#__PURE__*/ function(Object1) {
        "use strict";
        (0, _inherits._)(SubObject, Object1);
        function SubObject() {
            (0, _class_call_check._)(this, SubObject);
            return (0, _call_super._)(this, SubObject, arguments);
        }
        return SubObject;
    }((0, _wrap_native_super._)(Object));
    return [
        null,
        undefined,
        1,
        '',
        'str',
        [],
        [
            1
        ],
        function() {},
        function() {},
        true,
        false,
        NaN,
        Infinity,
        function _class() {
            "use strict";
            (0, _class_call_check._)(this, _class);
        },
        new function _class() {
            "use strict";
            (0, _class_call_check._)(this, _class);
        }(),
        new Map(),
        new Set(),
        new Date(),
        [],
        new Date(),
        /./,
        /./,
        SubObject,
        new SubObject(),
        Symbol('')
    ];
}
