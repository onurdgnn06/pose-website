(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "react-dom"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.nutReact = {}, global2.React, global2.ReactDOM));
})(this, function(exports, React, ReactDOM) {
  "use strict";
  function _interopNamespaceDefault(e2) {
    const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e2) {
      for (const k in e2) {
        if (k !== "default") {
          const d2 = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d2.get ? d2 : {
            enumerable: true,
            get: () => e2[k]
          });
        }
      }
    }
    n2.default = e2;
    return Object.freeze(n2);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
  const ReactDOM__namespace = /* @__PURE__ */ _interopNamespaceDefault(ReactDOM);
  function _define_property(obj, key2, value2) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
    } else obj[key2] = value2;
    return obj;
  }
  function _object_spread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(
          Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          })
        );
      }
      ownKeys2.forEach(function(key2) {
        _define_property(target, key2, source[key2]);
      });
    }
    return target;
  }
  function ownKeys$2(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    else {
      ownKeys$2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var classnames = { exports: {} };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  (function(module2) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key2 in arg) {
          if (hasOwn.call(arg, key2) && arg[key2]) {
            classes = appendClass(classes, key2);
          }
        }
        return classes;
      }
      function appendClass(value2, newClass) {
        if (!newClass) {
          return value2;
        }
        if (value2) {
          return value2 + " " + newClass;
        }
        return value2 + newClass;
      }
      if (module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  var classnamesExports = classnames.exports;
  const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  const n$b = {
    classPrefix: "nut-icon",
    tag: "i",
    fontClassName: "nutui-iconfont"
  };
  var Q = { exports: {} }, $ = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Ce;
  function lr() {
    if (Ce)
      return $;
    Ce = 1;
    var F = React, E = Symbol.for("react.element"), D = Symbol.for("react.fragment"), _ = Object.prototype.hasOwnProperty, x = F.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, C = { key: true, ref: true, __self: true, __source: true };
    function R(m2, f, T) {
      var d2, h = {}, g = null, P = null;
      T !== void 0 && (g = "" + T), f.key !== void 0 && (g = "" + f.key), f.ref !== void 0 && (P = f.ref);
      for (d2 in f)
        _.call(f, d2) && !C.hasOwnProperty(d2) && (h[d2] = f[d2]);
      if (m2 && m2.defaultProps)
        for (d2 in f = m2.defaultProps, f)
          h[d2] === void 0 && (h[d2] = f[d2]);
      return { $$typeof: E, type: m2, key: g, ref: P, props: h, _owner: x.current };
    }
    return $.Fragment = D, $.jsx = R, $.jsxs = R, $;
  }
  var W = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var Oe;
  function cr() {
    return Oe || (Oe = 1, process.env.NODE_ENV !== "production" && function() {
      var F = React, E = Symbol.for("react.element"), D = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), R = Symbol.for("react.provider"), m2 = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), d2 = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), P = Symbol.for("react.offscreen"), S = Symbol.iterator, N = "@@iterator";
      function Y(e2) {
        if (e2 === null || typeof e2 != "object")
          return null;
        var r = S && e2[S] || e2[N];
        return typeof r == "function" ? r : null;
      }
      var w = F.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function s2(e2) {
        {
          for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n2 = 1; n2 < r; n2++)
            t[n2 - 1] = arguments[n2];
          Se("error", e2, t);
        }
      }
      function Se(e2, r, t) {
        {
          var n2 = w.ReactDebugCurrentFrame, i2 = n2.getStackAddendum();
          i2 !== "" && (r += "%s", t = t.concat([i2]));
          var u = t.map(function(o) {
            return String(o);
          });
          u.unshift("Warning: " + r), Function.prototype.apply.call(console[e2], console, u);
        }
      }
      var je = false, ke = false, Fe = false, De = false, Ae = false, re;
      re = Symbol.for("react.module.reference");
      function Ie(e2) {
        return !!(typeof e2 == "string" || typeof e2 == "function" || e2 === _ || e2 === C || Ae || e2 === x || e2 === T || e2 === d2 || De || e2 === P || je || ke || Fe || typeof e2 == "object" && e2 !== null && (e2.$$typeof === g || e2.$$typeof === h || e2.$$typeof === R || e2.$$typeof === m2 || e2.$$typeof === f || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        e2.$$typeof === re || e2.getModuleId !== void 0));
      }
      function $e(e2, r, t) {
        var n2 = e2.displayName;
        if (n2)
          return n2;
        var i2 = r.displayName || r.name || "";
        return i2 !== "" ? t + "(" + i2 + ")" : t;
      }
      function te(e2) {
        return e2.displayName || "Context";
      }
      function b(e2) {
        if (e2 == null)
          return null;
        if (typeof e2.tag == "number" && s2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e2 == "function")
          return e2.displayName || e2.name || null;
        if (typeof e2 == "string")
          return e2;
        switch (e2) {
          case _:
            return "Fragment";
          case D:
            return "Portal";
          case C:
            return "Profiler";
          case x:
            return "StrictMode";
          case T:
            return "Suspense";
          case d2:
            return "SuspenseList";
        }
        if (typeof e2 == "object")
          switch (e2.$$typeof) {
            case m2:
              var r = e2;
              return te(r) + ".Consumer";
            case R:
              var t = e2;
              return te(t._context) + ".Provider";
            case f:
              return $e(e2, e2.render, "ForwardRef");
            case h:
              var n2 = e2.displayName || null;
              return n2 !== null ? n2 : b(e2.type) || "Memo";
            case g: {
              var i2 = e2, u = i2._payload, o = i2._init;
              try {
                return b(o(u));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var O = Object.assign, A = 0, ne, ae, oe, ie, ue, se, le;
      function ce() {
      }
      ce.__reactDisabledLog = true;
      function We() {
        {
          if (A === 0) {
            ne = console.log, ae = console.info, oe = console.warn, ie = console.error, ue = console.group, se = console.groupCollapsed, le = console.groupEnd;
            var e2 = {
              configurable: true,
              enumerable: true,
              value: ce,
              writable: true
            };
            Object.defineProperties(console, {
              info: e2,
              log: e2,
              warn: e2,
              error: e2,
              group: e2,
              groupCollapsed: e2,
              groupEnd: e2
            });
          }
          A++;
        }
      }
      function Ne() {
        {
          if (A--, A === 0) {
            var e2 = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: O({}, e2, {
                value: ne
              }),
              info: O({}, e2, {
                value: ae
              }),
              warn: O({}, e2, {
                value: oe
              }),
              error: O({}, e2, {
                value: ie
              }),
              group: O({}, e2, {
                value: ue
              }),
              groupCollapsed: O({}, e2, {
                value: se
              }),
              groupEnd: O({}, e2, {
                value: le
              })
            });
          }
          A < 0 && s2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var q = w.ReactCurrentDispatcher, J;
      function L(e2, r, t) {
        {
          if (J === void 0)
            try {
              throw Error();
            } catch (i2) {
              var n2 = i2.stack.trim().match(/\n( *(at )?)/);
              J = n2 && n2[1] || "";
            }
          return `
` + J + e2;
        }
      }
      var G = false, V2;
      {
        var Ye = typeof WeakMap == "function" ? WeakMap : Map;
        V2 = new Ye();
      }
      function fe(e2, r) {
        if (!e2 || G)
          return "";
        {
          var t = V2.get(e2);
          if (t !== void 0)
            return t;
        }
        var n2;
        G = true;
        var i2 = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var u;
        u = q.current, q.current = null, We();
        try {
          if (r) {
            var o = function() {
              throw Error();
            };
            if (Object.defineProperty(o.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(o, []);
              } catch (y) {
                n2 = y;
              }
              Reflect.construct(e2, [], o);
            } else {
              try {
                o.call();
              } catch (y) {
                n2 = y;
              }
              e2.call(o.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (y) {
              n2 = y;
            }
            e2();
          }
        } catch (y) {
          if (y && n2 && typeof y.stack == "string") {
            for (var a = y.stack.split(`
`), v = n2.stack.split(`
`), l2 = a.length - 1, c6 = v.length - 1; l2 >= 1 && c6 >= 0 && a[l2] !== v[c6]; )
              c6--;
            for (; l2 >= 1 && c6 >= 0; l2--, c6--)
              if (a[l2] !== v[c6]) {
                if (l2 !== 1 || c6 !== 1)
                  do
                    if (l2--, c6--, c6 < 0 || a[l2] !== v[c6]) {
                      var p2 = `
` + a[l2].replace(" at new ", " at ");
                      return e2.displayName && p2.includes("<anonymous>") && (p2 = p2.replace("<anonymous>", e2.displayName)), typeof e2 == "function" && V2.set(e2, p2), p2;
                    }
                  while (l2 >= 1 && c6 >= 0);
                break;
              }
          }
        } finally {
          G = false, q.current = u, Ne(), Error.prepareStackTrace = i2;
        }
        var k = e2 ? e2.displayName || e2.name : "", we = k ? L(k) : "";
        return typeof e2 == "function" && V2.set(e2, we), we;
      }
      function Le(e2, r, t) {
        return fe(e2, false);
      }
      function Ve(e2) {
        var r = e2.prototype;
        return !!(r && r.isReactComponent);
      }
      function M(e2, r, t) {
        if (e2 == null)
          return "";
        if (typeof e2 == "function")
          return fe(e2, Ve(e2));
        if (typeof e2 == "string")
          return L(e2);
        switch (e2) {
          case T:
            return L("Suspense");
          case d2:
            return L("SuspenseList");
        }
        if (typeof e2 == "object")
          switch (e2.$$typeof) {
            case f:
              return Le(e2.render);
            case h:
              return M(e2.type, r, t);
            case g: {
              var n2 = e2, i2 = n2._payload, u = n2._init;
              try {
                return M(u(i2), r, t);
              } catch {
              }
            }
          }
        return "";
      }
      var U = Object.prototype.hasOwnProperty, de = {}, ve = w.ReactDebugCurrentFrame;
      function B(e2) {
        if (e2) {
          var r = e2._owner, t = M(e2.type, e2._source, r ? r.type : null);
          ve.setExtraStackFrame(t);
        } else
          ve.setExtraStackFrame(null);
      }
      function Me(e2, r, t, n2, i2) {
        {
          var u = Function.call.bind(U);
          for (var o in e2)
            if (u(e2, o)) {
              var a = void 0;
              try {
                if (typeof e2[o] != "function") {
                  var v = Error((n2 || "React class") + ": " + t + " type `" + o + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e2[o] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw v.name = "Invariant Violation", v;
                }
                a = e2[o](r, o, n2, t, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (l2) {
                a = l2;
              }
              a && !(a instanceof Error) && (B(i2), s2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", n2 || "React class", t, o, typeof a), B(null)), a instanceof Error && !(a.message in de) && (de[a.message] = true, B(i2), s2("Failed %s type: %s", t, a.message), B(null));
            }
        }
      }
      var Ue = Array.isArray;
      function z(e2) {
        return Ue(e2);
      }
      function Be(e2) {
        {
          var r = typeof Symbol == "function" && Symbol.toStringTag, t = r && e2[Symbol.toStringTag] || e2.constructor.name || "Object";
          return t;
        }
      }
      function qe(e2) {
        try {
          return pe(e2), false;
        } catch {
          return true;
        }
      }
      function pe(e2) {
        return "" + e2;
      }
      function he(e2) {
        if (qe(e2))
          return s2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Be(e2)), pe(e2);
      }
      var I = w.ReactCurrentOwner, Je = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      }, ge, me;
      function Ge(e2) {
        if (U.call(e2, "ref")) {
          var r = Object.getOwnPropertyDescriptor(e2, "ref").get;
          if (r && r.isReactWarning)
            return false;
        }
        return e2.ref !== void 0;
      }
      function ze(e2) {
        if (U.call(e2, "key")) {
          var r = Object.getOwnPropertyDescriptor(e2, "key").get;
          if (r && r.isReactWarning)
            return false;
        }
        return e2.key !== void 0;
      }
      function He(e2, r) {
        if (typeof e2.ref == "string" && I.current && r) ;
      }
      function Ke(e2, r) {
        {
          var t = function() {
            ge || (ge = true, s2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
          };
          t.isReactWarning = true, Object.defineProperty(e2, "key", {
            get: t,
            configurable: true
          });
        }
      }
      function Xe(e2, r) {
        {
          var t = function() {
            me || (me = true, s2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
          };
          t.isReactWarning = true, Object.defineProperty(e2, "ref", {
            get: t,
            configurable: true
          });
        }
      }
      var Ze = function(e2, r, t, n2, i2, u, o) {
        var a = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: E,
          // Built-in properties that belong on the element
          type: e2,
          key: r,
          ref: t,
          props: o,
          // Record the component responsible for creating this element.
          _owner: u
        };
        return a._store = {}, Object.defineProperty(a._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }), Object.defineProperty(a, "_self", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: n2
        }), Object.defineProperty(a, "_source", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: i2
        }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;
      };
      function Qe(e2, r, t, n2, i2) {
        {
          var u, o = {}, a = null, v = null;
          t !== void 0 && (he(t), a = "" + t), ze(r) && (he(r.key), a = "" + r.key), Ge(r) && (v = r.ref, He(r, i2));
          for (u in r)
            U.call(r, u) && !Je.hasOwnProperty(u) && (o[u] = r[u]);
          if (e2 && e2.defaultProps) {
            var l2 = e2.defaultProps;
            for (u in l2)
              o[u] === void 0 && (o[u] = l2[u]);
          }
          if (a || v) {
            var c6 = typeof e2 == "function" ? e2.displayName || e2.name || "Unknown" : e2;
            a && Ke(o, c6), v && Xe(o, c6);
          }
          return Ze(e2, a, v, i2, n2, I.current, o);
        }
      }
      var K = w.ReactCurrentOwner, be = w.ReactDebugCurrentFrame;
      function j(e2) {
        if (e2) {
          var r = e2._owner, t = M(e2.type, e2._source, r ? r.type : null);
          be.setExtraStackFrame(t);
        } else
          be.setExtraStackFrame(null);
      }
      var X;
      X = false;
      function Z(e2) {
        return typeof e2 == "object" && e2 !== null && e2.$$typeof === E;
      }
      function ye() {
        {
          if (K.current) {
            var e2 = b(K.current.type);
            if (e2)
              return `

Check the render method of \`` + e2 + "`.";
          }
          return "";
        }
      }
      function er(e2) {
        {
          return "";
        }
      }
      var Ee = {};
      function rr(e2) {
        {
          var r = ye();
          if (!r) {
            var t = typeof e2 == "string" ? e2 : e2.displayName || e2.name;
            t && (r = `

Check the top-level render call using <` + t + ">.");
          }
          return r;
        }
      }
      function _e(e2, r) {
        {
          if (!e2._store || e2._store.validated || e2.key != null)
            return;
          e2._store.validated = true;
          var t = rr(r);
          if (Ee[t])
            return;
          Ee[t] = true;
          var n2 = "";
          e2 && e2._owner && e2._owner !== K.current && (n2 = " It was passed a child from " + b(e2._owner.type) + "."), j(e2), s2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n2), j(null);
        }
      }
      function Re(e2, r) {
        {
          if (typeof e2 != "object")
            return;
          if (z(e2))
            for (var t = 0; t < e2.length; t++) {
              var n2 = e2[t];
              Z(n2) && _e(n2, r);
            }
          else if (Z(e2))
            e2._store && (e2._store.validated = true);
          else if (e2) {
            var i2 = Y(e2);
            if (typeof i2 == "function" && i2 !== e2.entries)
              for (var u = i2.call(e2), o; !(o = u.next()).done; )
                Z(o.value) && _e(o.value, r);
          }
        }
      }
      function tr(e2) {
        {
          var r = e2.type;
          if (r == null || typeof r == "string")
            return;
          var t;
          if (typeof r == "function")
            t = r.propTypes;
          else if (typeof r == "object" && (r.$$typeof === f || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          r.$$typeof === h))
            t = r.propTypes;
          else
            return;
          if (t) {
            var n2 = b(r);
            Me(t, e2.props, "prop", n2, e2);
          } else if (r.PropTypes !== void 0 && !X) {
            X = true;
            var i2 = b(r);
            s2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", i2 || "Unknown");
          }
          typeof r.getDefaultProps == "function" && !r.getDefaultProps.isReactClassApproved && s2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function nr(e2) {
        {
          for (var r = Object.keys(e2.props), t = 0; t < r.length; t++) {
            var n2 = r[t];
            if (n2 !== "children" && n2 !== "key") {
              j(e2), s2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", n2), j(null);
              break;
            }
          }
          e2.ref !== null && (j(e2), s2("Invalid attribute `ref` supplied to `React.Fragment`."), j(null));
        }
      }
      function Te(e2, r, t, n2, i2, u) {
        {
          var o = Ie(e2);
          if (!o) {
            var a = "";
            (e2 === void 0 || typeof e2 == "object" && e2 !== null && Object.keys(e2).length === 0) && (a += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var v = er();
            v ? a += v : a += ye();
            var l2;
            e2 === null ? l2 = "null" : z(e2) ? l2 = "array" : e2 !== void 0 && e2.$$typeof === E ? (l2 = "<" + (b(e2.type) || "Unknown") + " />", a = " Did you accidentally export a JSX literal instead of a component?") : l2 = typeof e2, s2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", l2, a);
          }
          var c6 = Qe(e2, r, t, i2, u);
          if (c6 == null)
            return c6;
          if (o) {
            var p2 = r.children;
            if (p2 !== void 0)
              if (n2)
                if (z(p2)) {
                  for (var k = 0; k < p2.length; k++)
                    Re(p2[k], e2);
                  Object.freeze && Object.freeze(p2);
                } else
                  s2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                Re(p2, e2);
          }
          return e2 === _ ? nr(c6) : tr(c6), c6;
        }
      }
      function ar(e2, r, t) {
        return Te(e2, r, t, true);
      }
      function or(e2, r, t) {
        return Te(e2, r, t, false);
      }
      var ir = or, ur = ar;
      W.Fragment = _, W.jsx = ir, W.jsxs = ur;
    }()), W;
  }
  process.env.NODE_ENV === "production" ? Q.exports = lr() : Q.exports = cr();
  var ee = Q.exports;
  const fr = ee.Fragment, xe = ee.jsx, gr = ee.jsxs, dr = {
    className: "",
    style: void 0,
    viewBox: " 0 0 1024 1024",
    name: "",
    width: "",
    height: "",
    onClick: () => {
    }
  }, vr = (F) => {
    const E = n$b.classPrefix, { viewBox: D, className: _, style: x, name: C, color: R, width: m2, height: f, children: T, onClick: d2 } = { ...dr, ...F }, h = (s2) => {
      d2 && d2(s2);
    }, g = (s2) => s2 === "" ? "" : isNaN(Number(s2)) ? String(s2) : s2 + "px", P = () => `${E} ${E}-${C} ${_}`, S = {}, N = g(m2 || ""), Y = g(f || "");
    N && (S.width = N), Y && (S.height = Y);
    const w = () => ({
      color: R,
      ...x,
      ...S
    });
    return /* @__PURE__ */ xe(fr, { children: /* @__PURE__ */ xe(
      "svg",
      {
        className: P(),
        style: w(),
        onClick: h,
        xmlns: "http://www.w3.org/2000/svg",
        color: R,
        viewBox: D,
        "aria-labelledby": C,
        role: "presentation",
        children: T
      }
    ) });
  }, mr = vr;
  const l$1 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowDown", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M153.81 362.67a10.67 10.67 0 0 0-7.68 18.13L512 746.67 877.87 380.8a10.67 10.67 0 0 0-7.68-18.13h-60.38a10.03 10.03 0 0 0-7.46 3.2L512 656.21 221.65 365.87a10.88 10.88 0 0 0-7.46-3.2z",
        fill: "currentColor"
      }
    ) });
  };
  const d$7 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowLeft", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M661.33 153.81a10.67 10.67 0 0 0-18.13-7.68L277.33 512 643.2 877.87a10.67 10.67 0 0 0 18.13-7.68v-60.38a10.03 10.03 0 0 0-3.2-7.46L367.79 512l290.34-290.35a10.88 10.88 0 0 0 3.2-7.46z",
        fill: "currentColor"
      }
    ) });
  };
  const i$1 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowRadius", viewBox: "0 0 8 4", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M3.253.336a1 1 0 0 1 1.494 0L8 4H0z",
        fill: "currentColor"
      }
    ) });
  };
  const p$3 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "ArrowUp", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M870.19 661.33a10.67 10.67 0 0 0 7.68-18.13L512 277.33 146.13 643.2a10.67 10.67 0 0 0 7.68 18.13h60.38c2.77 0 5.55-1.07 7.46-3.2L512 367.79l290.35 290.34c1.92 1.92 4.69 3.2 7.46 3.2z",
        fill: "currentColor"
      }
    ) });
  };
  const n$a = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Ask", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M48 24c0 13.255-10.745 24-24 24S0 37.255 0 24 10.745 0 24 0s24 10.745 24 24m-3 0c0-11.598-9.402-21-21-21C12.403 3 3 12.402 3 24s9.403 21 21 21c11.598 0 21-9.402 21-21m-21-9a4.5 4.5 0 0 0-4.472 4c-.03.275-.251.5-.527.5h-2a.476.476 0 0 1-.484-.5 7.5 7.5 0 1 1 8.983 7.85v.65a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5V24H24a4.5 4.5 0 1 0 0-9m-1.5 17a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-.5-.5z",
        fill: "currentColor"
      }
    ) });
  };
  const c$2 = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "CheckChecked", viewBox: "0 0 16 16", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m0-4a4 4 0 1 1 0-8 4 4 0 0 1 0 8",
        fill: "currentColor"
      }
    ) });
  };
  const n$9 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "CheckDisabled", viewBox: "0 0 16 16", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m3.75-7.25h-7.5A.25.25 0 0 1 4 8.5v-1a.25.25 0 0 1 .25-.25h7.5a.25.25 0 0 1 .25.25v1a.25.25 0 0 1-.25.25",
        fill: "currentColor"
      }
    ) });
  };
  const n$8 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "CheckNormal", viewBox: "0 0 16 16", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M8 15.5a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15m0 .5A8 8 0 1 0 8 0a8 8 0 0 0 0 16",
        fill: "currentColor"
      }
    ) });
  };
  const d$6 = (e2) => {
    const r = { ...dr, ...e2 };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Check", viewBox: "0 0 49 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M45.121 16.121 47.243 14 43 9.757l-2.121 2.122L19 33.757 7.121 21.88 5 19.757.757 24l2.122 2.121L14.757 38l2.122 2.121L19 42.243l2.121-2.122L23.243 38z",
        fill: "currentColor"
      }
    ) });
  };
  const n$7 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Checked", viewBox: "0 0 16 16", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m4.325-10.117-5.318 5.362-3.332-3.36a.25.25 0 0 1 0-.351l.701-.707a.25.25 0 0 1 .355 0L7.007 9.12l4.262-4.297a.25.25 0 0 1 .355 0l.701.707a.25.25 0 0 1 0 .352",
        fill: "currentColor"
      }
    ) });
  };
  const n$6 = (c6) => {
    const o = { ...dr, ...c6 };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "Close", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m512 557.23 279.25 279.25c4.27 4.27 10.88 4.27 14.94 0l30.29-30.29c4.27-4.27 4.27-10.88 0-14.94L557.23 512l279.25-279.25c4.27-4.27 4.27-10.88 0-14.94l-30.29-30.29c-4.27-4.27-10.88-4.27-14.94 0L512 466.77 232.75 187.52c-4.27-4.27-10.88-4.27-14.94 0l-30.29 30.29c-4.27 4.27-4.27 10.88 0 14.94L466.77 512 187.52 791.25c-4.27 4.27-4.27 10.88 0 14.94l30.29 30.29c4.27 4.27 10.88 4.27 14.94 0z",
        fill: "currentColor"
      }
    ) });
  };
  const n$5 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Del", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M15.5 0a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h17a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5zM48 7.5a.5.5 0 0 0-.5-.5H.5a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h3.824l2.904 26.86A8 8 0 0 0 15.182 44h17.636a7.999 7.999 0 0 0 7.953-7.14L43.676 10H47.5a.5.5 0 0 0 .5-.5zM10.21 36.537 7.343 10h33.316l-2.87 26.537A4.999 4.999 0 0 1 32.819 41H15.182a5 5 0 0 1-4.971-4.463M18.5 19a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5zm11.5.5v11a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5",
        fill: "currentColor"
      }
    ) });
  };
  const n$4 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Failure", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M48 24C48 10.745 37.255 0 24 0S0 10.745 0 24s10.745 24 24 24 24-10.745 24-24m-3 0c0 11.598-9.402 21-21 21S3 35.598 3 24 12.402 3 24 3s21 9.402 21 21m-28.146-9.268a.5.5 0 0 0-.708 0l-1.413 1.414a.5.5 0 0 0 0 .708L21.879 24l-7.146 7.146a.5.5 0 0 0 0 .708l1.413 1.414a.5.5 0 0 0 .708 0L24 26.12l7.146 7.147a.5.5 0 0 0 .708 0l1.413-1.414a.5.5 0 0 0 0-.708L26.121 24l7.146-7.146a.5.5 0 0 0 0-.708l-1.413-1.414a.5.5 0 0 0-.708 0L24 21.88z",
        fill: "currentColor"
      }
    ) });
  };
  const d$5 = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ gr(mr, { ...r, name: r.name || "ImageError", viewBox: "0 0 1024 1024", children: [
      /* @__PURE__ */ xe(
        "path",
        {
          d: "M696.43 465.25c40.61 0 73.53-32.72 73.53-73.09s-32.96-73.08-73.53-73.08-73.54 32.72-73.54 73.08 32.92 73.09 73.54 73.09M535.74 650.62l-273.61-259.4a56.19 56.19 0 0 0-15.36 11.58l-114 119.63-6-222.77c-.73-26.82 20.84-49.41 47.67-50.14l201.77-5.44 47.34-50-250.43 6.75C119 202.33 76.33 247.17 77.78 301l7.32 271.4 4.5 166.78C91.06 793 136.05 835.47 190.2 834l176-4.75 12-.32 47.34-50 116.18-122.64z",
          fill: "currentColor"
        }
      ),
      ",",
      /* @__PURE__ */ xe(
        "path",
        {
          d: "m861.71 214.8-242.83-33.86-55.09 41.46L855 263a49.05 49.05 0 0 1 41.79 55.13l-54.33 389.59-120.87-159.05A59.86 59.86 0 0 0 638.06 537l-44 33.08 65.07 86.15L603.84 698l-79.57 60.1-54.92 41.48 34.17 4.76 270.73 37.76a97.55 97.55 0 0 0 109.88-79.6 22.37 22.37 0 0 0 .65-3.44l60.53-434.16c7.44-53.32-29.95-102.62-83.6-110.1",
          fill: "currentColor"
        }
      )
    ] });
  };
  const n$3 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Image", viewBox: "0 0 49 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M48 18.85V36a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8a8 8 0 0 1 8-8h32a8 8 0 0 1 8 8v10.153c.054.226.056.465 0 .696M8 3a5 5 0 0 0-5 5V24.49A16.536 16.536 0 0 1 7 24c3.45 0 6.655 1.06 9.303 2.87C19.627 19.295 27.193 14 36 14c3.212 0 6.26.705 9 1.97V8a5 5 0 0 0-5-5zm2 9a2 2 0 1 1 4 0 2 2 0 0 1-4 0M3 27.602V36a5 5 0 0 0 5 5h32a5 5 0 0 0 5-5V19.333A18.412 18.412 0 0 0 36 17c-8.124 0-15.028 5.237-17.513 12.524a1.499 1.499 0 0 1-2.486.914A13.444 13.444 0 0 0 7 27c-1.395 0-2.738.211-4 .602",
        fill: "currentColor"
      }
    ) });
  };
  const c$1 = (a) => {
    const o = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "JoySmile", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M728.58 159.81a39.33 39.33 0 1 0-54.28-56.95c-94.92 90.4-244.1 90.4-339.03 0A39.35 39.35 0 0 0 281 159.81c125.33 119.35 322.24 119.35 447.58 0",
        fill: "currentColor"
      }
    ) });
  };
  const d$4 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Link", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M777.87 246.13a166.03 166.03 0 0 0-234.78 0l-74.39 74.24a43.89 43.89 0 0 1-62.03-62.1l74.24-74.24A253.81 253.81 0 0 1 839.9 543.01l-74.17 74.32a43.89 43.89 0 1 1-62.1-62.03l74.24-74.24a166.03 166.03 0 0 0 0-234.86zM637.44 386.56a43.89 43.89 0 0 1 0 62.03L448.66 637.51a43.89 43.89 0 1 1-62.1-62.1l188.93-188.92a43.89 43.89 0 0 1 62.1 0zm-317.07 20.11a43.89 43.89 0 0 1 0 62.03l-74.24 74.31a166.03 166.03 0 0 0 234.78 234.86l74.39-74.24a43.89 43.89 0 0 1 62.03 62.1l-74.24 74.17A253.81 253.81 0 1 1 184.1 480.99l74.17-74.32a43.89 43.89 0 0 1 62.1 0",
        fill: "currentColor"
      }
    ) });
  };
  const s = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Loading", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 73.14a43.89 43.89 0 0 1 43.89 43.89v118.49a43.89 43.89 0 0 1-87.78 0V117.03A43.89 43.89 0 0 1 512 73.14M201.65 201.65a43.89 43.89 0 0 1 62.1 0l83.68 83.83a43.89 43.89 0 1 1-62.03 62.02l-83.75-83.75a43.89 43.89 0 0 1 0-62.1m620.7 0a43.89 43.89 0 0 1 0 62.1l-83.83 83.68a43.89 43.89 0 1 1-62.02-62.03l83.75-83.82a43.89 43.89 0 0 1 62.1 0zM73.14 512a43.89 43.89 0 0 1 43.89-43.89h118.49a43.89 43.89 0 0 1 0 87.78H117.03A43.89 43.89 0 0 1 73.14 512m671.45 0a43.89 43.89 0 0 1 43.89-43.89h118.49a43.89 43.89 0 1 1 0 87.78H788.48A43.89 43.89 0 0 1 744.59 512M347.5 676.5a43.89 43.89 0 0 1 0 62.02l-83.75 83.83a43.89 43.89 0 1 1-62.1-62.1l83.83-83.68a43.89 43.89 0 0 1 62.02 0zm329 0a43.89 43.89 0 0 1 62.02 0l83.83 83.75a43.89 43.89 0 1 1-62.1 62.1l-83.68-83.83a43.89 43.89 0 0 1 0-62.02zM512 744.59a43.89 43.89 0 0 1 43.89 43.89v118.49a43.89 43.89 0 1 1-87.78 0V788.48A43.89 43.89 0 0 1 512 744.59",
        fill: "currentColor"
      }
    ) });
  };
  const d$3 = (a) => {
    const o = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "Loading1", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M520.66 64.56a29.24 29.24 0 0 0-7.07-.89c-16.21 0-29.35 13.14-29.35 29.35 0 15.83 12.54 28.7 28.23 29.29v.08c.38 0 .75-.01 1.12-.02 216.49 0 389.63 173.94 389.63 390.44S730.08 901.64 513.59 901.63 123.96 729.3 123.96 512.8c0-.27.01-.54.01-.8h-.01c0-16.21-13.14-29.35-29.35-29.35S65.26 495.79 65.26 512c0 .06.01.11.01.16 0 .21-.01.42-.01.64 0 247.61 200.72 448.33 448.33 448.33 247.61 0 448.33-200.72 448.33-448.33 0-245.24-196.92-444.46-441.25-448.24z",
        fill: "currentColor"
      }
    ) });
  };
  const m$3 = (a) => {
    const o = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...o, name: o.name || "Location", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M533.33 1024s448-232.53 448-576c0-247.47-200.53-448-448-448s-448 200.53-448 448c0 343.47 448 576 448 576m181.12-206.72c-52.91 47.57-105.81 85.33-145.92 111.36a893.32 893.32 0 0 1-35.2 21.76 1148.76 1148.76 0 0 1-181.12-133.12C244.05 719.79 149.33 591.79 149.33 448c0-212.05 171.95-384 384-384s384 171.95 384 384c0 143.79-94.72 271.79-202.88 369.28M533.33 640a192 192 0 1 0-.02-384.02 192 192 0 0 0 .02 384.02m0-64c-70.61 0-128-57.39-128-128s57.39-128 128-128 128 57.39 128 128-57.39 128-128 128",
        fill: "currentColor"
      }
    ) });
  };
  const n$2 = (r) => {
    const s2 = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...s2, name: s2.name || "MaskClose", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M512 14.9C238.59 14.9 14.9 238.6 14.9 512s223.7 497.1 497.1 497.1 497.1-223.7 497.1-497.1S785.4 14.9 512 14.9m207.13 646.23c16.57 16.57 16.57 41.42 0 58s-41.42 16.57-58 0L512 570 362.87 719.13c-16.57 16.57-41.43 16.57-58 0s-16.57-41.42 0-58L454 512 304.87 362.87c-16.57-16.57-16.57-41.43 0-58s41.42-16.57 58 0L512 454l149.13-149.13c16.57-16.57 41.43-16.57 58 0s16.57 41.42 0 58L570 512z",
        fill: "currentColor"
      }
    ) });
  };
  const i = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "Minus", viewBox: "0 0 20 20", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M0 10a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1",
        fill: "currentColor"
      }
    ) });
  };
  const l = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "More", viewBox: "0 0 40 6", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M3 6a3 3 0 1 0 0-6 3 3 0 0 0 0 6M23 3a3 3 0 1 1-6 0 3 3 0 0 1 6 0M40 3a3 3 0 1 1-6 0 3 3 0 0 1 6 0",
        fill: "currentColor"
      }
    ) });
  };
  const n$1 = (r) => {
    const c6 = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...c6, name: c6.name || "Notice", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M533.33 0C539.3 0 544 4.69 544 10.67v76.16c179.41 16.21 320 167.04 320 350.5v226.35c0 26.45 6.19 52.69 17.92 76.37l36.48 72.96c14.08 28.37-6.4 61.65-38.19 61.66H143.79c-31.79 0-52.27-33.28-38.19-61.66l36.48-72.96c11.95-23.68 17.92-49.92 17.92-76.37V437.33c0-183.68 140.59-334.29 320-350.5V10.67C480 4.7 484.69 0 490.67 0zM224 437.33v226.35c0 36.48-8.53 72.32-24.75 104.96l-21.12 42.03h667.74l-21.12-42.03C808.54 736 800 700.16 800 663.68V437.33c0-159.15-128.85-288-288-288s-288 128.85-288 288M394.67 960c-5.97 0-10.67 4.69-10.67 10.67v42.66c0 5.97 4.69 10.67 10.67 10.67h234.66c5.97 0 10.67-4.69 10.67-10.67v-42.66c0-5.97-4.69-10.67-10.67-10.67z",
        fill: "currentColor"
      }
    ) });
  };
  const e = (r) => {
    const c6 = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...c6, name: c6.name || "Photograph", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M402.35 42.67c-55.47 0-104.75 35.84-121.6 88.53l-5.98 18.13h-104.1C76.38 149.33 0 225.7 0 320v490.67c0 94.29 76.37 170.67 170.67 170.66h682.66c94.29 0 170.67-76.37 170.67-170.66V320c0-94.29-76.37-170.67-170.67-170.67h-104.1l-5.98-18.13a127.89 127.89 0 0 0-121.81-88.53zM170.67 213.33h150.61l20.27-62.29c8.53-26.45 33.07-44.37 60.8-44.37h219.09c27.73 0 52.27 17.92 61.01 44.37l20.27 62.29h150.61C912.21 213.33 960 261.12 960 320v490.67c0 58.88-47.79 106.67-106.67 106.66H170.67C111.79 917.33 64 869.54 64 810.67V320c0-58.88 47.79-106.67 106.67-106.67M725.33 288c0-5.97 4.69-10.67 10.67-10.67h106.67c5.97 0 10.67 4.69 10.66 10.67v42.67c0 5.97-4.69 10.67-10.66 10.66H736c-5.97 0-10.67-4.69-10.67-10.66zM736 554.67c0 123.73-100.27 224-224 224s-224-100.27-224-224 100.27-224 224-224 224 100.27 224 224m-64 0c0-88.32-71.68-160-160-160s-160 71.68-160 160 71.68 160 160 160 160-71.68 160-160",
        fill: "currentColor"
      }
    ) });
  };
  const d$2 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Plus", viewBox: "0 0 20 20", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M9 19a1 1 0 1 0 2 0v-8h8a1 1 0 1 0 0-2h-8V1a1 1 0 1 0-2 0v8H1a1 1 0 1 0 0 2h8z",
        fill: "currentColor"
      }
    ) });
  };
  const n = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Search", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M20 40c11.045 0 20-8.954 20-20S31.045 0 20 0C8.954 0 0 8.954 0 20s8.954 20 20 20m0-3C10.61 37 3 29.39 3 20S10.61 3 20 3s17 7.611 17 17-7.611 17-17 17m24.207 5.086a.5.5 0 0 1 0 .707l-1.414 1.414a.5.5 0 0 1-.707 0l-6.293-6.293a.5.5 0 0 1 0-.707l1.414-1.414a.5.5 0 0 1 .707 0z",
        fill: "currentColor"
      }
    ) });
  };
  const m$2 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Service", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M2 20h1.006C3.278 8.875 12.609 0 24 0c11.39 0 20.722 8.875 20.994 20H46a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-.508c-.269 7.663-6.658 13.743-14.49 13.992a.488.488 0 0 1-.502-.492v-2c0-.276.224-.499.5-.51 6.27-.245 11.223-5.075 11.49-10.99H41a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h.993C41.721 10.6 33.805 3 24 3 14.195 3 6.279 10.6 6.007 20H7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2m1 3v6h3v-6zm39 6h3v-6h-3zm-13.063-.858a.528.528 0 0 1 .72.011l1.413 1.415a.483.483 0 0 1-.007.698c-3.998 3.64-10.127 3.64-14.126 0a.483.483 0 0 1-.009-.698l1.415-1.415a.527.527 0 0 1 .718-.011 7.501 7.501 0 0 0 9.876 0",
        fill: "currentColor"
      }
    ) });
  };
  const d$1 = (l2) => {
    const a = { ...dr, ...l2 };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "StarFill", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M24 .1a1.5 1.5 0 0 1 1.296.745l7.316 12.56 14.206 3.077a1.5 1.5 0 0 1 .8 2.466l-9.684 10.839 1.464 14.462a1.5 1.5 0 0 1-2.097 1.524L24 39.91l-13.3 5.862a1.5 1.5 0 0 1-2.098-1.524l1.464-14.462-9.685-10.84a1.5 1.5 0 0 1 .802-2.465l14.205-3.076L22.704.846A1.5 1.5 0 0 1 24 .1",
        fill: "currentColor"
      }
    ) });
  };
  const m$1 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Success", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24m0-3C12.402 45 3 35.598 3 24S12.402 3 24 3s21 9.402 21 21-9.402 21-21 21m10.767-25.646a.5.5 0 0 0 0-.708l-1.413-1.414a.5.5 0 0 0-.708 0L21 28.88l-6.647-6.647a.5.5 0 0 0-.707 0l-1.414 1.414a.501.501 0 0 0 0 .708L21 33.12z",
        fill: "currentColor"
      }
    ) });
  };
  const p$2 = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Tips", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24m0-3C12.402 45 3 35.598 3 24S12.402 3 24 3s21 9.402 21 21-9.402 21-21 21m2-29.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5zM24.748 33H26.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5H23a1.5 1.5 0 0 1-1.482-1.728L23.252 23H21.5a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 1 .5-.5H25a1.5 1.5 0 0 1 1.482 1.728z",
        fill: "currentColor"
      }
    ) });
  };
  const p$1 = (r) => {
    const a = { ...dr, ...r };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Top", viewBox: "0 0 44 44", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M43.042 18.666a.6.6 0 0 1 .062.846l-1.506 1.743a.6.6 0 0 1-.846.062L23.753 6.64V42.9a.6.6 0 0 1-.6.599H20.85a.6.6 0 0 1-.6-.6V6.64L3.25 21.318a.6.6 0 0 1-.846-.062L.898 19.512a.6.6 0 0 1 .062-.846L22.001.5z",
        fill: "currentColor"
      }
    ) });
  };
  const d = (a) => {
    const r = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "TriangleDown", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m573.06 752 308.8-404.61A76.8 76.8 0 0 0 820.74 224H203.23a76.8 76.8 0 0 0-61.05 123.39L450.98 752a76.8 76.8 0 0 0 122.08 0",
        fill: "currentColor"
      }
    ) });
  };
  const p = (o) => {
    const r = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...r, name: r.name || "TriangleUp", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "m573.06 272 308.8 404.61A76.8 76.8 0 0 1 820.74 800H203.23a76.8 76.8 0 0 1-61.05-123.39L450.98 272a76.8 76.8 0 0 1 122.08 0",
        fill: "currentColor"
      }
    ) });
  };
  const m = (a) => {
    const c6 = { ...dr, ...a };
    return /* @__PURE__ */ xe(mr, { ...c6, name: c6.name || "User", viewBox: "0 0 1024 1024", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M874.67 362.67c0 142.29-81.92 265.39-200.96 324.69a513.58 513.58 0 0 1 306.98 279.47c2.99 6.83-2.13 14.51-9.81 14.5h-47.36a10.67 10.67 0 0 1-9.6-5.97C840.75 827.31 688.21 725.33 512 725.33S183.25 827.09 110.08 975.36c-1.92 3.63-5.55 5.97-9.81 5.97H52.91c-7.47 0-12.8-7.68-9.6-14.5a514.22 514.22 0 0 1 306.98-279.47c-119.04-59.52-200.96-182.61-200.96-324.69C149.33 162.35 311.68 0 512 0s362.67 162.35 362.67 362.67m-64 0C810.67 197.76 676.91 64 512 64S213.33 197.76 213.33 362.67 347.09 661.34 512 661.33s298.67-133.76 298.67-298.66m-376.11 78.29c-3.41-4.69-10.03-6.61-14.93-3.63l-36.91 21.34c-5.12 2.99-6.83 9.6-3.63 14.5A160 160 0 0 0 512 544c55.47 0 104.32-28.16 132.91-70.83 3.2-4.91 1.49-11.52-3.63-14.5l-36.91-21.34c-5.12-2.99-11.52-1.07-14.93 3.63A96.04 96.04 0 0 1 512 480c-31.57 0-59.73-15.36-77.44-39.04",
        fill: "currentColor"
      }
    ) });
  };
  const c = (o) => {
    const a = { ...dr, ...o };
    return /* @__PURE__ */ xe(mr, { ...a, name: a.name || "Warning", viewBox: "0 0 48 48", children: /* @__PURE__ */ xe(
      "path",
      {
        d: "M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24m0-3C12.403 45 3 35.598 3 24S12.403 3 24 3c11.598 0 21 9.402 21 21s-9.402 21-21 21m-1.5-32.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5zm3 19.5a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5z",
        fill: "currentColor"
      }
    ) });
  };
  var ComponentDefaults = {
    className: "",
    style: {}
  };
  var prefixCls$2 = "nut-button";
  var defaultProps$1B = _object_spread_props(_object_spread({}, ComponentDefaults), {
    color: "",
    type: "default",
    size: "normal",
    shape: "round",
    fill: "outline",
    loading: false,
    disabled: false,
    block: false,
    icon: null,
    rightIcon: null,
    nativeType: "button",
    onClick: function() {
    }
  });
  var Button = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _ref = _object_spread({}, defaultProps$1B, props), color = _ref.color, shape = _ref.shape, fill = _ref.fill, loading = _ref.loading, disabled = _ref.disabled, type2 = _ref.type, size = _ref.size, block = _ref.block, icon = _ref.icon, rightIcon = _ref.rightIcon, children = _ref.children, className = _ref.className, style = _ref.style, nativeType = _ref.nativeType, onClick = _ref.onClick, rest = _object_without_properties(_ref, [
      "color",
      "shape",
      "fill",
      "loading",
      "disabled",
      "type",
      "size",
      "block",
      "icon",
      "rightIcon",
      "children",
      "className",
      "style",
      "nativeType",
      "onClick"
    ]);
    var getStyle = React.useMemo(function() {
      var style2 = {};
      if (color) {
        if (props.fill === "outline" || props.fill === "dashed") {
          style2.color = color;
          if (!(color === null || color === void 0 ? void 0 : color.includes("gradient"))) {
            style2.borderColor = color;
          }
        } else {
          style2.color = "#fff";
          style2.background = color;
          style2.borderColor = "transparent";
        }
      }
      return style2;
    }, [
      color,
      props.fill
    ]);
    var handleClick = React.useCallback(function(e2) {
      if (!loading && !disabled && onClick) {
        onClick(e2);
      }
    }, [
      loading,
      disabled,
      onClick
    ]);
    var _obj;
    var buttonClassNames = classNames(prefixCls$2, "".concat(prefixCls$2, "-").concat(type2), (_obj = {}, _define_property(_obj, "".concat(prefixCls$2, "-").concat(type2, "-solid"), type2 === "primary" && !props.fill), _define_property(_obj, "".concat(prefixCls$2, "-").concat(fill), props.fill), _define_property(_obj, "".concat(prefixCls$2, "-").concat(type2, "-").concat(fill), props.fill), _define_property(_obj, "".concat(prefixCls$2, "-").concat(size), size), _define_property(_obj, "".concat(prefixCls$2, "-").concat(shape), shape), _define_property(_obj, "".concat(prefixCls$2, "-block"), block), _define_property(_obj, "".concat(prefixCls$2, "-disabled"), disabled || loading), _define_property(_obj, "".concat(prefixCls$2, "-").concat(type2).concat(props.fill ? "-".concat(fill) : "", "-disabled"), disabled || loading), _define_property(_obj, "".concat(prefixCls$2, "-loading"), loading), _define_property(_obj, "".concat(prefixCls$2, "-icononly"), !children), _obj), className);
    return /* @__PURE__ */ React.createElement("button", _object_spread_props(_object_spread({}, rest), {
      ref,
      type: nativeType,
      className: buttonClassNames,
      style: _object_spread({}, getStyle, style),
      onClick: handleClick
    }), /* @__PURE__ */ React.createElement("div", {
      className: "nut-button-wrap"
    }, loading && /* @__PURE__ */ React.createElement(s, {
      className: "nut-icon-loading"
    }), !loading && icon, children && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(props.fill || disabled || loading ? "nut-button-".concat(type2).concat(props.fill ? "-".concat(fill) : "").concat(disabled || loading ? "-disabled" : "") : "").concat(icon || loading ? " nut-button-text" : "").concat(rightIcon ? " nut-button-text-right" : "")
    }, children), rightIcon));
  });
  Button.displayName = "NutButton";
  var CellGroupContext = React.createContext(null);
  var defaultProps$1A = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: "",
    description: "",
    divider: true
  });
  var classPrefix$v = "nut-cell-group";
  var CellGroup = function(props) {
    var _ref = _object_spread({}, defaultProps$1A, props), children = _ref.children, className = _ref.className, title = _ref.title, description = _ref.description, divider = _ref.divider, rest = _object_without_properties(_ref, [
      "children",
      "className",
      "title",
      "description",
      "divider"
    ]);
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix$v, className)
    }, rest), title ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$v, "-title")
    }, title) : null, description ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$v, "-description")
    }, description) : null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$v, "-wrap ").concat(divider ? "".concat(classPrefix$v, "-wrap-divider") : "")
    }, /* @__PURE__ */ React.createElement(CellGroupContext.Provider, {
      value: {
        divider,
        group: true
      }
    }, React.Children.map(children, function(child, index2) {
      var _child_type;
      return (child === null || child === void 0 ? void 0 : (_child_type = child.type) === null || _child_type === void 0 ? void 0 : _child_type.displayName) === "NutCell" ? /* @__PURE__ */ React.cloneElement(child, {
        isLast: index2 === React.Children.count(children) - 1
      }) : child;
    }))));
  };
  CellGroup.displayName = "NutCellGroup";
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    // Latin-1 Supplement block.
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "c",
    "": "D",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "N",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "o",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "Y",
    "": "y",
    "": "y",
    "": "Ae",
    "": "ae",
    "": "Th",
    "": "th",
    "": "ss",
    // Latin Extended-A block.
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "C",
    "": "C",
    "": "C",
    "": "c",
    "": "c",
    "": "c",
    "": "c",
    "": "D",
    "": "D",
    "": "d",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "G",
    "": "G",
    "": "G",
    "": "G",
    "": "g",
    "": "g",
    "": "g",
    "": "g",
    "": "H",
    "": "H",
    "": "h",
    "": "h",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "J",
    "": "j",
    "": "K",
    "": "k",
    "": "k",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "N",
    "": "N",
    "": "N",
    "": "N",
    "": "n",
    "": "n",
    "": "n",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "R",
    "": "R",
    "": "R",
    "": "r",
    "": "r",
    "": "r",
    "": "S",
    "": "S",
    "": "S",
    "": "S",
    "": "s",
    "": "s",
    "": "s",
    "": "s",
    "": "T",
    "": "T",
    "": "T",
    "": "t",
    "": "t",
    "": "t",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "W",
    "": "w",
    "": "Y",
    "": "y",
    "": "Y",
    "": "Z",
    "": "Z",
    "": "Z",
    "": "z",
    "": "z",
    "": "z",
    "": "IJ",
    "": "ij",
    "": "Oe",
    "": "oe",
    "": "'n",
    "": "ss"
  };
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array2, iteratee, accumulator, initAccum) {
    var index2 = -1, length2 = array2 ? array2.length : 0;
    while (++index2 < length2) {
      accumulator = iteratee(accumulator, array2[index2], index2, array2);
    }
    return accumulator;
  }
  function asciiWords(string2) {
    return string2.match(reAsciiWord) || [];
  }
  function basePropertyOf(object2) {
    return function(key2) {
      return object2 == null ? void 0 : object2[key2];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicodeWord(string2) {
    return reHasUnicodeWord.test(string2);
  }
  function unicodeWords(string2) {
    return string2.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol$1 = root.Symbol;
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value2) {
    if (typeof value2 == "string") {
      return value2;
    }
    if (isSymbol(value2)) {
      return symbolToString ? symbolToString.call(value2) : "";
    }
    var result = value2 + "";
    return result == "0" && 1 / value2 == -Infinity ? "-0" : result;
  }
  function createCompounder(callback) {
    return function(string2) {
      return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
  }
  function toString(value2) {
    return value2 == null ? "" : baseToString(value2);
  }
  function deburr(string2) {
    string2 = toString(string2);
    return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var kebabCase = createCompounder(function(result, word, index2) {
    return result + (index2 ? "-" : "") + word.toLowerCase();
  });
  function words(string2, pattern2, guard) {
    string2 = toString(string2);
    pattern2 = pattern2;
    if (pattern2 === void 0) {
      return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
    }
    return string2.match(pattern2) || [];
  }
  var lodash_kebabcase = kebabCase;
  const kebabCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_kebabcase);
  var hasElementType = typeof Element !== "undefined";
  var hasMap = typeof Map === "function";
  var hasSet = typeof Set === "function";
  var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
  function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length2, i2, keys;
      if (Array.isArray(a)) {
        length2 = a.length;
        if (length2 != b.length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!equal(a[i2], b[i2])) return false;
        return true;
      }
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!b.has(i2.value[0])) return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!equal(i2.value[1], b.get(i2.value[0]))) return false;
        return true;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!b.has(i2.value[0])) return false;
        return true;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length2 = a.length;
        if (length2 != b.length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (a[i2] !== b[i2]) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
      keys = Object.keys(a);
      length2 = keys.length;
      if (length2 !== Object.keys(b).length) return false;
      for (i2 = length2; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
      if (hasElementType && a instanceof Element) return false;
      for (i2 = length2; i2-- !== 0; ) {
        if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a.$$typeof) {
          continue;
        }
        if (!equal(a[keys[i2]], b[keys[i2]])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }
  var reactFastCompare = function isEqual2(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || "").match(/stack|recursion/i)) {
        console.warn("react-fast-compare cannot handle circular refs");
        return false;
      }
      throw error;
    }
  };
  const isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
  function useMemo(getValue2, condition, shouldUpdate) {
    var cacheRef = React__namespace.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue2();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }
  var zhCN = {
    save: "",
    confirm: "",
    cancel: "",
    done: "",
    noData: "",
    placeholder: "",
    select: "",
    edit: "",
    reset: "",
    video: {
      errorTip: "",
      clickRetry: ""
    },
    fixednav: {
      activeText: "",
      inactiveText: ""
    },
    infiniteloading: {
      pullRefreshText: "",
      loadText: "",
      loadMoreText: ""
    },
    pagination: {
      prev: "",
      next: ""
    },
    range: {
      rangeText: ""
    },
    calendaritem: {
      weekdays: [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ],
      end: "",
      start: "",
      confirm: "",
      title: "",
      monthTitle: function(year, month) {
        return "".concat(year, "").concat(Number(month) < 10 ? "0".concat(Number(month)) : month, "");
      },
      today: "",
      loadPreviousMonth: "",
      noEarlierMonth: ""
    },
    shortpassword: {
      title: "",
      description: "",
      tips: ""
    },
    uploader: {
      list: "",
      ready: "",
      readyUpload: "",
      waitingUpload: "",
      uploading: "...",
      success: "",
      error: "",
      deleteWord: ""
    },
    countdown: {
      day: "",
      hour: "",
      minute: "",
      second: ""
    },
    address: {
      selectRegion: "",
      deliveryTo: "",
      chooseAnotherAddress: "",
      hotCity: "",
      selectProvince: "/"
    },
    signature: {
      reSign: "",
      unsupported: "Canvas"
    },
    ecard: {
      chooseText: "",
      otherValueText: "",
      placeholder: "1-5000"
    },
    timeselect: {
      pickupTime: ""
    },
    sku: {
      buyNow: "",
      buyNumber: "",
      addToCard: ""
    },
    skuheader: {
      skuId: ""
    },
    addresslist: {
      addAddress: ""
    },
    comment: {
      complaintsText: "",
      additionalReview: function(day) {
        return "".concat(day, "");
      },
      additionalImages: function(length2) {
        return "".concat(length2, "");
      }
    },
    searchbar: {
      basePlaceholder: "",
      text: "",
      test: "",
      title1: "",
      title2: "",
      title3: "",
      title4: "",
      title5: "",
      title6: ""
    },
    audio: {
      back: "",
      forward: "",
      pause: "",
      start: "",
      mute: "",
      tips: "onPlayEndloop=false"
    },
    avatarCropper: {
      rotate: "",
      selectImage: ""
    },
    datepicker: {
      year: "",
      month: "",
      day: "",
      hour: "",
      min: "",
      seconds: ""
    },
    pullToRefresh: {
      pullingText: "",
      canReleaseText: "",
      refreshingText: "",
      completeText: ""
    },
    tour: {
      prevStepText: "",
      completeText: "",
      nextStepText: ""
    },
    watermark: {
      errorCanvasTips: "Canvas"
    }
  };
  function bound(position2, min, max) {
    var ret = position2;
    if (min !== void 0) {
      ret = Math.max(position2, min);
    }
    if (max !== void 0) {
      ret = Math.min(ret, max);
    }
    return ret;
  }
  var UPPERCASE = RegExp("[\\p{Lu}]", "u");
  var LOWERCASE = RegExp("[\\p{Ll}]", "u");
  var LEADING_CAPITAL = RegExp("^[\\p{Lu}](?![\\p{Lu}])", "gu");
  var IDENTIFIER = RegExp("([\\p{Alpha}\\p{N}_]|$)", "u");
  var SEPARATORS = /[_.\- ]+/;
  var LEADING_SEPARATORS = new RegExp("^".concat(SEPARATORS.source));
  var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
  var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+".concat(IDENTIFIER.source), "gu");
  var preserveCamelCase = function(string2, toLowerCase, toUpperCase) {
    var isLastCharLower = false;
    var isLastCharUpper = false;
    var isLastLastCharUpper = false;
    for (var index2 = 0; index2 < string2.length; index2++) {
      var character = string2[index2];
      if (isLastCharLower && UPPERCASE.test(character)) {
        string2 = "".concat(string2.slice(0, index2), "-").concat(string2.slice(index2));
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        index2++;
      } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
        string2 = "".concat(string2.slice(0, index2 - 1), "-").concat(string2.slice(index2 - 1));
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
      }
    }
    return string2;
  };
  var preserveConsecutiveUppercase = function(input, toLowerCase) {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replace(LEADING_CAPITAL, function(m1) {
      return toLowerCase(m1);
    });
  };
  var postProcess = function(input, toUpperCase) {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replace(SEPARATORS_AND_IDENTIFIER, function(_, identifier) {
      return toUpperCase(identifier);
    }).replace(NUMBERS_AND_IDENTIFIER, function(m2) {
      return toUpperCase(m2);
    });
  };
  var camelCase = function(input, options2) {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options2 = _object_spread({
      pascalCase: false,
      preserveConsecutiveUppercase: false
    }, options2);
    if (Array.isArray(input)) {
      input = input.map(function(x) {
        return x.trim();
      }).filter(function(x) {
        return x.length;
      }).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    var toLowerCase = options2.locale === false ? function(string2) {
      return string2.toLowerCase();
    } : function(string2) {
      return string2.toLocaleLowerCase(options2.locale);
    };
    var toUpperCase = options2.locale === false ? function(string2) {
      return string2.toUpperCase();
    } : function(string2) {
      return string2.toLocaleUpperCase(options2.locale);
    };
    if (input.length === 1) {
      if (SEPARATORS.test(input)) {
        return "";
      }
      return options2.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    var hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
      input = preserveCamelCase(input, toLowerCase, toUpperCase);
    }
    input = input.replace(LEADING_SEPARATORS, "");
    input = options2.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
    if (options2.pascalCase) {
      input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
  };
  var canUseDom = !!(typeof window !== "undefined" && typeof document !== "undefined" && window.document && window.document.createElement);
  var clamp$2 = function(num, min, max) {
    return Math.min(Math.max(num, min), max);
  };
  function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
    return arr2;
  }
  function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
  }
  function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
      return Array.from(iter);
    }
  }
  function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(n2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _array_like_to_array(o, minLen);
  }
  function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
  }
  var Utils = {
    /**
    * 
    * @return {Boolse} true|false
    */
    isLeapYear: function isLeapYear(y) {
      return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0;
    },
    /**
    * 
    * @return {String}
    */
    getWhatDay: function getWhatDay(year, month, day) {
      var date2 = new Date("".concat(year, "/").concat(month, "/").concat(day));
      var index2 = date2.getDay();
      var dayNames = [
        "",
        "",
        "",
        "",
        "",
        "",
        ""
      ];
      return dayNames[index2];
    },
    /**
    * 
    * @return {Number}
    */
    getMonthPreDay: function getMonthPreDay(year, month) {
      var date2 = new Date("".concat(year, "/").concat(month, "/01"));
      var day = date2.getDay();
      if (day === 0) {
        day = 7;
      }
      return day;
    },
    /**
    * 
    * @return {Number}
    */
    getMonthDays: function getMonthDays(year, month) {
      if (/^0/.test(month)) {
        month = month.split("")[1];
      }
      return [
        0,
        31,
        this.isLeapYear(Number(year)) ? 29 : 28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
      ][month];
    },
    /**
    * 
    * @return {string}
    */
    getNumTwoBit: function getNumTwoBit(n2) {
      n2 = Number(n2);
      return (n2 > 9 ? "" : "0") + n2;
    },
    /**
    * 
    * @return {string}
    */
    date2Str: function date2Str(date2, split) {
      split = split || "-";
      var y = date2.getFullYear();
      var m2 = this.getNumTwoBit(date2.getMonth() + 1);
      var d2 = this.getNumTwoBit(date2.getDate());
      return [
        y,
        m2,
        d2
      ].join(split);
    },
    /**
    * 
    * @param {Number} 012
    * @return {string} '2014-12-31'
    */
    getDay: function getDay(i2) {
      i2 = i2 || 0;
      var date2 = /* @__PURE__ */ new Date();
      var diff = i2 * (1e3 * 60 * 60 * 24);
      date2 = new Date(date2.getTime() + diff);
      return this.date2Str(date2);
    },
    /**
    * 
    * @return {Boolean}
    */
    compareDate: function compareDate(date1, date2) {
      var startTime = new Date(date1.replace("-", "/").replace("-", "/"));
      var endTime = new Date(date2.replace("-", "/").replace("-", "/"));
      if (startTime >= endTime) {
        return false;
      }
      return true;
    },
    /**
    * 
    * @return {Boolean}
    */
    isEqual: function isEqual2(date1, date2) {
      var startTime = new Date((date1 || "").replace(/-/g, "/")).getTime();
      var endTime = new Date(date2.replace(/-/g, "/")).getTime();
      if (startTime === endTime) {
        return true;
      }
      return false;
    },
    getMonthWeek: function getMonthWeek(year, month, date2) {
      var firstDayOfWeek = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dateNow = new Date(Number(year), parseInt(month) - 1, Number(date2));
      var w = dateNow.getDay();
      var d2 = dateNow.getDate();
      var remainder = 6 - w;
      if (firstDayOfWeek !== 0) {
        w = w === 0 ? 7 : w;
        remainder = 7 - w;
      }
      return Math.ceil((d2 + remainder) / 7);
    },
    getYearWeek: function getYearWeek(year, month, date2) {
      var dateNow = new Date(Number(year), parseInt(month) - 1, Number(date2));
      var dateFirst = new Date(Number(year), 0, 1);
      var dataNumber = Math.round((dateNow.valueOf() - dateFirst.valueOf()) / 864e5);
      return Math.ceil((dataNumber + (dateFirst.getDay() + 1 - 1)) / 7);
    },
    getWeekDate: function getWeekDate(year, month, date2) {
      var firstDayOfWeek = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var dateNow = new Date(Number(year), parseInt(month) - 1, Number(date2));
      var nowTime = dateNow.getTime();
      var day = dateNow.getDay();
      if (firstDayOfWeek === 0) {
        var oneDayTime = 24 * 60 * 60 * 1e3;
        var SundayTime = nowTime - day * oneDayTime;
        var SaturdayTime = nowTime + (6 - day) * oneDayTime;
        var sunday = this.date2Str(new Date(SundayTime));
        var saturday = this.date2Str(new Date(SaturdayTime));
        return [
          sunday,
          saturday
        ];
      }
      day = day === 0 ? 7 : day;
      var oneDayTime1 = 24 * 60 * 60 * 1e3;
      var MondayTime = nowTime - (day - 1) * oneDayTime1;
      var SundayTime1 = nowTime + (7 - day) * oneDayTime1;
      var monday = this.date2Str(new Date(MondayTime));
      var sunday1 = this.date2Str(new Date(SundayTime1));
      return [
        monday,
        sunday1
      ];
    },
    formatResultDate: function formatResultDate(date2) {
      var days = _to_consumable_array(date2.split("-"));
      days[2] = Utils.getNumTwoBit(Number(days[2]));
      days[3] = "".concat(days[0], "-").concat(days[1], "-").concat(days[2]);
      days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
      return days;
    }
  };
  var getCurrMonthData = function(type2, year, month) {
    switch (type2) {
      case "prev":
        month === 1 && (year -= 1);
        month = month === 1 ? 12 : --month;
        break;
      case "next":
        month === 12 && (year += 1);
        month = month === 12 ? 1 : ++month;
        break;
    }
    return [
      year,
      Utils.getNumTwoBit(month),
      Utils.getMonthDays(String(year), String(month))
    ];
  };
  var getDaysStatus = function(type2, year, month) {
    var days = Utils.getMonthDays("".concat(year), "".concat(month));
    if (type2 === "prev" && days >= 7) {
      days -= 7;
    }
    return Array.from(Array(days), function(v, k) {
      return {
        day: k + 1,
        type: type2,
        year,
        month
      };
    });
  };
  var getPreMonthDates = function(type2, year, month, firstDayOfWeek) {
    var preMonth = +month - 1;
    var preYear = year;
    if (preMonth <= 0) {
      preMonth = 12;
      preYear += 1;
    }
    var days = Utils.getMonthPreDay(+year, +month);
    days -= firstDayOfWeek;
    if (type2 === "prev" && days >= 7) {
      days -= 7;
    }
    var preDates = Utils.getMonthDays("".concat(preYear), "".concat(preMonth));
    var months = Array.from(Array(preDates), function(v, k) {
      return {
        day: k + 1,
        type: type2,
        preYear,
        preMonth
      };
    });
    return months.slice(preDates - days);
  };
  var inBrowser = typeof document !== "undefined" && !!document.scripts;
  function isWindow(val2) {
    return val2 === window;
  }
  var getRect = function(elementRef) {
    var element = elementRef;
    if (isWindow(element)) {
      var width2 = element.innerWidth;
      var height2 = element.innerHeight;
      return {
        top: 0,
        left: 0,
        right: width2,
        bottom: height2,
        width: width2,
        height: height2
      };
    }
    if (element && element.getBoundingClientRect) {
      return element.getBoundingClientRect();
    }
    return {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    };
  };
  var defaultRoot = canUseDom ? window : void 0;
  var overflowStylePatterns = [
    "scroll",
    "auto",
    "overlay"
  ];
  function isElement(node) {
    var ELEMENT_NODE_TYPE = 1;
    return node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent(el) {
    var root2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultRoot;
    var node = el;
    while (node && node !== root2 && isElement(node)) {
      if (node === document.body) {
        return root2;
      }
      var overflowY = window.getComputedStyle(node).overflowY;
      if (overflowStylePatterns.includes(overflowY) && node.scrollHeight > node.clientHeight) {
        return node;
      }
      node = node.parentNode;
    }
    return root2;
  }
  function getAllScrollableParents(element) {
    var scrollableParents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!element) {
      return scrollableParents;
    }
    var isScrollable = element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
    if (isScrollable) {
      if (element.nodeName === "HTML") {
        scrollableParents.push(document);
      } else {
        scrollableParents.push(element);
      }
    }
    return getAllScrollableParents(element.parentElement, scrollableParents);
  }
  function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
  }
  var isObject = function(val2) {
    return val2 !== null && (typeof val2 === "undefined" ? "undefined" : _type_of(val2)) === "object";
  };
  var isFunction = function(val2) {
    return typeof val2 === "function";
  };
  var isPromise = function(val2) {
    return isObject(val2) && isFunction(val2.then) && isFunction(val2.catch);
  };
  var funcInterceptor = function(interceptor, param) {
    var _param_args = param.args, args = _param_args === void 0 ? [] : _param_args, done = param.done, canceled = param.canceled;
    if (interceptor) {
      var returnVal = interceptor.apply(null, args);
      if (isPromise(returnVal)) {
        returnVal.then(function(value2) {
          if (value2) {
            done(value2);
          } else if (canceled) {
            canceled();
          }
        }).catch(function() {
        });
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  };
  var isDate = function(val2) {
    return Object.prototype.toString.call(val2) === "[object Date]" && !Number.isNaN(val2.getTime());
  };
  var isEmpty = function(p2) {
    if (p2 === null || p2 === void 0) return true;
    if ((typeof p2 === "undefined" ? "undefined" : _type_of(p2)) === "object" && Object.keys(p2).length === 0) return true;
    if (Array.isArray(p2) && p2.length === 0) return true;
    return false;
  };
  function isForwardRefComponent(component) {
    return component.type && component.type.$$typeof && // eslint-disable-next-line react/display-name
    React.forwardRef(
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      function() {
      }
    ).$$typeof === component.type.$$typeof;
  }
  function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var MiniLru = /* @__PURE__ */ function() {
    function MiniLru2(capacity) {
      _class_call_check(this, MiniLru2);
      _define_property(this, "cache", void 0);
      _define_property(this, "capacity", void 0);
      if (capacity <= 0) {
        throw new Error("Cache capacity must be a positive number");
      }
      this.cache = /* @__PURE__ */ new Map();
      this.capacity = capacity;
    }
    _create_class(MiniLru2, [
      {
        key: "get",
        value: function get(key2) {
          if (this.cache.has(key2)) {
            var value2 = this.cache.get(key2);
            this.cache.delete(key2);
            this.cache.set(key2, value2);
            return value2;
          }
          return null;
        }
      },
      {
        key: "set",
        value: function set(key2, value2) {
          if (this.cache.has(key2)) {
            this.cache.delete(key2);
          } else if (this.cache.size >= this.capacity) {
            this.cache.delete(this.cache.keys().next().value);
          }
          this.cache.set(key2, value2);
        }
      },
      {
        key: "has",
        value: function has2(key2) {
          return this.cache.has(key2);
        }
      }
    ]);
    return MiniLru2;
  }();
  function main() {
    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
      items[_key] = arguments[_key];
    }
    return merge.apply(void 0, _to_consumable_array(items));
  }
  main.clone = clone;
  main.isPlainObject = isPlainObject;
  main.recursive = recursive;
  function merge() {
    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
      items[_key] = arguments[_key];
    }
    return _merge(items[0] === true, false, items);
  }
  function recursive() {
    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
      items[_key] = arguments[_key];
    }
    return _merge(items[0] === true, true, items);
  }
  function clone(input) {
    if (Array.isArray(input)) {
      var output = [];
      for (var index2 = 0; index2 < input.length; ++index2) output.push(clone(input[index2]));
      return output;
    }
    if (isPlainObject(input)) {
      var output1 = {};
      for (var index1 in input) output1[index1] = clone(input[index1]);
      return output1;
    }
    return input;
  }
  function isPlainObject(input) {
    if (input === null || (typeof input === "undefined" ? "undefined" : _type_of(input)) !== "object") return false;
    if (Object.getPrototypeOf(input) === null) return true;
    var ref = input;
    while (Object.getPrototypeOf(ref) !== null) ref = Object.getPrototypeOf(ref);
    return Object.getPrototypeOf(input) === ref;
  }
  function _recursiveMerge(base, extend) {
    if (!isPlainObject(base) || !isPlainObject(extend)) return extend;
    for (var key2 in extend) {
      if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") continue;
      base[key2] = isPlainObject(base[key2]) && isPlainObject(extend[key2]) ? _recursiveMerge(base[key2], extend[key2]) : extend[key2];
    }
    return base;
  }
  function _merge(isClone, isRecursive, items) {
    var result;
    if (isClone || !isPlainObject(result = items.shift())) result = {};
    for (var index2 = 0; index2 < items.length; ++index2) {
      var item = items[index2];
      if (!isPlainObject(item)) continue;
      for (var key2 in item) {
        if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") continue;
        var value2 = isClone ? clone(item[key2]) : item[key2];
        result[key2] = isRecursive ? _recursiveMerge(result[key2], value2) : value2;
      }
    }
    return result;
  }
  function mergeProps() {
    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
      items[_key] = arguments[_key];
    }
    var ret = {};
    items.forEach(function(item) {
      if (item) {
        Object.keys(item).forEach(function(key2) {
          if (item[key2] !== void 0) {
            ret[key2] = item[key2];
          }
        });
      }
    });
    return ret;
  }
  function mergeProp(defaultProp) {
    for (var _len = arguments.length, propList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      propList[_key - 1] = arguments[_key];
    }
    for (var i2 = propList.length - 1; i2 >= 0; i2 -= 1) {
      if (propList[i2] !== void 0) {
        return propList[i2];
      }
    }
    return defaultProp;
  }
  var padZero = function(num) {
    var targetLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var str = "".concat(num);
    while (str.length < targetLength) {
      str = "0".concat(str);
    }
    return str;
  };
  function preventDefault$1(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      event.stopPropagation();
    }
  }
  var pxCheck = function(value2) {
    return parseFloat(value2.toString());
  };
  function requestAniFrame() {
    if (inBrowser) {
      var _window = window;
      return _window.requestAnimationFrame || _window.webkitRequestAnimationFrame || function(callback) {
        _window.setTimeout(callback, 1e3 / 60);
      };
    }
    return function(callback) {
      setTimeout(callback, 1e3 / 60);
    };
  }
  function cancelRaf(id) {
    if (inBrowser) {
      var _window = window;
      (_window.cancelAnimationFrame || _window.webkitCancelAnimationFrame)(id);
    } else {
      clearTimeout(id);
    }
  }
  const requestAniFrame$1 = requestAniFrame();
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
    try {
      var info = gen[key2](arg);
      var value2 = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) resolve(value2);
    else Promise.resolve(value2).then(_next, _throw);
  }
  function _async_to_generator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value2) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value2);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var fullClone = _object_spread({}, ReactDOM__namespace);
  var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
  var createRoot;
  try {
    var mainVersion = Number((version || "").split(".")[0]);
    if (mainVersion >= 18 && fullClone.createRoot) {
      createRoot = fullClone.createRoot;
    }
  } catch (e2) {
  }
  function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && (typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "undefined" ? "undefined" : _type_of(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  var MARK = "__nutui_react_root__";
  function legacyRender(node, container) {
    reactRender(node, container);
  }
  function concurrentRender(node, container) {
    toggleWarning(true);
    var root2 = container[MARK] || createRoot(container);
    toggleWarning(false);
    root2.render(node);
    container[MARK] = root2;
  }
  function render(node, container) {
    if (createRoot) {
      concurrentRender(node, container);
      return;
    }
    legacyRender(node, container);
  }
  function legacyUnmount(container) {
    return unmountComponentAtNode(container);
  }
  function concurrentUnmount(container) {
    return _concurrentUnmount.apply(this, arguments);
  }
  function _concurrentUnmount() {
    _concurrentUnmount = _async_to_generator(function(container) {
      return __generator(this, function(_state) {
        return [
          2,
          Promise.resolve().then(function() {
            var _container_MARK;
            (_container_MARK = container[MARK]) === null || _container_MARK === void 0 ? void 0 : _container_MARK.unmount();
            delete container[MARK];
          })
        ];
      });
    });
    return _concurrentUnmount.apply(this, arguments);
  }
  function unmount(container) {
    if (createRoot) {
      return concurrentUnmount(container);
    }
    return legacyUnmount(container);
  }
  function rubberband$1(distance, dimension, constant) {
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds$1(position2, min, max, dimension) {
    var constant = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.15;
    if (constant === 0) return bound(position2, min, max);
    if (position2 < min) return -rubberband$1(min - position2, dimension, constant) + min;
    if (position2 > max) return +rubberband$1(position2 - max, dimension, constant) + max;
    return position2;
  }
  var sleep = function(time2) {
    return new Promise(function(resolve) {
      return setTimeout(resolve, time2);
    });
  };
  exports.passiveSupported = false;
  if (canUseDom) {
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: function get() {
          exports.passiveSupported = true;
        }
      });
      window.addEventListener("test-passive-supported", null, opts);
    } catch (e2) {
      console.log("supported passive error", e2);
    }
  }
  function toArray$1(value2) {
    if (value2 === void 0 || value2 === null) {
      return [];
    }
    return Array.isArray(value2) ? value2 : [
      value2
    ];
  }
  var upperCaseFirst = function(str) {
    str = str.toLowerCase();
    str = str.replace(/\b\w+\b/g, function(word) {
      return word.substring(0, 1).toUpperCase() + word.substring(1);
    });
    return str;
  };
  var classPrefix$u = "nut-configprovider";
  var defaultConfigRef = {
    current: {
      locale: zhCN
    }
  };
  var setDefaultConfig = function(config2) {
    defaultConfigRef.current = config2;
  };
  var getDefaultConfig = function() {
    return defaultConfigRef.current;
  };
  var ConfigContext = /* @__PURE__ */ React.createContext(null);
  var useConfig = function() {
    var _useContext;
    return (_useContext = React.useContext(ConfigContext)) !== null && _useContext !== void 0 ? _useContext : getDefaultConfig();
  };
  function convertThemeVarsToCSSVars(themeVars) {
    var cssVars = {};
    Object.keys(themeVars).forEach(function(key2) {
      cssVars["--".concat(kebabCase$1(key2))] = themeVars[key2];
    });
    return cssVars;
  }
  var useRtl = function() {
    var direction = useConfig().direction;
    if (direction) {
      return direction === "rtl";
    }
    return inBrowser && document.dir === "rtl";
  };
  var ConfigProvider = function(props) {
    var style = props.style, className = props.className, children = props.children, direction = props.direction, config2 = _object_without_properties(props, [
      "style",
      "className",
      "children",
      "direction"
    ]);
    var mergedConfig = useMemo(function() {
      return _object_spread_props(_object_spread({}, getDefaultConfig(), config2), {
        direction
      });
    }, [
      config2,
      direction
    ], function(prev, next) {
      return prev.some(function(prevTheme, index2) {
        var nextTheme = next[index2];
        return !isEqual$1(prevTheme, nextTheme);
      });
    });
    var cssVarStyle = React.useMemo(function() {
      return convertThemeVarsToCSSVars(mergedConfig.theme || {});
    }, [
      mergedConfig.theme
    ]);
    return /* @__PURE__ */ React.createElement(ConfigContext.Provider, {
      value: mergedConfig
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix$u, className),
      style: _object_spread_props(_object_spread({}, cssVarStyle, style), {
        direction
      }),
      dir: direction
    }, children));
  };
  ConfigProvider.displayName = "NutConfigProvider";
  var defaultProps$1z = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: null,
    description: null,
    extra: null,
    radius: "6px",
    align: "flex-start",
    clickable: false,
    isLast: false,
    onClick: function(event) {
    }
  });
  var classPrefix$t = "nut-cell";
  var Cell = function(props) {
    var ctx2 = React.useContext(CellGroupContext);
    var _ref = _object_spread({}, defaultProps$1z, props), children = _ref.children, clickable = _ref.clickable, onClick = _ref.onClick, title = _ref.title, description = _ref.description, extra = _ref.extra, radius = _ref.radius, align = _ref.align, isLast = _ref.isLast, className = _ref.className, style = _ref.style, rest = _object_without_properties(_ref, [
      "children",
      "clickable",
      "onClick",
      "title",
      "description",
      "extra",
      "radius",
      "align",
      "isLast",
      "className",
      "style"
    ]);
    var rtl = useRtl();
    var handleClick = function(event) {
      onClick(event);
    };
    var baseStyle = _object_spread_props(_object_spread({}, style), {
      borderRadius: Number.isNaN(Number(radius)) ? String(radius) : "".concat(radius, "px"),
      alignItems: align
    });
    var _obj;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classNames([
        classPrefix$t,
        className,
        _define_property({}, "".concat(classPrefix$t, "-group-item"), ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.group)
      ], clickable ? "".concat(classPrefix$t, "-clickable") : "")),
      onClick: function(event) {
        return handleClick(event);
      },
      style: baseStyle
    }, rest), children || /* @__PURE__ */ React.createElement(React.Fragment, null, title || description ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$t, "-left")
    }, title ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$t, "-title")
    }, title) : null, description ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$t, "-description")
    }, description) : null) : null, extra ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$t, "-extra")
    }, extra) : null)), (ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.divider) && !isLast ? /* @__PURE__ */ React.createElement("div", {
      className: classNames([
        (_obj = {}, _define_property(_obj, "".concat(classPrefix$t, "-divider"), true), _define_property(_obj, "".concat(classPrefix$t, "-divider-rtl"), rtl), _obj)
      ])
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$t, "-divider-inner")
    })) : null);
  };
  Cell.displayName = "NutCell";
  Cell.Group = CellGroup;
  function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterable_to_array_limit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _sliced_to_array(arr, i2) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i2) || _unsupported_iterable_to_array(arr, i2) || _non_iterable_rest();
  }
  var defaultProps$1y = _object_spread_props(_object_spread({}, ComponentDefaults), {
    fit: "fill",
    position: "center",
    alt: "",
    width: "",
    height: "",
    error: true,
    loading: true,
    lazy: false
  });
  var classPrefix$s = "nut-image";
  var Image$1 = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1y, props), className = _$_object_spread.className, style = _$_object_spread.style, src = _$_object_spread.src, fit = _$_object_spread.fit, position2 = _$_object_spread.position, alt = _$_object_spread.alt, width2 = _$_object_spread.width, height2 = _$_object_spread.height, radius = _$_object_spread.radius, error = _$_object_spread.error, loading = _$_object_spread.loading, lazy = _$_object_spread.lazy, draggable = _$_object_spread.draggable, onClick = _$_object_spread.onClick, onLoad = _$_object_spread.onLoad, onError = _$_object_spread.onError;
    var _useState = _sliced_to_array(React.useState(false), 2), innerLoading = _useState[0], setInnerLoading = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(false), 2), isError = _useState1[0], setIsError = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(false), 2), complete = _useState2[0], setComplete = _useState2[1];
    var imgRef = React.useRef(null);
    var pxCheck2 = function(value2) {
      return Number.isNaN(Number(value2)) ? String(value2) : "".concat(value2, "px");
    };
    React.useEffect(function() {
      if (imgRef.current && imgRef.current.complete && !lazy) {
        if (imgRef.current.naturalHeight === 0) {
          handleError();
        } else {
          handleLoad();
        }
      } else {
        setInnerLoading(true);
      }
    }, [
      imgRef
    ]);
    React.useEffect(function() {
      setComplete(false);
    }, [
      src
    ]);
    var handleLoad = function() {
      if (!complete) {
        setIsError(false);
        setInnerLoading(false);
        onLoad && onLoad();
        setComplete(true);
      }
    };
    var handleError = function() {
      if (!complete) {
        setIsError(true);
        setInnerLoading(false);
        onError && onError();
        setComplete(true);
      }
    };
    var containerStyle = _object_spread({
      height: height2 ? pxCheck2(height2) : "",
      width: width2 ? pxCheck2(width2) : "",
      overflow: radius !== void 0 && radius !== null ? "hidden" : "",
      borderRadius: radius !== void 0 && radius !== null ? pxCheck2(radius) : ""
    }, style);
    var imgStyle = _object_spread({
      objectFit: fit,
      objectPosition: position2
    }, style);
    var observer = React.useRef(null);
    var initObserver = function() {
      var options2 = {
        threshold: [
          0
        ],
        rootMargin: "0px"
      };
      observer.current = new IntersectionObserver(function(entires, self2) {
        entires.forEach(function(item) {
          if (item.isIntersecting) {
            setTimeout(function() {
              var img = item.target;
              if (img.dataset.src) {
                img.src = img.dataset.src;
                img.removeAttribute("data-src");
              }
              resetObserver();
            }, 300);
          }
        });
      }, options2);
      observer.current.observe(imgRef.current);
    };
    var resetObserver = function() {
      observer.current.disconnect && observer.current.disconnect();
    };
    React.useEffect(function() {
      lazy && initObserver();
      return function() {
        lazy && resetObserver();
      };
    }, [
      lazy
    ]);
    var imageClick = function(event) {
      onClick && onClick(event);
    };
    var renderErrorImg = React.useCallback(function() {
      if (!isError) return null;
      if (typeof error === "boolean" && error === true && !innerLoading) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix$s, "-error")
        }, /* @__PURE__ */ React.createElement(d$5, null));
      }
      if (/* @__PURE__ */ React.isValidElement(error) && !innerLoading) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix$s, "-error")
        }, error);
      }
      return null;
    }, [
      error,
      isError
    ]);
    var renderLoading = React.useCallback(function() {
      if (!loading) return null;
      if (typeof loading === "boolean" && loading === true && innerLoading) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix$s, "-loading")
        }, /* @__PURE__ */ React.createElement(n$3, null));
      }
      if (/* @__PURE__ */ React.isValidElement(loading) && innerLoading) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix$s, "-loading")
        }, loading);
      }
      return null;
    }, [
      loading,
      innerLoading
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix$s, className),
      style: containerStyle,
      onClick: function(e2) {
        imageClick(e2);
      }
    }, lazy ? /* @__PURE__ */ React.createElement("img", {
      ref: imgRef,
      className: "".concat(classPrefix$s, "-default lazyload"),
      style: imgStyle,
      "data-src": src,
      alt,
      loading: "lazy",
      onLoad: handleLoad,
      onError: handleError,
      draggable
    }) : /* @__PURE__ */ React.createElement("img", {
      ref: imgRef,
      className: "".concat(classPrefix$s, "-default"),
      style: imgStyle,
      src,
      alt,
      onLoad: handleLoad,
      onError: handleError,
      draggable
    }), renderLoading(), renderErrorImg());
  };
  Image$1.displayName = "NutImage";
  function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e2 = 1; e2 < arguments.length; e2++) {
        var t = arguments[e2];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n2[r] = t[r]);
      }
      return n2;
    }, _extends$4.apply(null, arguments);
  }
  function _objectWithoutPropertiesLoose$4(r, e2) {
    if (null == r) return {};
    var t = {};
    for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
      if (e2.includes(n2)) continue;
      t[n2] = r[n2];
    }
    return t;
  }
  function _setPrototypeOf$1(t, e2) {
    return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
      return t2.__proto__ = e3, t2;
    }, _setPrototypeOf$1(t, e2);
  }
  function _inheritsLoose$1(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf$1(t, o);
  }
  var propTypes = { exports: {} };
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = "function" === typeof Symbol && Symbol.for, c6 = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e2 = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l2 = b ? Symbol.for("react.async_mode") : 60111, m2 = b ? Symbol.for("react.concurrent_mode") : 60111, n2 = b ? Symbol.for("react.forward_ref") : 60112, p2 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c6:
            switch (a = a.type, a) {
              case l2:
              case m2:
              case e2:
              case g:
              case f:
              case p2:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n2:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d2:
            return u;
        }
      }
    }
    function A(a) {
      return z(a) === m2;
    }
    reactIs_production_min.AsyncMode = l2;
    reactIs_production_min.ConcurrentMode = m2;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c6;
    reactIs_production_min.ForwardRef = n2;
    reactIs_production_min.Fragment = e2;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d2;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f;
    reactIs_production_min.Suspense = p2;
    reactIs_production_min.isAsyncMode = function(a) {
      return A(a) || z(a) === l2;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a) {
      return z(a) === k;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return z(a) === h;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c6;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return z(a) === n2;
    };
    reactIs_production_min.isFragment = function(a) {
      return z(a) === e2;
    };
    reactIs_production_min.isLazy = function(a) {
      return z(a) === t;
    };
    reactIs_production_min.isMemo = function(a) {
      return z(a) === r;
    };
    reactIs_production_min.isPortal = function(a) {
      return z(a) === d2;
    };
    reactIs_production_min.isProfiler = function(a) {
      return z(a) === g;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return z(a) === f;
    };
    reactIs_production_min.isSuspense = function(a) {
      return z(a) === p2;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e2 || a === m2 || a === g || a === f || a === p2 || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n2 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    reactIs_production_min.typeOf = z;
    return reactIs_production_min;
  }
  var reactIs_development = {};
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_development;
  function requireReactIs_development() {
    if (hasRequiredReactIs_development) return reactIs_development;
    hasRequiredReactIs_development = 1;
    if (process.env.NODE_ENV !== "production") {
      (function() {
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object2.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        reactIs_development.AsyncMode = AsyncMode;
        reactIs_development.ConcurrentMode = ConcurrentMode;
        reactIs_development.ContextConsumer = ContextConsumer;
        reactIs_development.ContextProvider = ContextProvider;
        reactIs_development.Element = Element2;
        reactIs_development.ForwardRef = ForwardRef;
        reactIs_development.Fragment = Fragment;
        reactIs_development.Lazy = Lazy;
        reactIs_development.Memo = Memo;
        reactIs_development.Portal = Portal;
        reactIs_development.Profiler = Profiler;
        reactIs_development.StrictMode = StrictMode;
        reactIs_development.Suspense = Suspense;
        reactIs_development.isAsyncMode = isAsyncMode;
        reactIs_development.isConcurrentMode = isConcurrentMode;
        reactIs_development.isContextConsumer = isContextConsumer;
        reactIs_development.isContextProvider = isContextProvider;
        reactIs_development.isElement = isElement2;
        reactIs_development.isForwardRef = isForwardRef;
        reactIs_development.isFragment = isFragment;
        reactIs_development.isLazy = isLazy;
        reactIs_development.isMemo = isMemo;
        reactIs_development.isPortal = isPortal;
        reactIs_development.isProfiler = isProfiler;
        reactIs_development.isStrictMode = isStrictMode;
        reactIs_development.isSuspense = isSuspense;
        reactIs_development.isValidElementType = isValidElementType;
        reactIs_development.typeOf = typeOf;
      })();
    }
    return reactIs_development;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    if (process.env.NODE_ENV === "production") {
      reactIs.exports = requireReactIs_production_min();
    } else {
      reactIs.exports = requireReactIs_development();
    }
    return reactIs.exports;
  }
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var objectAssign;
  var hasRequiredObjectAssign;
  function requireObjectAssign() {
    if (hasRequiredObjectAssign) return objectAssign;
    hasRequiredObjectAssign = 1;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val2) {
      if (val2 === null || val2 === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val2);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to2 = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key2 in from) {
          if (hasOwnProperty.call(from, key2)) {
            to2[key2] = from[key2];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to2[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
    return objectAssign;
  }
  var ReactPropTypesSecret_1;
  var hasRequiredReactPropTypesSecret;
  function requireReactPropTypesSecret() {
    if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
    hasRequiredReactPropTypesSecret = 1;
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    ReactPropTypesSecret_1 = ReactPropTypesSecret;
    return ReactPropTypesSecret_1;
  }
  var has;
  var hasRequiredHas;
  function requireHas() {
    if (hasRequiredHas) return has;
    hasRequiredHas = 1;
    has = Function.call.bind(Object.prototype.hasOwnProperty);
    return has;
  }
  var checkPropTypes_1;
  var hasRequiredCheckPropTypes;
  function requireCheckPropTypes() {
    if (hasRequiredCheckPropTypes) return checkPropTypes_1;
    hasRequiredCheckPropTypes = 1;
    var printWarning = function() {
    };
    if (process.env.NODE_ENV !== "production") {
      var ReactPropTypesSecret = requireReactPropTypesSecret();
      var loggedTypeFailures = {};
      var has2 = requireHas();
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (process.env.NODE_ENV !== "production") {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (process.env.NODE_ENV !== "production") {
        loggedTypeFailures = {};
      }
    };
    checkPropTypes_1 = checkPropTypes;
    return checkPropTypes_1;
  }
  var factoryWithTypeCheckers;
  var hasRequiredFactoryWithTypeCheckers;
  function requireFactoryWithTypeCheckers() {
    if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
    hasRequiredFactoryWithTypeCheckers = 1;
    var ReactIs2 = requireReactIs();
    var assign2 = requireObjectAssign();
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    var has2 = requireHas();
    var checkPropTypes = requireCheckPropTypes();
    var printWarning = function() {
    };
    if (process.env.NODE_ENV !== "production") {
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess2) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data2) {
        this.message = message;
        this.data = data2 && typeof data2 === "object" ? data2 : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (process.env.NODE_ENV !== "production") {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess2) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
              var cacheKey2 = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey2] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey2] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs2.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (process.env.NODE_ENV !== "production") {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is2(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key2, value2) {
            var type2 = getPreciseType(value2);
            if (type2 === "symbol") {
              return String(value2);
            }
            return value2;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key2 in propValue) {
            if (has2(propValue, key2)) {
              var error = typeChecker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          process.env.NODE_ENV !== "production" ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key2, type2) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key2 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key2 in shapeTypes) {
            var checker = shapeTypes[key2];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key2 in allKeys) {
            var checker = shapeTypes[key2];
            if (has2(shapeTypes, key2) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key2, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key2 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key2, componentName, location, propFullName + "." + key2, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value2) {
        var type2 = getPreciseType(value2);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    return factoryWithTypeCheckers;
  }
  var factoryWithThrowingShims;
  var hasRequiredFactoryWithThrowingShims;
  function requireFactoryWithThrowingShims() {
    if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
    hasRequiredFactoryWithThrowingShims = 1;
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    return factoryWithThrowingShims;
  }
  if (process.env.NODE_ENV !== "production") {
    var ReactIs = requireReactIs();
    var throwOnDirectAccess = true;
    propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  } else {
    propTypes.exports = requireFactoryWithThrowingShims()();
  }
  var propTypesExports = propTypes.exports;
  const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList) element.classList.add(className);
    else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
    else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  const config$2 = {
    disabled: false
  };
  var timeoutsShape = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    enter: PropTypes.number,
    exit: PropTypes.number,
    appear: PropTypes.number
  }).isRequired]) : null;
  var classNamesShape = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string,
    active: PropTypes.string
  }), PropTypes.shape({
    enter: PropTypes.string,
    enterDone: PropTypes.string,
    enterActive: PropTypes.string,
    exit: PropTypes.string,
    exitDone: PropTypes.string,
    exitActive: PropTypes.string
  })]) : null;
  const TransitionGroupContext = React.createContext(null);
  var forceReflow = function forceReflow2(node) {
    return node.scrollTop;
  };
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(Transition2, _React$Component);
    function Transition2(props, context2) {
      var _this;
      _this = _React$Component.call(this, props, context2) || this;
      var parentGroup = context2;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== "number") {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear !== void 0 ? timeout.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
            if (node) forceReflow(node);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts2 = this.getTimeouts();
      var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
      if (!mounting && !enter || config$2.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts2 = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
      if (!exit || config$2.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts2.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active2 = true;
      this.nextCallback = function(event) {
        if (active2) {
          active2 = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active2 = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render2() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose$4(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(React.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = process.env.NODE_ENV !== "production" ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: PropTypes.shape({
      current: typeof Element === "undefined" ? PropTypes.any : function(propValue, key2, componentName, location, propFullName, secret) {
        var value2 = propValue[key2];
        return PropTypes.instanceOf(value2 && "ownerDocument" in value2 ? value2.ownerDocument.defaultView.Element : Element)(propValue, key2, componentName, location, propFullName, secret);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: PropTypes.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: PropTypes.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: PropTypes.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: PropTypes.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: PropTypes.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: PropTypes.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener) pt = pt.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt.apply(void 0, [props].concat(args));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: PropTypes.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: PropTypes.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: PropTypes.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: PropTypes.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: PropTypes.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: PropTypes.func
  } : {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var _addClass = function addClass$1(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return addClass(node, c6);
    });
  };
  var removeClass = function removeClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return removeClass$1(node, c6);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type2 = appearing ? "appear" : "enter";
        _this.addClass(node, type2, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type2 = appearing ? "appear" : "enter";
        _this.removeClasses(node, type2);
        _this.addClass(node, type2, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type2) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type2 : classNames2[type2];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type2 + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type2 + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node, type2, phase) {
      var className = this.getClassNames(type2)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type2 === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        if (node) forceReflow(node);
      }
      if (className) {
        this.appliedClasses[type2][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type2) {
      var _this$appliedClasses$ = this.appliedClasses[type2], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type2] = {};
      if (baseClassName) {
        removeClass(node, baseClassName);
      }
      if (activeClassName) {
        removeClass(node, activeClassName);
      }
      if (doneClassName) {
        removeClass(node, doneClassName);
      }
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose$4(_this$props, ["classNames"]);
      return /* @__PURE__ */ React.createElement(Transition, _extends$4({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(React.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends$4({}, Transition.propTypes, {
    /**
     * The animation classNames applied to the component as it appears, enters,
     * exits or has finished the transition. A single name can be provided, which
     * will be suffixed for each stage, e.g. `classNames="fade"` applies:
     *
     * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
     * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
     * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
     *
     * A few details to note about how these classes are applied:
     *
     * 1. They are _joined_ with the ones that are already defined on the child
     *    component, so if you want to add some base styles, you can use
     *    `className` without worrying that it will be overridden.
     *
     * 2. If the transition component mounts with `in={false}`, no classes are
     *    applied yet. You might be expecting `*-exit-done`, but if you think
     *    about it, a component cannot finish exiting if it hasn't entered yet.
     *
     * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
     *    allows you to define different behavior for when appearing is done and
     *    when regular entering is done, using selectors like
     *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
     *    an epic entrance animation when element first appears in the DOM using
     *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
     *    simply use `fade-enter-done` for defining both cases.
     *
     * Each individual classNames can also be specified independently like:
     *
     * ```js
     * classNames={{
     *  appear: 'my-appear',
     *  appearActive: 'my-active-appear',
     *  appearDone: 'my-done-appear',
     *  enter: 'my-enter',
     *  enterActive: 'my-active-enter',
     *  enterDone: 'my-done-enter',
     *  exit: 'my-exit',
     *  exitActive: 'my-active-exit',
     *  exitDone: 'my-done-exit',
     * }}
     * ```
     *
     * If you want to set these classes using CSS Modules:
     *
     * ```js
     * import styles from './styles.css';
     * ```
     *
     * you might want to use camelCase in your CSS file, that way could simply
     * spread them instead of listing them one by one:
     *
     * ```js
     * classNames={{ ...styles }}
     * ```
     *
     * @type {string | {
     *  appear?: string,
     *  appearActive?: string,
     *  appearDone?: string,
     *  enter?: string,
     *  enterActive?: string,
     *  enterDone?: string,
     *  exit?: string,
     *  exitActive?: string,
     *  exitDone?: string,
     * }}
     */
    classNames: classNamesShape,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEnter: PropTypes.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter-active' or
     * 'appear-active' class is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or
     * 'appear' classes are **removed** and the `done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntered: PropTypes.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExit: PropTypes.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExiting: PropTypes.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' classes
     * are **removed** and the `exit-done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExited: PropTypes.func
  }) : {};
  var MIN_DISTANCE = 10;
  function getDirection(x, y) {
    if (x > y && x > MIN_DISTANCE) {
      return "horizontal";
    }
    if (y > x && y > MIN_DISTANCE) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    var startX = React.useRef(0);
    var startY = React.useRef(0);
    var deltaX = React.useRef(0);
    var deltaY = React.useRef(0);
    var delta = React.useRef(0);
    var offsetX = React.useRef(0);
    var offsetY = React.useRef(0);
    var direction = React.useRef("");
    var last = React.useRef(false);
    var velocity2 = React.useRef(0);
    var touchTime = React.useRef(Date.now());
    var isVertical = function() {
      return direction.current === "vertical";
    };
    var isHorizontal = function() {
      return direction.current === "horizontal";
    };
    var reset = function() {
      touchTime.current = Date.now();
      deltaX.current = 0;
      deltaY.current = 0;
      offsetX.current = 0;
      offsetY.current = 0;
      delta.current = 0;
      direction.current = "";
      last.current = false;
    };
    var getTouch = function(event) {
      var touch = event.touches ? event.touches[0] : event.nativeEvent;
      return touch;
    };
    var getX = function(touch) {
      if (typeof touch.clientX !== "undefined" && typeof touch.pageX !== "undefined") return touch.pageX;
      var _touch_screenX, _ref, _ref1;
      return (_ref1 = (_ref = (_touch_screenX = touch.screenX) !== null && _touch_screenX !== void 0 ? _touch_screenX : touch.pageX) !== null && _ref !== void 0 ? _ref : touch.clientX) !== null && _ref1 !== void 0 ? _ref1 : 0;
    };
    var getY = function(touch) {
      if (typeof touch.clientY !== "undefined" && typeof touch.pageY !== "undefined") return touch.pageY;
      var _touch_screenY, _ref, _ref1;
      return (_ref1 = (_ref = (_touch_screenY = touch.screenY) !== null && _touch_screenY !== void 0 ? _touch_screenY : touch.pageY) !== null && _ref !== void 0 ? _ref : touch.clientY) !== null && _ref1 !== void 0 ? _ref1 : 0;
    };
    var start2 = function(event) {
      reset();
      touchTime.current = Date.now();
      startX.current = getX(getTouch(event));
      startY.current = getY(getTouch(event));
    };
    var move = function(event) {
      var touch = getTouch(event);
      var clientX = getX(touch);
      var clientY = getY(touch);
      deltaX.current = clientX < 0 ? 0 : clientX - startX.current;
      deltaY.current = clientY - startY.current;
      offsetX.current = Math.abs(deltaX.current);
      offsetY.current = Math.abs(deltaY.current);
      delta.current = isVertical() ? deltaY.current : deltaX.current;
      if (!direction.current) {
        direction.current = getDirection(offsetX.current, offsetY.current);
      }
    };
    var end = function(event) {
      last.current = true;
      velocity2.current = Math.sqrt(Math.pow(deltaX.current, 2) + Math.pow(deltaY.current, 2)) / (Date.now() - touchTime.current);
    };
    return {
      end,
      move,
      start: start2,
      reset,
      touchTime,
      startX,
      startY,
      deltaX,
      deltaY,
      delta,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal,
      last
    };
  }
  var totalLockCount = 0;
  var BODY_LOCK_CLASS = "nut-overflow-hidden";
  function getScrollableElement(el) {
    var current = el === null || el === void 0 ? void 0 : el.parentElement;
    while (current) {
      if (current.clientHeight < current.scrollHeight) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function useLockScroll(rootRef, shouldLock) {
    var touch = useTouch();
    var onTouchMove = function(event) {
      touch.move(event);
      var direction = touch.deltaY.current > 0 ? "10" : "01";
      var el = getScrollParent(event.target, rootRef.current);
      if (!el) return;
      if (shouldLock === "strict") {
        var scrollableParent = getScrollableElement(event.target);
        if (scrollableParent === document.body || scrollableParent === document.documentElement) {
          event.preventDefault();
          return;
        }
      }
      var scrollHeight = el.scrollHeight, offsetHeight = el.offsetHeight, scrollTop = el.scrollTop;
      var status = "11";
      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? "00" : "01";
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = "10";
      }
      if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    };
    var lock = function() {
      document.addEventListener("touchstart", touch.start);
      document.addEventListener("touchmove", onTouchMove, exports.passiveSupported ? {
        passive: false
      } : false);
      if (!totalLockCount) {
        document.body.classList.add(BODY_LOCK_CLASS);
      }
      totalLockCount++;
    };
    var unlock = function() {
      if (totalLockCount) {
        document.removeEventListener("touchstart", touch.start);
        document.removeEventListener("touchmove", onTouchMove);
        totalLockCount--;
        if (!totalLockCount) {
          document.body.classList.remove(BODY_LOCK_CLASS);
        }
      }
    };
    React.useEffect(function() {
      if (shouldLock) {
        lock();
        return function() {
          unlock();
        };
      }
    }, [
      shouldLock
    ]);
  }
  var defaultOverlayProps = _object_spread_props(_object_spread({}, ComponentDefaults), {
    zIndex: 1e3,
    duration: 300,
    closeOnOverlayClick: true,
    visible: false,
    lockScroll: true,
    onClick: function() {
    },
    afterShow: function() {
    },
    afterClose: function() {
    }
  });
  var Overlay = function(props) {
    var _ref = _object_spread({}, defaultOverlayProps, props), children = _ref.children, zIndex = _ref.zIndex, duration = _ref.duration, className = _ref.className, closeOnOverlayClick = _ref.closeOnOverlayClick, visible = _ref.visible, lockScroll = _ref.lockScroll, style = _ref.style, afterShow = _ref.afterShow, afterClose = _ref.afterClose, onClick = _ref.onClick, rest = _object_without_properties(_ref, [
      "children",
      "zIndex",
      "duration",
      "className",
      "closeOnOverlayClick",
      "visible",
      "lockScroll",
      "style",
      "afterShow",
      "afterClose",
      "onClick"
    ]);
    var classPrefix2 = "nut-overlay";
    var _useState = _sliced_to_array(React.useState(visible), 2), innerVisible = _useState[0], setInnerVisible = _useState[1];
    var nodeRef = React.useRef(null);
    React.useEffect(function() {
      setInnerVisible(visible);
    }, [
      visible
    ]);
    var shouldLockScroll = !innerVisible ? false : lockScroll;
    useLockScroll(nodeRef, shouldLockScroll);
    var classes = classNames(classPrefix2, className);
    var styles = _object_spread_props(_object_spread({}, style), {
      zIndex
    });
    var handleClick = function(e2) {
      if (closeOnOverlayClick) {
        onClick && onClick(e2);
      }
    };
    return /* @__PURE__ */ React.createElement(CSSTransition, {
      nodeRef,
      classNames: "".concat(classPrefix2, "-slide"),
      unmountOnExit: true,
      timeout: duration,
      in: innerVisible,
      onEntered: afterShow,
      onExited: afterClose
    }, /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      ref: nodeRef,
      className: classes,
      style: styles
    }, rest), {
      onClick: handleClick
    }), children));
  };
  Overlay.displayName = "NutOverlay";
  var defaultProps$1x = _object_spread_props(_object_spread({}, ComponentDefaults), {
    contentPosition: "center",
    direction: "horizontal"
  });
  var classPrefix$r = "nut-divider";
  var Divider = function(props) {
    var _ref = _object_spread({}, defaultProps$1x, props), children = _ref.children, contentPosition = _ref.contentPosition, style = _ref.style, className = _ref.className, direction = _ref.direction, rest = _object_without_properties(_ref, [
      "children",
      "contentPosition",
      "style",
      "className",
      "direction"
    ]);
    var rtl = useRtl();
    var _obj, _obj1;
    var classes = direction === "horizontal" ? classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix$r), true), _define_property(_obj, "".concat(classPrefix$r, "-center"), children), _define_property(_obj, "".concat(classPrefix$r, "-left"), contentPosition === "left"), _define_property(_obj, "".concat(classPrefix$r, "-right"), contentPosition === "right"), _define_property(_obj, "".concat(classPrefix$r, "-rtl"), ([
      "left",
      "right"
    ].includes(contentPosition) || children) && rtl), _obj)) : classNames((_obj1 = {}, _define_property(_obj1, "".concat(classPrefix$r), true), _define_property(_obj1, "".concat(classPrefix$r, "-vertical"), direction === "vertical"), _obj1));
    var getClassNames = function(direction2) {
      return "".concat(classes.split(" ").map(function(item) {
        return "".concat(item, "-").concat(direction2);
      }).join(" "));
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classes, " ").concat(className || ""),
      style
    }, rest), direction === "horizontal" && /* @__PURE__ */ React.createElement("div", {
      className: getClassNames("before"),
      style
    }), children, direction === "horizontal" && /* @__PURE__ */ React.createElement("div", {
      className: getClassNames("after"),
      style
    }));
  };
  Divider.displayName = "NutDivider";
  var context = {
    onClick: function(item, index2) {
    }
  };
  const GridContext = React.createContext(context);
  var defaultProps$1w = {
    text: "",
    columns: 4,
    gap: 9,
    center: true,
    square: true,
    reverse: false,
    direction: "vertical"
  };
  var GridItem = function(props) {
    var _ref = _object_spread({}, defaultProps$1w, props), children = _ref.children, style = _ref.style, columns = _ref.columns, index2 = _ref.index, gap = _ref.gap, square = _ref.square, text2 = _ref.text, center = _ref.center, reverse = _ref.reverse, direction = _ref.direction, className = _ref.className, onClick = _ref.onClick, rest = _object_without_properties(_ref, [
      "children",
      "style",
      "columns",
      "index",
      "gap",
      "square",
      "text",
      "center",
      "reverse",
      "direction",
      "className",
      "onClick"
    ]);
    var classPrefix2 = "nut-grid-item";
    var classes = classNames(classPrefix2, className);
    var context2 = React.useContext(GridContext);
    var rootStyle = function() {
      var width2 = "calc((100% - ".concat(Number(gap) * (Number(columns) - 1), "px) / ").concat(Number(columns), ")");
      var styles = _object_spread({
        flexBasis: width2
      }, style);
      if (square) {
        styles.paddingTop = width2;
      }
      if (gap) {
        if ((index2 + 1) % Number(columns)) {
          styles.marginRight = pxCheck(gap);
        }
        if (index2 >= Number(columns)) {
          styles.marginTop = pxCheck(gap);
        }
      } else {
        styles.borderRadius = 0;
      }
      return styles;
    };
    var contentClass = function() {
      var _obj;
      return classNames("".concat(classPrefix2, "-content"), (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-content-border"), true), _define_property(_obj, "".concat(classPrefix2, "-content-surround"), gap), _define_property(_obj, "".concat(classPrefix2, "-content-center"), center), _define_property(_obj, "".concat(classPrefix2, "-content-square"), square), _define_property(_obj, "".concat(classPrefix2, "-content-reverse"), reverse && direction !== "horizontal"), _define_property(_obj, "".concat(classPrefix2, "-content-").concat(direction), !!direction), _define_property(_obj, "".concat(classPrefix2, "-content-horizontal-reverse"), reverse && direction === "horizontal"), _obj));
    };
    var textClass = function() {
      var _obj;
      return classNames("".concat(classPrefix2, "-text"), (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-text-reverse"), reverse && direction !== "horizontal"), _define_property(_obj, "".concat(classPrefix2, "-text-horizontal"), direction === "horizontal"), _define_property(_obj, "".concat(classPrefix2, "-text-horizontal-reverse"), reverse && direction === "horizontal"), _obj));
    };
    var handleClick = function(e2) {
      onClick && onClick(e2);
      context2.onClick && context2.onClick({
        text: text2,
        index: index2,
        columns,
        gap,
        center,
        square,
        reverse,
        direction
      }, index2);
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: classes,
      style: rootStyle()
    }, rest), {
      onClick: handleClick
    }), /* @__PURE__ */ React.createElement("div", {
      className: contentClass()
    }, children && /* @__PURE__ */ React.createElement(React.Fragment, null, children), text2 && /* @__PURE__ */ React.createElement("div", {
      className: textClass()
    }, text2)));
  };
  GridItem.displayName = "NutGridItem";
  var defaultProps$1v = {
    columns: 4,
    gap: 9,
    center: true,
    square: true,
    reverse: false,
    direction: "vertical"
  };
  var Grid = function(props) {
    var _ref = _object_spread({}, defaultProps$1v, props), children = _ref.children, columns = _ref.columns, gap = _ref.gap, center = _ref.center, square = _ref.square, reverse = _ref.reverse, direction = _ref.direction, style = _ref.style, className = _ref.className, onClick = _ref.onClick, rest = _object_without_properties(_ref, [
      "children",
      "columns",
      "gap",
      "center",
      "square",
      "reverse",
      "direction",
      "style",
      "className",
      "onClick"
    ]);
    var childrenDom = React.Children.toArray(children);
    var classPrefix2 = "nut-grid";
    var rootClass = function() {
      return classNames(classPrefix2, _define_property({}, "".concat(classPrefix2, "-border"), !gap), className);
    };
    var rootStyle = function() {
      var styleSelf = {};
      if (style) {
        styleSelf = style;
      }
      return styleSelf;
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: rootClass(),
      style: rootStyle()
    }, rest), /* @__PURE__ */ React.createElement(GridContext.Provider, {
      value: {
        onClick
      }
    }, childrenDom.map(function(item, idex) {
      return /* @__PURE__ */ React.cloneElement(item, {
        index: idex,
        columns,
        center,
        gap,
        square,
        reverse,
        direction
      });
    })));
  };
  Grid.displayName = "NutGrid";
  Grid.Item = GridItem;
  var Layout = function() {
    return /* @__PURE__ */ React.createElement("div", {
      className: "nut-layout"
    }, "Layout");
  };
  Layout.displayName = "NutLayout";
  var DataContext$1 = React.createContext({});
  var defaultProps$1u = _object_spread_props(_object_spread({}, ComponentDefaults), {
    span: "24",
    offset: "0",
    gutter: "0",
    isFirst: false,
    isLast: false
  });
  var Col = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1u, props), className = _$_object_spread.className, style = _$_object_spread.style, span = _$_object_spread.span, offset = _$_object_spread.offset, children = _$_object_spread.children, isFirst = _$_object_spread.isFirst, isLast = _$_object_spread.isLast, onClick = _$_object_spread.onClick;
    var _useState = _sliced_to_array(React.useState(""), 2), colName = _useState[0], setColName = _useState[1];
    var _useState1 = _sliced_to_array(React.useState({}), 2), colStyle = _useState1[0], setColStyle = _useState1[1];
    var gutter = React.useContext(DataContext$1).gutter;
    var classs = function() {
      var prefixCls2 = "nut-col";
      return "".concat(prefixCls2, " ").concat(prefixCls2, "-").concat(span, " ").concat(gutter ? "".concat(prefixCls2, "-gutter") : "", " ").concat(prefixCls2, "-offset-").concat(offset);
    };
    var getStyle = function() {
      var style2 = {};
      if (!isFirst) {
        style2.paddingLeft = "".concat(gutter / 2, "px");
      }
      if (!isLast) {
        style2.paddingRight = "".concat(gutter / 2, "px");
      }
      return style2;
    };
    React.useEffect(function() {
      setColName(classs);
      setColStyle(getStyle);
    }, [
      span,
      offset,
      gutter
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(colName, className),
      style: _object_spread({}, style, colStyle),
      onClick: function(e2) {
        onClick && onClick(e2, "col");
      }
    }, children);
  };
  Col.displayName = "NutCol";
  var classPrefix$q = "nut-row";
  var defaultProps$1t = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "",
    justify: "start",
    align: "flex-start",
    wrap: "nowrap",
    gutter: "0"
  });
  var Row = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1t, props), className = _$_object_spread.className, style = _$_object_spread.style, children = _$_object_spread.children, type2 = _$_object_spread.type, justify = _$_object_spread.justify, align = _$_object_spread.align, wrap = _$_object_spread.wrap, gutter = _$_object_spread.gutter, onClick = _$_object_spread.onClick;
    var getClass = function(prefix2, type3) {
      var classType = type3 ? "nut-row-".concat(prefix2, "-").concat(type3) : "";
      if (prefix2) return classType;
      if (type3) return "nut-row-".concat(type3);
      return "";
    };
    var getClasses = function() {
      return classNames(classPrefix$q, getClass("", type2), getClass("justify", justify), getClass("align", align), getClass("flex", wrap));
    };
    var parentRow = {
      gutter
    };
    return /* @__PURE__ */ React.createElement(DataContext$1.Provider, {
      value: parentRow
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames(getClasses(), className),
      style,
      onClick: function(e2) {
        onClick === null || onClick === void 0 ? void 0 : onClick(e2, "row");
      }
    }, React.Children.map(children, function(child, index2) {
      var _child_type;
      return (child === null || child === void 0 ? void 0 : (_child_type = child.type) === null || _child_type === void 0 ? void 0 : _child_type.displayName) === "NutCol" ? /* @__PURE__ */ React.cloneElement(child, {
        isFirst: index2 === 0,
        isLast: index2 === React.Children.count(children) - 1
      }) : child;
    })));
  };
  Row.displayName = "NutRow";
  var classPrefix$p = "nut-safe-area";
  var SafeArea = function(props) {
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix$p, "".concat(classPrefix$p, "-position-").concat(props.position))
    });
  };
  SafeArea.displayName = "NutSafeArea";
  var prefixCls$1 = "nut-space";
  var defaultProps$1s = {
    direction: "horizontal"
  };
  var Space = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1s, props), className = _$_object_spread.className, style = _$_object_spread.style, children = _$_object_spread.children, wrap = _$_object_spread.wrap, align = _$_object_spread.align, direction = _$_object_spread.direction, justify = _$_object_spread.justify;
    var _obj;
    var cls = classNames(prefixCls$1, (_obj = {}, _define_property(_obj, "".concat(prefixCls$1, "-").concat(direction), direction), _define_property(_obj, "".concat(prefixCls$1, "-").concat(direction, "-wrap"), wrap), _define_property(_obj, "".concat(prefixCls$1, "-align-").concat(align), align), _define_property(_obj, "".concat(prefixCls$1, "-justify-").concat(justify), justify), _define_property(_obj, "".concat(className), className), _obj));
    var _obj1;
    var itemCls = classNames("".concat(prefixCls$1, "-item"), (_obj1 = {}, _define_property(_obj1, "".concat(prefixCls$1, "-").concat(direction, "-item"), direction), _define_property(_obj1, "".concat(prefixCls$1, "-").concat(direction, "-wrap-item"), wrap), _obj1));
    var childrenCount = React.Children.count(children);
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, React.Children.map(children, function(child, idx) {
      var isLast = idx === childrenCount - 1;
      return child !== null && child !== void 0 && /* @__PURE__ */ React.createElement("div", {
        className: classNames(itemCls, isLast && "".concat(prefixCls$1, "-").concat(direction, "-item-last"))
      }, child);
    }));
  };
  Space.displayName = "NutSpace";
  function useWatch$1(dep, callback) {
    var config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      immediate: false
    };
    var immediate = config2.immediate;
    var prev = React.useRef();
    var inited = React.useRef(false);
    var stop2 = React.useRef(false);
    React.useEffect(function() {
      var execute = function() {
        return callback(prev.current);
      };
      if (!stop2.current) {
        if (!inited.current) {
          inited.current = true;
          if (immediate) {
            execute();
          }
        } else {
          execute();
        }
        prev.current = dep;
      }
    }, [
      dep
    ]);
    return function() {
      stop2.current = true;
    };
  }
  var defaultProps$1r = _object_spread_props(_object_spread({}, ComponentDefaults), {
    position: "top",
    threshold: 0,
    zIndex: 900
  });
  var classPrefix$o = "nut-sticky";
  var Sticky = function(props) {
    var _ref = _object_spread({}, defaultProps$1r, props), position2 = _ref.position, zIndex = _ref.zIndex, children = _ref.children, container = _ref.container, style = _ref.style, className = _ref.className, threshold = _ref.threshold, onChange = _ref.onChange, rest = _object_without_properties(_ref, [
      "position",
      "zIndex",
      "children",
      "container",
      "style",
      "className",
      "threshold",
      "onChange"
    ]);
    var stickyRef = React.useRef(null);
    var rootRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(false), 2), isFixed = _useState[0], setIsFixed = _useState[1];
    var _obj;
    var _useState1 = _sliced_to_array(React.useState((_obj = {}, _define_property(_obj, position2, "".concat(threshold, "px")), _define_property(_obj, "zIndex", zIndex), _obj)), 2), stickyStyle = _useState1[0], setStickyStyle = _useState1[1];
    React.useEffect(function() {
      var _obj2;
      setStickyStyle(_object_spread_props(_object_spread({}, stickyStyle), (_obj2 = {}, _define_property(_obj2, position2, "".concat(threshold, "px")), _define_property(_obj2, "zIndex", zIndex), _obj2)));
    }, [
      threshold,
      position2,
      zIndex
    ]);
    var _useState2 = _sliced_to_array(React.useState({}), 2), rootStyle = _useState2[0], setRootStyle = _useState2[1];
    var getElement = React.useCallback(function() {
      return getScrollParent(rootRef.current);
    }, []);
    React.useEffect(function() {
      if (position2 === "top") return;
      var containerEle = container && container.current;
      var rootEle = rootRef.current;
      var stickyEle = stickyRef.current;
      if (!rootEle && !containerEle) return;
      var rootRect = getRect(rootEle);
      var containerRect = getRect(containerEle);
      var clientHeight = document.documentElement.clientHeight;
      var stickyRect = getRect(stickyEle);
      var fixed = clientHeight - threshold < rootRect.bottom;
      if (containerEle) {
        fixed = containerRect.bottom > clientHeight - threshold - stickyRect.height && clientHeight - threshold - stickyRect.height > containerRect.top;
      }
      var defaultPostVal = fixed ? "fixed" : "inherit";
      setStickyStyle(function(prev) {
        return _object_spread_props(_object_spread({}, prev), {
          position: defaultPostVal
        });
      });
      setIsFixed(fixed);
    }, [
      position2,
      container,
      threshold
    ]);
    var handleScroll = React.useCallback(function() {
      var containerEle = container && container.current;
      var rootEle = rootRef.current;
      var stickyEle = stickyRef.current;
      if (!rootEle && !containerEle) return;
      var rootRect = getRect(rootEle);
      var stickyRect = getRect(stickyEle);
      var containerRect = getRect(containerEle);
      if (rootRect.height) {
        setRootStyle(function(prev) {
          return _object_spread_props(_object_spread({}, prev), {
            height: rootRect.height
          });
        });
      }
      var getFixed = function() {
        var fixed2 = false;
        if (position2 === "top") {
          fixed2 = containerEle ? threshold > rootRect.top && containerRect.bottom > 0 : threshold > rootRect.top;
        } else {
          var clientHeight = document.documentElement.clientHeight;
          fixed2 = containerEle ? containerRect.bottom > 0 && clientHeight - threshold - stickyRect.height > containerRect.top : clientHeight - threshold < rootRect.bottom;
        }
        return {
          position: fixed2 ? "fixed" : "inherit",
          fixed: fixed2
        };
      };
      var getTransform = function() {
        if (position2 === "top" && containerEle) {
          var diff = containerRect.bottom - threshold - stickyRect.height;
          var transform2 = diff < 0 ? diff : 0;
          return {
            transform: "translate3d(0, ".concat(transform2, "px, 0)")
          };
        }
        if (position2 === "bottom" && containerEle) {
          var clientHeight = document.documentElement.clientHeight;
          var diff1 = containerRect.bottom - (clientHeight - threshold);
          var transform1 = diff1 < 0 ? diff1 : 0;
          return {
            transform: "translate3d(0, ".concat(transform1, "px, 0)")
          };
        }
        return {};
      };
      var fixed = getFixed();
      setStickyStyle(function(prev) {
        return _object_spread_props(_object_spread({}, prev, getTransform()), {
          position: fixed.position
        });
      });
      setIsFixed(fixed.fixed);
    }, [
      position2,
      threshold,
      container
    ]);
    useWatch$1(isFixed, function() {
      onChange && onChange(isFixed);
    });
    React.useEffect(function() {
      var el = getElement();
      el === null || el === void 0 ? void 0 : el.addEventListener("scroll", handleScroll, false);
      return function() {
        el === null || el === void 0 ? void 0 : el.removeEventListener("scroll", handleScroll);
      };
    }, [
      getElement,
      handleScroll
    ]);
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      ref: rootRef,
      style: _object_spread({}, style, rootStyle),
      className: classNames(classPrefix$o, className)
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "nut-sticky-box",
      ref: stickyRef,
      style: stickyStyle
    }, children));
  };
  Sticky.displayName = "NutSticky";
  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
  }
  var getIcon = function(icon) {
    return React.isValidElement(icon) ? React.cloneElement(icon, {
      // @ts-ignore
      className: "nut-icon"
    }) : icon;
  };
  var defaultProps$1q = _object_spread_props(_object_spread({}, ComponentDefaults), {
    icon: null,
    onClick: function(event) {
    }
  });
  var classPrefix$n = "nut-hoverbutton-item";
  var HoverButtonItem = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1q, props), className = _$_object_spread.className, children = _$_object_spread.children, style = _$_object_spread.style, icon = _$_object_spread.icon, onClick = _$_object_spread.onClick;
    var handleClick = function(event) {
      if (onClick) {
        onClick(event);
      }
    };
    var renderBody = function() {
      if (icon && !children) return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$n, "-icon")
      }, getIcon(icon));
      if (icon && children) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
          className: classNames(_define_property({}, "".concat(classPrefix$n, "-text-icon"), true))
        }), getIcon(icon), /* @__PURE__ */ React.createElement("div", {
          className: classNames(_define_property({}, "".concat(classPrefix$n, "-text"), true))
        }, children));
      }
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames([
        "".concat(classPrefix$n, "-container"),
        className
      ], _define_property({}, "".concat(classPrefix$n, "-container-icontext"), icon && children)),
      style,
      onClick: handleClick
    }, renderBody());
  };
  HoverButtonItem.displayName = "NutHoverButtonItem";
  var UI_BOTTOM_DISTANCE = 60;
  var defaultProps$1p = _object_spread({}, ComponentDefaults);
  var classPrefix$m = "nut-hoverbutton";
  var HoverButton = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1p, props), children = _$_object_spread.children, zIndex = _$_object_spread.zIndex, tabbarHeight = _$_object_spread.tabbarHeight, className = _$_object_spread.className, style = _$_object_spread.style, icon = _$_object_spread.icon, onClick = _$_object_spread.onClick;
    var rtl = useRtl();
    var baseStyle = _object_spread({}, style);
    if (tabbarHeight) {
      var bottom = tabbarHeight + UI_BOTTOM_DISTANCE;
      baseStyle.bottom = "".concat(bottom, "px");
    }
    if (typeof zIndex !== "undefined") {
      baseStyle.zIndex = zIndex;
    }
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames([
        "".concat(classPrefix$m, "-container"),
        className
      ], _define_property({}, "".concat(classPrefix$m, "-container-rtl"), rtl)),
      style: baseStyle
    }, /* @__PURE__ */ React.createElement("div", {
      className: classPrefix$m
    }, children || icon && /* @__PURE__ */ React.createElement(HoverButtonItem, {
      icon,
      onClick
    })), /* @__PURE__ */ React.createElement(SafeArea, {
      position: "bottom"
    }));
  };
  HoverButton.displayName = "NutHoverButton";
  HoverButton.Item = HoverButtonItem;
  var defaultProps$1o = _object_spread_props(_object_spread({}, ComponentDefaults), {
    target: "",
    threshold: 200,
    zIndex: 900,
    duration: 1e3
  });
  var BackTop = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1o, props), children = _$_object_spread.children, target = _$_object_spread.target, threshold = _$_object_spread.threshold, zIndex = _$_object_spread.zIndex, className = _$_object_spread.className, duration = _$_object_spread.duration, icon = _$_object_spread.icon, style = _$_object_spread.style, onClick = _$_object_spread.onClick;
    var classPrefix2 = "nut-backtop";
    var _useState = _sliced_to_array(React.useState(false), 2), backTop = _useState[0], setBackTop = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(0), 2), scrollTop = _useState1[0], setScrollTop = _useState1[1];
    var startTime = React.useRef(0);
    var cls = classNames(classPrefix2, _define_property({}, "".concat(classPrefix2, "-show"), backTop), className);
    var scrollEl = React.useRef(null);
    var scrollListener = React.useCallback(function() {
      var top = null;
      if (_instanceof(scrollEl.current, Window)) {
        top = scrollEl.current.scrollY;
      } else {
        top = scrollEl.current.scrollTop;
      }
      setScrollTop(top);
      setBackTop(top >= threshold);
    }, [
      threshold
    ]);
    var init = React.useCallback(function() {
      var _scrollEl_current, _scrollEl_current1;
      if (target && document.getElementById(target)) {
        scrollEl.current = document.getElementById(target);
      } else {
        scrollEl.current = window;
      }
      (_scrollEl_current = scrollEl.current) === null || _scrollEl_current === void 0 ? void 0 : _scrollEl_current.addEventListener("scroll", scrollListener, false);
      (_scrollEl_current1 = scrollEl.current) === null || _scrollEl_current1 === void 0 ? void 0 : _scrollEl_current1.addEventListener("resize", scrollListener, false);
    }, [
      scrollListener,
      target
    ]);
    React.useEffect(function() {
      init();
      return function() {
        var _scrollEl_current, _scrollEl_current1;
        (_scrollEl_current = scrollEl.current) === null || _scrollEl_current === void 0 ? void 0 : _scrollEl_current.removeEventListener("scroll", scrollListener, false);
        (_scrollEl_current1 = scrollEl.current) === null || _scrollEl_current1 === void 0 ? void 0 : _scrollEl_current1.removeEventListener("resize", scrollListener, false);
      };
    }, [
      init,
      scrollListener
    ]);
    var scroll = React.useCallback(function() {
      var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (_instanceof(scrollEl.current, Window)) {
        window.scrollTo(0, y);
      } else {
        scrollEl.current.scrollTop = y;
        window.scrollTo(0, y);
      }
    }, []);
    var scrollAnimation = React.useCallback(function() {
      var cid = requestAniFrame$1(function fn() {
        var t = duration - Math.max(0, startTime.current - +/* @__PURE__ */ new Date() + duration / 2);
        var y = t * -scrollTop / duration + scrollTop;
        scroll(y);
        cid = requestAniFrame$1(fn);
        if (t === duration || y === 0) {
          cancelRaf(cid);
        }
      });
    }, [
      duration,
      scroll,
      scrollTop,
      startTime
    ]);
    var goTop = React.useCallback(function(e2) {
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      var otime = +/* @__PURE__ */ new Date();
      startTime.current = otime;
      duration > 0 ? scrollAnimation() : scroll();
    }, [
      duration,
      onClick,
      scroll,
      scrollAnimation
    ]);
    return /* @__PURE__ */ React.createElement(HoverButton, {
      className: cls,
      style: _object_spread({
        zIndex
      }, style),
      icon: !children && (icon || /* @__PURE__ */ React.createElement(p$1, null)),
      onClick: function(e2) {
        goTop(e2);
      }
    }, children && /* @__PURE__ */ React.createElement("div", {
      className: "nut-hoverbutton-item-container",
      onClick: function(e2) {
        goTop(e2);
      }
    }, children));
  };
  BackTop.displayName = "NutBackTop";
  function clamp$1(v, min, max) {
    return Math.max(min, Math.min(v, max));
  }
  const V = {
    toVector(v, fallback) {
      if (v === void 0) v = fallback;
      return Array.isArray(v) ? v : [v, v];
    },
    add(v1, v2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    },
    sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    },
    addTo(v1, v2) {
      v1[0] += v2[0];
      v1[1] += v2[1];
    },
    subTo(v1, v2) {
      v1[0] -= v2[0];
      v1[1] -= v2[1];
    }
  };
  function rubberband(distance, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds(position2, min, max, constant = 0.15) {
    if (constant === 0) return clamp$1(position2, min, max);
    if (position2 < min) return -rubberband(min - position2, max - min, constant) + min;
    if (position2 > max) return +rubberband(position2 - max, max - min, constant) + max;
    return position2;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
  }
  function _defineProperty$1(obj, key2, value2) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value2;
    }
    return obj;
  }
  function ownKeys$1(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  const EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string2) {
    if (!string2) return "";
    return string2[0].toUpperCase() + string2.slice(1);
  }
  const actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop) {
    let eventKey = prop.substring(2).toLowerCase();
    const passive = !!~eventKey.indexOf("passive");
    if (passive) eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture) eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event)) return "touch";
    if ("pointerType" in event) return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e2) => {
      var _event$currentTarget, _event$currentTarget$;
      return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
    });
  }
  function getTouchList(event) {
    return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
  }
  function getValueEvent(event) {
    return isTouch(event) ? getTouchList(event)[0] : event;
  }
  function distanceAngle(P1, P2) {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function touchDistanceAngle(event, ids) {
    const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
    return distanceAngle(P1, P2);
  }
  function pointerId(event) {
    const valueEvent = getValueEvent(event);
    return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
  }
  function pointerValues(event) {
    const valueEvent = getValueEvent(event);
    return [valueEvent.clientX, valueEvent.clientY];
  }
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;
  function wheelValues(event) {
    let {
      deltaX,
      deltaY,
      deltaMode
    } = event;
    if (deltaMode === 1) {
      deltaX *= LINE_HEIGHT;
      deltaY *= LINE_HEIGHT;
    } else if (deltaMode === 2) {
      deltaX *= PAGE_HEIGHT;
      deltaY *= PAGE_HEIGHT;
    }
    return [deltaX, deltaY];
  }
  function scrollValues(event) {
    var _ref, _ref2;
    const {
      scrollX,
      scrollY,
      scrollLeft,
      scrollTop
    } = event.currentTarget;
    return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event) payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call$1(v, ...args) {
    if (typeof v === "function") {
      return v(...args);
    } else {
      return v;
    }
  }
  function noop$1() {
  }
  function chain(...fns) {
    if (fns.length === 0) return noop$1;
    if (fns.length === 1) return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value2, fallback) {
    return Object.assign({}, fallback, value2 || {});
  }
  const BEFORE_LAST_KINEMATICS_DELAY = 32;
  class Engine {
    constructor(ctrl, args, key2) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key2;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init) this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config2.from ? call$1(config2.from, state) : state.offset;
        state.offset = state.lastOffset;
      }
      state.startTime = state.timeStamp = event.timeStamp;
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config: config2,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config2.preventDefault && event.cancelable) state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent) this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config2.threshold;
      const {
        _step,
        values
      } = state;
      if (config2.hasCustomTransform) {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional) return;
      const movement = [0, 0];
      if (config2.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config2) state._bounds = call$1(config2.bounds, state);
            if (this.setup) this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config2 = this.config;
      if (!state._active) this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents) return;
      const memo = this.handler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo !== void 0) state.memo = memo;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  }
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  class CoordinatesEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state.axis && event) {
        const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
    }
    restrictToAxis(v) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v[1] = 0;
            break;
          case "y":
            v[0] = 0;
            break;
        }
      }
    }
  }
  const identity = (v) => v;
  const DEFAULT_RUBBERBAND = 0.15;
  const commonConfigResolver = {
    enabled(value2 = true) {
      return value2;
    },
    eventOptions(value2, _k, config2) {
      return _objectSpread2$1(_objectSpread2$1({}, config2.shared.eventOptions), value2);
    },
    preventDefault(value2 = false) {
      return value2;
    },
    triggerAllEvents(value2 = false) {
      return value2;
    },
    rubberband(value2 = 0) {
      switch (value2) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value2);
      }
    },
    from(value2) {
      if (typeof value2 === "function") return value2;
      if (value2 != null) return V.toVector(value2);
    },
    transform(value2, _k, config2) {
      const transform2 = value2 || config2.shared.transform;
      this.hasCustomTransform = !!transform2;
      if (process.env.NODE_ENV === "development") {
        const originalTransform = transform2 || identity;
        return (v) => {
          const r = originalTransform(v);
          if (!isFinite(r[0]) || !isFinite(r[1])) {
            console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
          }
          return r;
        };
      }
      return transform2 || identity;
    },
    threshold(value2) {
      return V.toVector(value2, 0);
    }
  };
  if (process.env.NODE_ENV === "development") {
    Object.assign(commonConfigResolver, {
      domTarget(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
        }
        return NaN;
      },
      lockDirection(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
        }
        return NaN;
      },
      initial(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
        }
        return NaN;
      }
    });
  }
  const DEFAULT_AXIS_THRESHOLD = 0;
  const coordinatesConfigResolver = _objectSpread2$1(_objectSpread2$1({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection) return axis;
    },
    axisThreshold(value2 = DEFAULT_AXIS_THRESHOLD) {
      return value2;
    },
    bounds(value2 = {}) {
      if (typeof value2 === "function") {
        return (state) => coordinatesConfigResolver.bounds(value2(state));
      }
      if ("current" in value2) {
        return () => value2.current;
      }
      if (typeof HTMLElement === "function" && value2 instanceof HTMLElement) {
        return value2;
      }
      const {
        left = -Infinity,
        right = Infinity,
        top = -Infinity,
        bottom = Infinity
      } = value2;
      return [[left, right], [top, bottom]];
    }
  });
  const DISPLACEMENT = 10;
  const KEYS_DELTA_MAP = {
    ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
    ArrowLeft: (factor = 1) => [-10 * factor, 0],
    ArrowUp: (factor = 1) => [0, -10 * factor],
    ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
  };
  class DragEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "dragging");
    }
    reset() {
      super.reset();
      const state = this.state;
      state._pointerId = void 0;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
    setup() {
      const state = this.state;
      if (state._bounds instanceof HTMLElement) {
        const boundRect = state._bounds.getBoundingClientRect();
        const targetRect = state.currentTarget.getBoundingClientRect();
        const _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled) return;
      state.canceled = true;
      state._active = false;
      setTimeout(() => {
        this.compute();
        this.emit();
      }, 0);
    }
    setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
    clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;
      super.clean();
    }
    pointerDown(event) {
      const config2 = this.config;
      const state = this.state;
      if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons)) return;
      const ctrlIds = this.ctrl.setEventIds(event);
      if (config2.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }
      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();
      if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config2.delay > 0) {
        this.setupDelayTrigger(event);
        if (config2.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
    startPointerDrag(event) {
      const state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
    pointerMove(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._pointerActive) return;
      if (state.type === event.type && event.timeStamp === state.timeStamp) return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId) return;
      const _values = pointerValues(event);
      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = V.sub(_values, state._values);
        this.computeValues(_values);
      }
      V.addTo(state._movement, state._delta);
      this.compute(event);
      if (state._delayed && state.intentional) {
        this.timeoutStore.remove("dragDelay");
        state.active = false;
        this.startPointerDrag(event);
        return;
      }
      if (config2.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove("startPointerDrag");
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }
      this.emit();
    }
    pointerUp(event) {
      this.ctrl.setEventIds(event);
      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
        }
      }
      const state = this.state;
      const config2 = this.config;
      if (!state._active || !state._pointerActive) return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId) return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);
      const [dx, dy] = state._distance;
      state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
      if (state.tap && config2.filterTaps) {
        state._force = true;
      } else {
        const [dirx, diry] = state.direction;
        const [vx, vy] = state.velocity;
        const [mx, my] = state.movement;
        const [svx, svy] = config2.swipe.velocity;
        const [sx, sy] = config2.swipe.distance;
        const sdt = config2.swipe.duration;
        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;
        }
      }
      this.emit();
    }
    pointerClick(event) {
      if (!this.state.tap && event.detail > 0) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    setupPointer(event) {
      const config2 = this.config;
      const device = config2.device;
      if (process.env.NODE_ENV === "development") {
        try {
          if (device === "pointer" && config2.preventScrollDelay === void 0) {
            const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
            const style = window.getComputedStyle(currentTarget);
            if (style.touchAction === "auto") {
              console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
            }
          }
        } catch (_unused2) {
        }
      }
      if (config2.pointerLock) {
        event.currentTarget.requestPointerLock();
      }
      if (!config2.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
      }
    }
    pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
    preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
    setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
      this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
      this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
    setupDelayTrigger(event) {
      this.state._delayed = true;
      this.timeoutStore.add("dragDelay", () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      }, this.config.delay);
    }
    keyDown(event) {
      const deltaFn = KEYS_DELTA_MAP[event.key];
      if (deltaFn) {
        const state = this.state;
        const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
    keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP)) return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      bindFunction(device, "start", this.pointerDown.bind(this));
      if (this.config.pointerCapture) {
        bindFunction(device, "change", this.pointerMove.bind(this));
        bindFunction(device, "end", this.pointerUp.bind(this));
        bindFunction(device, "cancel", this.pointerUp.bind(this));
        bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
      }
      if (this.config.keys) {
        bindFunction("key", "down", this.keyDown.bind(this));
        bindFunction("key", "up", this.keyUp.bind(this));
      }
      if (this.config.filterTaps) {
        bindFunction("click", "", this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  }
  function persistEvent(event) {
    "persist" in event && typeof event.persist === "function" && event.persist();
  }
  const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents() {
    return isBrowser && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents() {
    return isBrowser && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e2) {
      return false;
    }
  }
  const SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
  };
  const DEFAULT_PREVENT_SCROLL_DELAY = 250;
  const DEFAULT_DRAG_DELAY = 180;
  const DEFAULT_SWIPE_VELOCITY = 0.5;
  const DEFAULT_SWIPE_DISTANCE = 50;
  const DEFAULT_SWIPE_DURATION = 250;
  const DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  const dragConfigResolver = _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch) return "touch";
      if (this.pointerLock) return "mouse";
      if (SUPPORT.pointer && !mouse) return "pointer";
      if (SUPPORT.touch) return "touch";
      return "mouse";
    },
    preventScrollAxis(value2, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value2 ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
      return value2 ? value2 : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1
      } = {}
    }) {
      this.pointerButtons = buttons;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    keys(value2 = true) {
      return value2;
    },
    threshold(value2, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value2, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity: velocity2 = DEFAULT_SWIPE_VELOCITY,
      distance = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity2)),
        distance: this.transform(V.toVector(distance)),
        duration
      };
    },
    delay(value2 = 0) {
      switch (value2) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value2;
      }
    },
    axisThreshold(value2) {
      if (!value2) return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread2$1(_objectSpread2$1({}, DEFAULT_DRAG_AXIS_THRESHOLD), value2);
    }
  });
  if (process.env.NODE_ENV === "development") {
    Object.assign(dragConfigResolver, {
      useTouch(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
        }
        return NaN;
      },
      experimental_preventWindowScrollY(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
        }
        return NaN;
      },
      swipeVelocity(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
        }
        return NaN;
      },
      swipeDistance(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
        }
        return NaN;
      },
      swipeDuration(value2) {
        if (value2 !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
        }
        return NaN;
      }
    });
  }
  const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
  const PINCH_WHEEL_RATIO = 100;
  class PinchEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "pinching");
      _defineProperty$1(this, "aliasKey", "da");
    }
    init() {
      this.state.offset = [1, 0];
      this.state.lastOffset = [1, 0];
      this.state._pointerEvents = /* @__PURE__ */ new Map();
    }
    reset() {
      super.reset();
      const state = this.state;
      state._touchIds = [];
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
      state.turns = 0;
    }
    computeOffset() {
      const {
        type: type2,
        movement,
        lastOffset
      } = this.state;
      if (type2 === "wheel") {
        this.state.offset = V.add(movement, lastOffset);
      } else {
        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
      }
    }
    computeMovement() {
      const {
        offset,
        lastOffset
      } = this.state;
      this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
    }
    axisIntent() {
      const state = this.state;
      const [_m0, _m1] = state._movement;
      if (!state.axis) {
        const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
        if (axisMovementDifference < 0) state.axis = "angle";
        else if (axisMovementDifference > 0) state.axis = "scale";
      }
    }
    restrictToAxis(v) {
      if (this.config.lockDirection) {
        if (this.state.axis === "scale") v[1] = 0;
        else if (this.state.axis === "angle") v[0] = 0;
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled) return;
      setTimeout(() => {
        state.canceled = true;
        state._active = false;
        this.compute();
        this.emit();
      }, 0);
    }
    touchStart(event) {
      this.ctrl.setEventIds(event);
      const state = this.state;
      const ctrlTouchIds = this.ctrl.touchIds;
      if (state._active) {
        if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
      }
      if (ctrlTouchIds.size < 2) return;
      this.start(event);
      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
      const payload = touchDistanceAngle(event, state._touchIds);
      this.pinchStart(event, payload);
    }
    pointerStart(event) {
      if (event.buttons != null && event.buttons % 2 !== 1) return;
      this.ctrl.setEventIds(event);
      event.target.setPointerCapture(event.pointerId);
      const state = this.state;
      const _pointerEvents = state._pointerEvents;
      const ctrlPointerIds = this.ctrl.pointerIds;
      if (state._active) {
        if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
      }
      if (_pointerEvents.size < 2) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (state._pointerEvents.size < 2) return;
      this.start(event);
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchStart(event, payload);
    }
    pinchStart(event, payload) {
      const state = this.state;
      state.origin = payload.origin;
      this.computeValues([payload.distance, payload.angle]);
      this.computeInitial();
      this.compute(event);
      this.emit();
    }
    touchMove(event) {
      if (!this.state._active) return;
      const payload = touchDistanceAngle(event, this.state._touchIds);
      this.pinchMove(event, payload);
    }
    pointerMove(event) {
      const _pointerEvents = this.state._pointerEvents;
      if (_pointerEvents.has(event.pointerId)) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (!this.state._active) return;
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchMove(event, payload);
    }
    pinchMove(event, payload) {
      const state = this.state;
      const prev_a = state._values[1];
      const delta_a = payload.angle - prev_a;
      let delta_turns = 0;
      if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
      state.origin = payload.origin;
      state.turns = delta_turns;
      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
      this.compute(event);
      this.emit();
    }
    touchEnd(event) {
      this.ctrl.setEventIds(event);
      if (!this.state._active) return;
      if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
        this.state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    pointerEnd(event) {
      const state = this.state;
      this.ctrl.setEventIds(event);
      try {
        event.target.releasePointerCapture(event.pointerId);
      } catch (_unused) {
      }
      if (state._pointerEvents.has(event.pointerId)) {
        state._pointerEvents.delete(event.pointerId);
      }
      if (!state._active) return;
      if (state._pointerEvents.size < 2) {
        state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    gestureStart(event) {
      if (event.cancelable) event.preventDefault();
      const state = this.state;
      if (state._active) return;
      this.start(event);
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    gestureMove(event) {
      if (event.cancelable) event.preventDefault();
      if (!this.state._active) return;
      const state = this.state;
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      const _previousMovement = state._movement;
      state._movement = [event.scale - 1, event.rotation];
      state._delta = V.sub(state._movement, _previousMovement);
      this.compute(event);
      this.emit();
    }
    gestureEnd(event) {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    wheel(event) {
      const modifierKey = this.config.modifierKey;
      if (modifierKey && !event[modifierKey]) return;
      if (!this.state._active) this.wheelStart(event);
      else this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelStart(event) {
      this.start(event);
      this.wheelChange(event);
    }
    wheelChange(event) {
      const isR3f = "uv" in event;
      if (!isR3f) {
        if (event.cancelable) {
          event.preventDefault();
        }
        if (process.env.NODE_ENV === "development" && !event.defaultPrevented) {
          console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
        }
      }
      const state = this.state;
      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
      V.addTo(state._movement, state._delta);
      this.state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      if (!!device) {
        bindFunction(device, "start", this[device + "Start"].bind(this));
        bindFunction(device, "change", this[device + "Move"].bind(this));
        bindFunction(device, "end", this[device + "End"].bind(this));
        bindFunction(device, "cancel", this[device + "End"].bind(this));
      }
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
  const pinchConfigResolver = _objectSpread2$1(_objectSpread2$1({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
      if (SUPPORT.touch && touch) return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer) return "pointer";
        if (SUPPORT.touch) return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D = assignDefault(call$1(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D.min, D.max];
      };
      const _angleBounds = (state) => {
        const A = assignDefault(call$1(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A.min, A.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value2, _k, config2) {
      this.lockDirection = config2.axis === "lock";
      const threshold = V.toVector(value2, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value2) {
      if (value2 === void 0) return "ctrlKey";
      return value2;
    }
  });
  class MoveEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "moving");
    }
    move(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      if (!this.state._active) this.moveStart(event);
      else this.moveChange(event);
      this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
    }
    moveStart(event) {
      this.start(event);
      this.computeValues(pointerValues(event));
      this.compute(event);
      this.computeInitial();
      this.emit();
    }
    moveChange(event) {
      if (!this.state._active) return;
      const values = pointerValues(event);
      const state = this.state;
      state._delta = V.sub(values, state._values);
      V.addTo(state._movement, state._delta);
      this.computeValues(values);
      this.compute(event);
      this.emit();
    }
    moveEnd(event) {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("pointer", "change", this.move.bind(this));
      bindFunction("pointer", "leave", this.moveEnd.bind(this));
    }
  }
  const moveConfigResolver = _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value2 = true) => value2
  });
  class ScrollEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "scrolling");
    }
    scroll(event) {
      if (!this.state._active) this.start(event);
      this.scrollChange(event);
      this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
    }
    scrollChange(event) {
      if (event.cancelable) event.preventDefault();
      const state = this.state;
      const values = scrollValues(event);
      state._delta = V.sub(values, state._values);
      V.addTo(state._movement, state._delta);
      this.computeValues(values);
      this.compute(event);
      this.emit();
    }
    scrollEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("scroll", "", this.scroll.bind(this));
    }
  }
  const scrollConfigResolver = coordinatesConfigResolver;
  class WheelEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "wheeling");
    }
    wheel(event) {
      if (!this.state._active) this.start(event);
      this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelChange(event) {
      const state = this.state;
      state._delta = wheelValues(event);
      V.addTo(state._movement, state._delta);
      const [ox, oy] = state.overflow;
      const [dx, dy] = state._delta;
      const [dirx, diry] = state._direction;
      if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
        state._movement[0] = state._movementBound[0];
      }
      if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
        state._movement[1] = state._movementBound[1];
      }
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active) return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("wheel", "", this.wheel.bind(this));
    }
  }
  const wheelConfigResolver = coordinatesConfigResolver;
  class HoverEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "hovering");
    }
    enter(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      this.start(event);
      this.computeValues(pointerValues(event));
      this.compute(event);
      this.emit();
    }
    leave(event) {
      if (this.config.mouseOnly && event.pointerType !== "mouse") return;
      const state = this.state;
      if (!state._active) return;
      state._active = false;
      const values = pointerValues(event);
      state._movement = state._delta = V.sub(values, state._values);
      this.computeValues(values);
      this.compute(event);
      state.delta = state.movement;
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("pointer", "enter", this.enter.bind(this));
      bindFunction("pointer", "leave", this.leave.bind(this));
    }
  }
  const hoverConfigResolver = _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value2 = true) => value2
  });
  const EngineMap = /* @__PURE__ */ new Map();
  const ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  const dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
  };
  const hoverAction = {
    key: "hover",
    engine: HoverEngine,
    resolver: hoverConfigResolver
  };
  const moveAction = {
    key: "move",
    engine: MoveEngine,
    resolver: moveConfigResolver
  };
  const pinchAction = {
    key: "pinch",
    engine: PinchEngine,
    resolver: pinchConfigResolver
  };
  const scrollAction = {
    key: "scroll",
    engine: ScrollEngine,
    resolver: scrollConfigResolver
  };
  const wheelAction = {
    key: "wheel",
    engine: WheelEngine,
    resolver: wheelConfigResolver
  };
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$3(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  const sharedConfigResolver = {
    target(value2) {
      if (value2) {
        return () => "current" in value2 ? value2.current : value2;
      }
      return void 0;
    },
    enabled(value2 = true) {
      return value2;
    },
    window(value2 = SUPPORT.isBrowser ? window : void 0) {
      return value2;
    },
    eventOptions({
      passive = true,
      capture = false
    } = {}) {
      return {
        passive,
        capture
      };
    },
    transform(value2) {
      return value2;
    }
  };
  const _excluded$4 = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config2 = {}, resolvers) {
    const result = {};
    for (const [key2, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          if (process.env.NODE_ENV === "development") {
            const r = resolver.call(result, config2[key2], key2, config2);
            if (!Number.isNaN(r)) result[key2] = r;
          } else {
            result[key2] = resolver.call(result, config2[key2], key2, config2);
          }
          break;
        case "object":
          result[key2] = resolveWith(config2[key2], resolver);
          break;
        case "boolean":
          if (resolver) result[key2] = config2[key2];
          break;
      }
    }
    return result;
  }
  function parse(newConfig, gestureKey, _config = {}) {
    const _ref = newConfig, {
      target,
      eventOptions,
      window: window2,
      enabled,
      transform: transform2
    } = _ref, rest = _objectWithoutProperties$1(_ref, _excluded$4);
    _config.shared = resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform: transform2
    }, sharedConfigResolver);
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread2$1({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key2 in rest) {
        const resolver = ConfigResolverMap.get(key2);
        if (resolver) {
          _config[key2] = resolveWith(_objectSpread2$1({
            shared: _config.shared
          }, rest[key2]), resolver);
        } else if (process.env.NODE_ENV === "development") {
          if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key2)) {
            if (key2 === "domTarget") {
              throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
            }
            console.warn(`[@use-gesture]: Unknown config key \`${key2}\` was used. Please read the documentation for further information.`);
          }
        }
      }
    }
    return _config;
  }
  class EventStore {
    constructor(ctrl, gestureKey) {
      _defineProperty$1(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options2) {
      const listeners = this._listeners;
      const type2 = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread2$1(_objectSpread2$1({}, _options), options2);
      element.addEventListener(type2, handler, eventOptions);
      const remove = () => {
        element.removeEventListener(type2, handler, eventOptions);
        listeners.delete(remove);
      };
      listeners.add(remove);
      return remove;
    }
    clean() {
      this._listeners.forEach((remove) => remove());
      this._listeners.clear();
    }
  }
  class TimeoutStore {
    constructor() {
      _defineProperty$1(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key2, callback, ms = 140, ...args) {
      this.remove(key2);
      this._timeouts.set(key2, window.setTimeout(callback, ms, ...args));
    }
    remove(key2) {
      const timeout = this._timeouts.get(key2);
      if (timeout) window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  }
  let Controller$1 = class Controller {
    constructor(handlers) {
      _defineProperty$1(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "_targetEventStore", new EventStore(this));
      _defineProperty$1(this, "gestureEventStores", {});
      _defineProperty$1(this, "gestureTimeoutStores", {});
      _defineProperty$1(this, "handlers", {});
      _defineProperty$1(this, "config", {});
      _defineProperty$1(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config2, gestureKey) {
      this.config = parse(config2, gestureKey, this.config);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key2 of this.gestures) {
        this.gestureEventStores[key2].clean();
        this.gestureTimeoutStores[key2].clean();
      }
    }
    effect() {
      if (this.config.shared.target) this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target) return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2$1(_objectSpread2$1({}, this.state.shared), {}, {
            event,
            args
          })), void 0, true);
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target) return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive
        });
      }
    }
  };
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag) setupGesture(ctrl, "drag");
    if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
    if (internalHandlers.move) setupGesture(ctrl, "move");
    if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
    if (internalHandlers.hover) setupGesture(ctrl, "hover");
  }
  const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options2 = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options2.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive = (_options$passive = options2.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive) handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
  const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
  function sortHandlers(_handlers) {
    const native = {};
    const handlers = {};
    const actions = /* @__PURE__ */ new Set();
    for (let key2 in _handlers) {
      if (RE_NOT_NATIVE.test(key2)) {
        actions.add(RegExp.lastMatch);
        handlers[key2] = _handlers[key2];
      } else {
        native[key2] = _handlers[key2];
      }
    }
    return [handlers, native, actions];
  }
  function registerGesture(actions, handlers, handlerKey, key2, internalHandlers, config2) {
    if (!actions.has(handlerKey)) return;
    if (!EngineMap.has(key2)) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key2}\` gesture but isn't properly configured.

Please add \`${key2}Action\` when creating your handler.`);
      }
      return;
    }
    const startKey = handlerKey + "Start";
    const endKey = handlerKey + "End";
    const fn = (state) => {
      let memo = void 0;
      if (state.first && startKey in handlers) handlers[startKey](state);
      if (handlerKey in handlers) memo = handlers[handlerKey](state);
      if (state.last && endKey in handlers) handlers[endKey](state);
      return memo;
    };
    internalHandlers[key2] = fn;
    config2[key2] = config2[key2] || {};
  }
  function parseMergedHandlers(mergedHandlers, mergedConfig) {
    const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
    const internalHandlers = {};
    registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
    return {
      handlers: internalHandlers,
      config: mergedConfig,
      nativeHandlers
    };
  }
  function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
    const ctrl = React.useMemo(() => new Controller$1(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config2, gestureKey);
    React.useEffect(ctrl.effect.bind(ctrl));
    React.useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config2.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function useDrag(handler, config2) {
    registerAction(dragAction);
    return useRecognizers({
      drag: handler
    }, config2 || {}, "drag");
  }
  function createUseGesture(actions) {
    actions.forEach(registerAction);
    return function useGesture2(_handlers, _config) {
      const {
        handlers,
        nativeHandlers,
        config: config2
      } = parseMergedHandlers(_handlers, _config || {});
      return useRecognizers(handlers, config2, void 0, nativeHandlers);
    };
  }
  function useGesture(handlers, config2) {
    const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
    return hook(handlers, {});
  }
  let updateQueue = makeQueue();
  const raf = (fn) => schedule(fn, updateQueue);
  let writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  let onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  let onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  let onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  let timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time2 = raf.now() + ms;
    let cancel = () => {
      let i2 = timeouts.findIndex((t) => t.cancel == cancel);
      if (~i2) timeouts.splice(i2, 1);
      pendingCount -= ~i2 ? 1 : 0;
    };
    let timeout = {
      time: time2,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time2), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  let findTimeout = (time2) => ~(~timeouts.findIndex((t) => t.time > time2) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  let nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  let ts = -1;
  let pendingCount = 0;
  let sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t) => t.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next = /* @__PURE__ */ new Set();
    let current = next;
    return {
      add(fn) {
        pendingCount += current == next && !next.has(fn) ? 1 : 0;
        next.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next && next.has(fn) ? 1 : 0;
        return next.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next.add(fn));
          pendingCount += next.size;
          current = next;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value2) => {
      try {
        each2(value2);
      } catch (e2) {
        raf.catch(e2);
      }
    });
  }
  function noop() {
  }
  const defineHidden = (obj, key2, value2) => Object.defineProperty(obj, key2, {
    value: value2,
    writable: true,
    configurable: true
  });
  const is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b) {
    if (is.arr(a)) {
      if (!is.arr(b) || a.length !== b.length) return false;
      for (let i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2]) return false;
      }
      return true;
    }
    return a === b;
  }
  const each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i2 = 0; i2 < obj.length; i2++) {
        fn.call(ctx2, obj[i2], `${i2}`);
      }
      return;
    }
    for (const key2 in obj) {
      if (obj.hasOwnProperty(key2)) {
        fn.call(ctx2, obj[key2], key2);
      }
    }
  }
  const toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  const flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  const isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  let createStringInterpolator$1;
  let to;
  let colors$1 = null;
  let skipAnimation = false;
  let willAdvance = noop;
  const assign = (globals2) => {
    if (globals2.to) to = globals2.to;
    if (globals2.now) raf.now = globals2.now;
    if (globals2.colors !== void 0) colors$1 = globals2.colors;
    if (globals2.skipAnimation != null) skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator) createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame) raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates) raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance) willAdvance = globals2.willAdvance;
    if (globals2.frameLoop) raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  const startQueue = /* @__PURE__ */ new Set();
  let currentFrame = [];
  let prevFrame = [];
  let priority = 0;
  const frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation)) startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i2 = 0; i2 < currentFrame.length; i2++) {
      const animation = currentFrame[i2];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index2 = arr.findIndex(test);
    return index2 < 0 ? arr.length : index2;
  }
  const clamp = (min, max, v) => Math.min(Math.max(v, min), max);
  const colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  const rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  const rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  const hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  const hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex6 = /^#([0-9a-fA-F]{6})$/;
  const hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color) {
    let match;
    if (typeof color === "number") {
      return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
    }
    if (match = hex6.exec(color)) return parseInt(match[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color] !== void 0) {
      return colors$1[color];
    }
    if (match = rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
    if (match = rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
    if (match = hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
    if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;
    if (match = hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
    if (match = hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
    if (match = hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p2, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  function hslToRgb(h, s2, l2) {
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q;
    const r = hue2rgb(p2, q, h + 1 / 3);
    const g = hue2rgb(p2, q, h);
    const b = hue2rgb(p2, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) return 0;
    if (int > 255) return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) return 0;
    if (num > 1) return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) return 0;
    if (int > 100) return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null) return input;
    int32Color = int32Color || 0;
    let r = (int32Color & 4278190080) >>> 24;
    let g = (int32Color & 16711680) >>> 16;
    let b = (int32Color & 65280) >>> 8;
    let a = (int32Color & 255) / 255;
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }
  const createInterpolator = (range2, output, extrapolate) => {
    if (is.fun(range2)) {
      return range2;
    }
    if (is.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is.str(range2.output[0])) {
      return createStringInterpolator$1(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t) => t);
    return (input) => {
      const range3 = findRange(input, inputRange);
      return interpolate(input, inputRange[range3], inputRange[range3 + 1], outputRange[range3], outputRange[range3 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity") return result;
      else if (extrapolateLeft === "clamp") result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity") return result;
      else if (extrapolateRight === "clamp") result = inputMax;
    }
    if (outputMin === outputMax) return outputMin;
    if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity) result = -result;
    else if (inputMax === Infinity) result = result - inputMin;
    else result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity) result = -result;
    else if (outputMax === Infinity) result = result + outputMin;
    else result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i2 = 1; i2 < inputRange.length - 1; ++i2) if (inputRange[i2] >= input) break;
    return i2 - 1;
  }
  const steps = (steps2, direction = "end") => (progress) => {
    progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 1e-3);
    const expanded = progress * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp(0, 1, rounded / steps2);
  };
  const c1 = 1.70158;
  const c2 = c1 * 1.525;
  const c3 = c1 + 1;
  const c4 = 2 * Math.PI / 3;
  const c5 = 2 * Math.PI / 4.5;
  const bounceOut = (x) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  };
  const easings = {
    linear: (x) => x,
    easeInQuad: (x) => x * x,
    easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
    easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
    easeInCubic: (x) => x * x * x,
    easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
    easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
    easeInQuart: (x) => x * x * x * x,
    easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
    easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
    easeInQuint: (x) => x * x * x * x * x,
    easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
    easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
    easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
    easeOutSine: (x) => Math.sin(x * Math.PI / 2),
    easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
    easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
    easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
    easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
    easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
    easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
    easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
    easeInBack: (x) => c3 * x * x * x - c1 * x * x,
    easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
    easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
    easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
    easeInBounce: (x) => 1 - bounceOut(1 - x),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
    steps
  };
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  const $get = Symbol.for("FluidValue.get");
  const $observers = Symbol.for("FluidValue.observers");
  const hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  const getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  const getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers = target[$observers];
    if (observers) {
      observers.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  class FluidValue {
    constructor(get) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  }
  const setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer)) {
        observers.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers = target[$observers];
    if (observers && observers.has(observer)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  const setHidden = (target, key2, value2) => Object.defineProperty(target, key2, {
    value: value2,
    writable: true,
    configurable: true
  });
  const numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  const unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  const rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  const variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable(input);
    if (!token || isSSR()) {
      return input;
    }
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value2) {
      return value2.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  const parseCSSVariable = (current) => {
    const match = cssVariableRegex.exec(current);
    if (!match) return [,];
    const [, token, fallback] = match;
    return [token, fallback];
  };
  let namedColorRegex;
  const rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  const createStringInterpolator = (config2) => {
    if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output = config2.output.map((value2) => {
      return getFluidValue(value2).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes = output.map((value2) => value2.match(numberRegex).map(Number));
    const outputRanges = keyframes[0].map((_, i2) => keyframes.map((values) => {
      if (!(i2 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i2];
    }));
    const interpolators = outputRanges.map((output2) => createInterpolator(_extends$3({}, config2, {
      output: output2
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value2) => unitRegex.test(value2))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i2 = 0;
      return output[0].replace(numberRegex, () => `${interpolators[i2++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  const prefix = "react-spring: ";
  const once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  const warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  const warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
  }
  function isAnimatedString(value2) {
    return is.str(value2) && (value2[0] == "#" || /\d/.test(value2) || !isSSR() && cssVariableRegex.test(value2) || value2 in (colors$1 || {}));
  }
  const useIsomorphicLayoutEffect$1 = isSSR() ? React.useEffect : React.useLayoutEffect;
  const useIsMounted = () => {
    const isMounted = React.useRef(false);
    useIsomorphicLayoutEffect$1(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate$1() {
    const update2 = React.useState()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update2(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = React.useState(() => ({
      inputs,
      result: getResult()
    }));
    const committed = React.useRef();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(cache.inputs && areInputsEqual(inputs, cache.inputs));
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    React.useEffect(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next, prev) {
    if (next.length !== prev.length) {
      return false;
    }
    for (let i2 = 0; i2 < next.length; i2++) {
      if (next[i2] !== prev[i2]) {
        return false;
      }
    }
    return true;
  }
  const useOnce = (effect2) => React.useEffect(effect2, emptyDeps);
  const emptyDeps = [];
  function usePrev(value2) {
    const prevRef = React.useRef();
    React.useEffect(() => {
      prevRef.current = value2;
    });
    return prevRef.current;
  }
  const $node = Symbol.for("Animated:node");
  const isAnimated = (value2) => !!value2 && value2[$node] === value2;
  const getAnimated = (owner) => owner && owner[$node];
  const setAnimated = (owner, node) => defineHidden(owner, $node, node);
  const getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  class Animated {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  }
  class AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value2) {
      return new AnimatedValue(value2);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value2, step) {
      if (is.num(value2)) {
        this.lastPosition = value2;
        if (step) {
          value2 = Math.round(value2 / step) * step;
          if (this.done) {
            this.lastPosition = value2;
          }
        }
      }
      if (this._value === value2) {
        return false;
      }
      this._value = value2;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }
  class AnimatedString extends AnimatedValue {
    constructor(value2) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value2, value2]
      });
    }
    static create(value2) {
      return new AnimatedString(value2);
    }
    getValue() {
      let value2 = this._string;
      return value2 == null ? this._string = this._toString(this._value) : value2;
    }
    setValue(value2) {
      if (is.str(value2)) {
        if (value2 == this._string) {
          return false;
        }
        this._string = value2;
        this._value = 1;
      } else if (super.setValue(value2)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  }
  const TreeContext = {
    dependencies: null
  };
  class AnimatedObject extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key2) => {
        if (isAnimated(source)) {
          values[key2] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key2] = getFluidValue(source);
        } else if (!animated2) {
          values[key2] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  }
  class AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i2) => node.setValue(source[i2])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  }
  function makeAnimated(value2) {
    const nodeType = isAnimatedString(value2) ? AnimatedString : AnimatedValue;
    return nodeType.create(value2);
  }
  function getAnimatedType(value2) {
    const parentNode = getAnimated(value2);
    return parentNode ? parentNode.constructor : is.arr(value2) ? AnimatedArray : isAnimatedString(value2) ? AnimatedString : AnimatedValue;
  }
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const withAnimated = (Component, host2) => {
    const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
    return React.forwardRef((givenProps, givenRef) => {
      const instanceRef = React.useRef(null);
      const ref = hasInstance && React.useCallback((value2) => {
        instanceRef.current = updateRef(givenRef, value2);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate$1();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = React.useRef();
      useIsomorphicLayoutEffect$1(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      React.useEffect(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React__namespace.createElement(Component, _extends$2({}, usedProps, {
        ref
      }));
    });
  };
  class PropsObserver {
    constructor(update2, deps) {
      this.update = update2;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  }
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style) props = _extends$2({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value2) {
    if (ref) {
      if (is.fun(ref)) ref(value2);
      else ref.current = value2;
    }
    return value2;
  }
  const cacheKey = Symbol.for("AnimatedComponent");
  const createHost = (components, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components, (Component, key2) => {
      if (is.arr(components)) {
        key2 = getDisplayName(Component);
      }
      animated2[key2] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  const getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function callProp(value2, ...args) {
    return is.fun(value2) ? value2(...args) : value2;
  }
  const matchProp = (value2, key2) => value2 === true || !!(key2 && value2 && (is.fun(value2) ? value2(key2) : toArray(value2).includes(key2)));
  const resolveProp = (prop, key2) => is.obj(prop) ? key2 && prop[key2] : prop;
  const getDefaultProp = (props, key2) => props.default === true ? props[key2] : props.default ? props.default[key2] : void 0;
  const noopTransform = (value2) => value2;
  const getDefaultProps = (props, transform2 = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key2 of keys) {
      const value2 = transform2(props[key2], key2);
      if (!is.und(value2)) {
        defaults2[key2] = value2;
      }
    }
    return defaults2;
  };
  const DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  const RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value2, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value2;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val2, key2) => key2 in to2 || (out[key2] = val2));
      return out;
    }
    return _extends$1({}, props);
  }
  function computeGoal(value2) {
    value2 = getFluidValue(value2);
    return is.arr(value2) ? value2.map(computeGoal) : isAnimatedString(value2) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value2, value2]
    })(1) : value2;
  }
  function hasProps(props) {
    for (const _ in props) return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _ctrl$ref;
    (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    if (ref && ctrl.ref !== ref) {
      var _ctrl$ref2;
      (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  const config$1 = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  const defaults = _extends$1({}, config$1.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  class AnimationConfig {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  }
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = _extends$1({}, defaultConfig);
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = _extends$1({}, defaultConfig, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key2 in defaults) {
      if (config2[key2] == null) {
        config2[key2] = defaults[key2];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01) frequency = 0.01;
      if (damping < 0) damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  const emptyArray = [];
  class Animation {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  }
  function scheduleProps(callId, {
    key: key2,
    props,
    defaultProps: defaultProps2,
    state,
    actions
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps2 == null ? void 0 : defaultProps2.cancel, key2);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key2);
        }
        let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key2);
        }
        delay = callProp(props.delay || 0, key2);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(_extends$1({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  const getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  const getNoopResult = (value2) => ({
    value: value2,
    noop: true,
    finished: true,
    cancelled: false
  });
  const getFinishedResult = (value2, finished, cancelled = false) => ({
    value: value2,
    finished,
    cancelled
  });
  const getCancelledResult = (value2) => ({
    value: value2,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps2 = getDefaultProps(props, (value2, key2) => key2 === "onRest" ? void 0 : value2);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps2, (value2, key2) => {
            if (is.und(props2[key2])) {
              props2[key2] = value2;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t) => t.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId) state.cancelId = cancelId;
  }
  class BailSignal extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  }
  class SkipAnimationSignal extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  }
  const isFrameValue = (value2) => value2 instanceof FrameValue;
  let nextId$1 = 1;
  class FrameValue extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1) this._attach();
    }
    observerRemoved(count) {
      if (count == 0) this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value2, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value: value2,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  }
  const $P = Symbol.for("SpringPhase");
  const HAS_ANIMATED = 1;
  const IS_ANIMATING = 2;
  const IS_PAUSED = 4;
  const hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  const isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  const isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  const setActiveBit = (target, active2) => active2 ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= -3;
  const setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= -5;
  class SpringValue extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i2) => {
        if (node2.done) return;
        const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i2].lastPosition : toValues[i2];
        let finished = anim.immediate;
        let position2 = to2;
        if (!finished) {
          position2 = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt;
          const from = anim.fromValues[i2];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i2] : config2.velocity;
          let velocity2;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          if (!is.und(config2.duration)) {
            let p2 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt;
                }
              }
              p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
              node2.durationProgress = p2;
            }
            position2 = from + config2.easing(p2) * (to2 - from);
            velocity2 = (position2 - node2.lastPosition) / dt;
            finished = p2 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e2 = Math.exp(-(1 - decay) * elapsed);
            position2 = from + v0 / (1 - decay) * (1 - e2);
            finished = Math.abs(node2.lastPosition - position2) <= precision;
            velocity2 = v0 * e2;
          } else {
            velocity2 = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity2) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position2) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position2 == to2 || position2 > to2 == isGrowing;
                if (isBouncing) {
                  velocity2 = -velocity2 * bounceFactor;
                  position2 = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position2 - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity2;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity2 = velocity2 + acceleration * step;
              position2 = position2 + velocity2 * step;
            }
          }
          node2.lastVelocity = velocity2;
          if (Number.isNaN(position2)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i2].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position2, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value2) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value2);
        this._set(value2);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends$1({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key2 = this.key || "";
      let {
        to: to2,
        from
      } = props;
      to2 = is.obj(to2) ? to2[key2] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key2] : from;
      if (from == null) {
        from = void 0;
      }
      const range2 = {
        to: to2,
        from
      };
      if (!hasAnimated(this)) {
        if (props.reverse) [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    _update(_ref, isLoop) {
      let props = _extends$1({}, _ref);
      const {
        key: key2,
        defaultProps: defaultProps2
      } = this;
      if (props.default) Object.assign(defaultProps2, getDefaultProps(props, (value2, prop) => /^on/.test(prop) ? resolveProp(value2, key2) : value2));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key: key2,
        props,
        defaultProps: defaultProps2,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range2.to);
      const hasFromProp = !is.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key: key2,
        defaultProps: defaultProps2,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from = prevFrom
      } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse) [to2, from] = [from, to2];
      const hasFromChanged = !isEqual(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay,
        velocity: velocity2
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key2), props.config !== defaultProps2.config ? callProp(defaultProps2.config, key2) : void 0);
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key2);
      const value2 = reset ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key2));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value2), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity2)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type2) => mergeActiveFn(this, props, type2));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed) raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps2.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
        }
      }
      if (reset) {
        this._set(value2);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value2));
      }
    }
    _focus(value2) {
      const anim = this.animation;
      if (value2 !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value2;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value2 = getFluidValue(arg);
      if (!is.und(value2)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value2, oldNode.getValue())) {
          const nodeType = getAnimatedType(value2);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value2));
          } else {
            oldNode.setValue(value2);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value2, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value2, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value2, this);
      }
      callProp(this.defaultProps.onChange, value2, this);
      super._onChange(value2, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  }
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value2 = computeGoal(target.get());
    return isEqual(value2, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(_extends$1({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        from: reset ? props.from : void 0,
        reset
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2)) findDefined(to2, keys);
    if (is.obj(from)) findDefined(from, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function declareUpdate(props) {
    const update2 = createUpdate(props);
    if (is.und(update2.default)) {
      update2.default = getDefaultProps(update2);
    }
    return update2;
  }
  function findDefined(values, keys) {
    eachProp(values, (value2, key2) => value2 != null && keys.add(key2));
  }
  const ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type2) {
    target.animation[type2] = props[type2] !== getDefaultProp(props, type2) ? resolveProp(props[type2], target.key) : void 0;
  }
  function sendEvent(target, type2, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type2]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type2]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  const BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  let nextId = 1;
  class Controller {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends$1({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    get() {
      const values = {};
      this.each((spring, key2) => values[key2] = spring.get());
      return values;
    }
    set(values) {
      for (const key2 in values) {
        const value2 = values[key2];
        if (!is.und(value2)) {
          this.springs[key2].set(value2);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray(keys), (key2) => springs[key2].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key2) => springs[key2].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key2) => springs[key2].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active2 = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active2 && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active2 && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else return;
      raf.onFrame(this._onFrame);
    }
  }
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false) props.to = null;
    if (from === false) props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key2) => {
        const handler = props[key2];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key2];
          props[key2] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished) result2.finished = false;
              if (cancelled) result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key2] = props[key2];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key2) => ctrl.springs[key2].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = _extends$1({}, ctrl.springs);
    if (props) {
      each(toArray(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = _extends$1({}, props2, {
            to: void 0
          });
        }
        prepareSprings(springs, props2, (key2) => {
          return createSpring(key2);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key2) => {
      if (!ctrl.springs[key2]) {
        ctrl.springs[key2] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key2, observer) {
    const spring = new SpringValue();
    spring.key = key2;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key2) => {
        const spring = springs[key2] || (springs[key2] = create(key2));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key2) => {
        return createSpring(key2, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  const _excluded$6 = ["children"];
  const SpringContext = (_ref) => {
    let {
      children
    } = _ref, props = _objectWithoutPropertiesLoose$2(_ref, _excluded$6);
    const inherited = React.useContext(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider
    } = ctx;
    return React__namespace.createElement(Provider, {
      value: props
    }, children);
  };
  const ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React__namespace.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  const SpringRef = () => {
    const current = [];
    const SpringRef2 = function SpringRef3(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i2) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = _getProps(props, ctrl, i2);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i2 = current.indexOf(ctrl);
      if (~i2) current.splice(i2, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl) => ctrl.set(values));
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i2) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = this._getProps(props, ctrl, i2);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i2) => ctrl.update(this._getProps(props, ctrl, i2)));
      return this;
    };
    const _getProps = function _getProps2(arg, ctrl, index2) {
      return is.fun(arg) ? arg(index2, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length2, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps) deps = [];
    const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
    const layoutId = React.useRef(0);
    const forceUpdate = useForceUpdate$1();
    const state = React.useMemo(() => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key2) => !ctrl.springs[key2]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }), []);
    const ctrls = React.useRef([...state.ctrls]);
    const updates = [];
    const prevLength = usePrev(length2) || 0;
    React.useMemo(() => {
      each(ctrls.current.slice(length2, prevLength), (ctrl) => {
        detachRefs(ctrl, ref);
        ctrl.stop(true);
      });
      ctrls.current.length = length2;
      declareUpdates(prevLength, length2);
    }, [length2]);
    React.useMemo(() => {
      declareUpdates(0, Math.min(prevLength, length2));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i2 = startIndex; i2 < endIndex; i2++) {
        const ctrl = ctrls.current[i2] || (ctrls.current[i2] = new Controller(null, state.flush));
        const update2 = propsFn ? propsFn(i2, ctrl) : props[i2];
        if (update2) {
          updates[i2] = declareUpdate(update2);
        }
      }
    }
    const springs = ctrls.current.map((ctrl, i2) => getSprings(ctrl, updates[i2]));
    const context2 = React.useContext(SpringContext);
    const prevContext = usePrev(context2);
    const hasContext = context2 !== prevContext && hasProps(context2);
    useIsomorphicLayoutEffect$1(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const {
        queue
      } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb) => cb());
      }
      each(ctrls.current, (ctrl, i2) => {
        ref == null ? void 0 : ref.add(ctrl);
        if (hasContext) {
          ctrl.start({
            default: context2
          });
        }
        const update2 = updates[i2];
        if (update2) {
          replaceRef(ctrl, update2.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update2);
          } else {
            ctrl.start(update2);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x) => _extends$1({}, x));
    return ref ? [values, ref] : values;
  }
  function useSpring(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? [] : deps);
    return isFn || arguments.length == 2 ? [values, ref] : values;
  }
  let TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  class Interpolation extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value2 = this._get();
      const nodeType = getAnimatedType(value2);
      setAnimated(this, nodeType.create(value2));
    }
    advance(_dt) {
      const value2 = this._get();
      const oldValue = this.get();
      if (!isEqual(value2, oldValue)) {
        getAnimated(this).setValue(value2);
        this._onChange(value2, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce((highest, parent2) => Math.max(highest, (isFrameValue(parent2) ? parent2.priority : 0) + 1), 0);
      }
    }
  }
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active2) {
    return !active2.size || Array.from(active2).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  const _excluded$2 = ["style", "children", "scrollTop", "scrollLeft", "viewBox"];
  const isCustomPropRE = /^--/;
  function dangerousStyleValue(name2, value2) {
    if (value2 == null || typeof value2 === "boolean" || value2 === "") return "";
    if (typeof value2 === "number" && value2 !== 0 && !isCustomPropRE.test(name2) && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) return value2 + "px";
    return ("" + value2).trim();
  }
  const attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref = props, {
      style,
      children,
      scrollTop,
      scrollLeft,
      viewBox
    } = _ref, attributes = _objectWithoutPropertiesLoose$1(_ref, _excluded$2);
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map((name2) => isFilterElement || instance.hasAttribute(name2) ? name2 : attributeCache[name2] || (attributeCache[name2] = name2.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name2 in style) {
      if (style.hasOwnProperty(name2)) {
        const value2 = dangerousStyleValue(name2, style[name2]);
        if (isCustomPropRE.test(name2)) {
          instance.style.setProperty(name2, value2);
        } else {
          instance.style[name2] = value2;
        }
      }
    }
    names.forEach((name2, i2) => {
      instance.setAttribute(name2, values[i2]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance.setAttribute("viewBox", viewBox);
    }
  }
  let isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  const prefixKey = (prefix2, key2) => prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
  const prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  const _excluded$1$1 = ["x", "y", "z"];
  const domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  const pxTransforms = /^(translate)/;
  const degTransforms = /^(rotate|skew)/;
  const addUnit = (value2, unit) => is.num(value2) && value2 !== 0 ? value2 + unit : value2;
  const isValueIdentity = (value2, id) => is.arr(value2) ? value2.every((v) => isValueIdentity(v, id)) : is.num(value2) ? value2 === id : parseFloat(value2) === id;
  class AnimatedStyle extends AnimatedObject {
    constructor(_ref) {
      let {
        x,
        y,
        z
      } = _ref, style = _objectWithoutPropertiesLoose$1(_ref, _excluded$1$1);
      const inputs = [];
      const transforms = [];
      if (x || y || z) {
        inputs.push([x || 0, y || 0, z || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value2, key2) => {
        if (key2 === "transform") {
          inputs.push([value2 || ""]);
          transforms.push((transform2) => [transform2, transform2 === ""]);
        } else if (domTransforms.test(key2)) {
          delete style[key2];
          if (is.und(value2)) return;
          const unit = pxTransforms.test(key2) ? "px" : degTransforms.test(key2) ? "deg" : "";
          inputs.push(toArray(value2));
          transforms.push(key2 === "rotate3d" ? ([x2, y2, z2, deg]) => [`rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key2}(${input.map((v) => addUnit(v, unit)).join(",")})`, isValueIdentity(input, key2.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  }
  class FluidTransform extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform2 = "";
      let identity2 = true;
      each(this.inputs, (input, i2) => {
        const arg1 = getFluidValue(input[0]);
        const [t, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform2 += " " + t;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform2;
    }
    observerAdded(count) {
      if (count == 1) each(this.inputs, (input) => each(input, (value2) => hasFluidValue(value2) && addFluidObserver(value2, this)));
    }
    observerRemoved(count) {
      if (count == 0) each(this.inputs, (input) => each(input, (value2) => hasFluidValue(value2) && removeFluidObserver(value2, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  }
  const primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  const _excluded$3 = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: ReactDOM.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  const host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref) => {
      let props = _objectWithoutPropertiesLoose$1(_ref, _excluded$3);
      return props;
    }
  });
  const animated = host.animated;
  var elevatorContext = /* @__PURE__ */ React.createContext({});
  var defaultProps$1n = _object_spread_props(_object_spread({}, ComponentDefaults), {
    height: "200px",
    floorKey: "title",
    list: [],
    sticky: false,
    spaceHeight: 23,
    titleHeight: 35,
    showKeys: true
  });
  var Elevator = function(props) {
    var _ref = _object_spread({}, defaultProps$1n, props), height2 = _ref.height, floorKey = _ref.floorKey, list = _ref.list, sticky = _ref.sticky, spaceHeight = _ref.spaceHeight;
    _ref.titleHeight;
    var showKeys = _ref.showKeys, className = _ref.className, style = _ref.style, onItemClick = _ref.onItemClick, onIndexClick = _ref.onIndexClick, children = _ref.children, rest = _object_without_properties(_ref, [
      "height",
      "floorKey",
      "list",
      "sticky",
      "spaceHeight",
      "titleHeight",
      "showKeys",
      "className",
      "style",
      "onItemClick",
      "onIndexClick",
      "children"
    ]);
    var classPrefix2 = "nut-elevator";
    var listview = React.useRef(null);
    var initData = {
      anchorIndex: 0,
      listHeight: [],
      listGroup: [],
      scrollY: 0
    };
    var touchState = React.useRef({
      y1: 0,
      y2: 0
    });
    var _useState = _sliced_to_array(React.useState(0), 2), scrollY = _useState[0], setScrollY = _useState[1];
    var _useState1 = _sliced_to_array(React.useState({}), 2), currentData = _useState1[0], setCurrentData = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(""), 2), currentKey = _useState2[0], setCurrentKey = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(0), 2), currentIndex = _useState3[0], setCurrentIndex = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState(0), 2), codeIndex = _useState4[0], setCodeIndex = _useState4[1];
    var _useState5 = _sliced_to_array(React.useState(false), 2), scrollStart = _useState5[0], setScrollStart = _useState5[1];
    var state = React.useRef(initData);
    var resetScrollState = function() {
      setScrollStart(false);
    };
    var getData = function(el, name2) {
      var prefix2 = "data-";
      return el.getAttribute(prefix2 + name2);
    };
    var calculateHeight = function() {
      var height3 = 0;
      state.current.listHeight.push(height3);
      for (var i2 = 0; i2 < state.current.listGroup.length; i2++) {
        var item = state.current.listGroup[i2];
        height3 += item.clientHeight;
        state.current.listHeight.push(height3);
      }
    };
    var scrollTo = function(index2) {
      if (!index2 && index2 !== 0) {
        return;
      }
      if (!state.current.listHeight.length) {
        calculateHeight();
      }
      var cacheIndex = index2;
      if (index2 < 0) {
        cacheIndex = 0;
      }
      if (index2 > state.current.listHeight.length - 2) {
        cacheIndex = Math.max(0, state.current.listHeight.length - 2);
      }
      setCodeIndex(cacheIndex);
      if (listview.current) {
        listview.current.scrollTo(0, state.current.listHeight[cacheIndex]);
      }
    };
    var bind = useGesture({
      onDragStart: function(param) {
        var target = param.target, offset = param.offset;
        setScrollStart(true);
        var index2 = Number(getData(target, "index"));
        touchState.current.y1 = offset[1];
        state.current.anchorIndex = +index2;
        setCodeIndex(function(codeIndex2) {
          return codeIndex2 + index2;
        });
        scrollTo(index2);
      },
      onDragEnd: function(param) {
        var offset = param.offset;
        touchState.current.y2 = offset[1];
        var delta = (touchState.current.y2 - touchState.current.y1) / spaceHeight || 0;
        var cacheIndex = state.current.anchorIndex + Math.round(delta);
        setCodeIndex(cacheIndex);
        scrollTo(cacheIndex);
        resetScrollState();
      }
    });
    var handleClickItem = function(key2, item) {
      onItemClick && onItemClick(key2, item);
      setCurrentData(item);
      setCurrentKey(key2);
    };
    var handleClickIndex = function(key2) {
      onIndexClick && onIndexClick(key2);
    };
    var setListGroup = function() {
      if (listview.current) {
        var els = listview.current.querySelectorAll(".nut-elevator-list-item");
        els.forEach(function(el) {
          if (el != null && !state.current.listGroup.includes(el)) {
            state.current.listGroup.push(el);
          }
        });
      }
    };
    var listViewScroll = function(e2) {
      var listHeight = state.current.listHeight;
      if (!listHeight.length) {
        calculateHeight();
      }
      var target = e2.target;
      var scrollTop = target.scrollTop;
      scrollTop = Math.ceil(scrollTop);
      state.current.scrollY = scrollTop;
      setScrollY(scrollTop);
      for (var i2 = 0; i2 < listHeight.length - 1; i2++) {
        var height1 = listHeight[i2];
        var height22 = listHeight[i2 + 1];
        if (state.current.scrollY >= height1 && state.current.scrollY < height22) {
          setCurrentIndex(i2);
          return;
        }
      }
      setCurrentIndex(listHeight.length - 2);
    };
    React.useEffect(function() {
      if (listview.current) {
        setListGroup();
        listview.current.addEventListener("scroll", listViewScroll);
      }
    }, [
      listview
    ]);
    var _obj;
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classPrefix2, " ").concat(className),
      style
    }, rest), sticky && scrollY > 0 ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-list-fixed")
    }, /* @__PURE__ */ React.createElement("span", {
      className: "".concat(classPrefix2, "-list-fixed-title")
    }, list[currentIndex][floorKey])) : null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-list"),
      style: {
        height: Number.isNaN(+height2) ? height2 : "".concat(height2, "px")
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-list-inner"),
      ref: listview
    }, list.map(function(item, idx) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-list-item"),
        key: idx
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-list-item-code")
      }, item[floorKey]), /* @__PURE__ */ React.createElement(React.Fragment, null, item.list.map(function(subitem) {
        var _obj2;
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-list-item-name"), true), _define_property(_obj2, "".concat(classPrefix2, "-list-item-name-highcolor"), currentData.id === subitem.id && currentKey === item[floorKey]), _obj2)),
          key: subitem.id,
          onClick: function() {
            return handleClickItem(item[floorKey], subitem);
          }
        }, children ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(elevatorContext.Provider, {
          value: subitem
        }, children)) : subitem.name);
      })));
    }))), showKeys ? /* @__PURE__ */ React.createElement(React.Fragment, null, list.length && scrollStart ? /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-code-current"), true), _define_property(_obj, "".concat(classPrefix2, "-code-current-current"), true), _obj))
    }, list[codeIndex][floorKey]) : null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-bars")
    }, /* @__PURE__ */ React.createElement(animated.div, _object_spread_props(_object_spread({
      className: "".concat(classPrefix2, "-bars-inner")
    }, bind()), {
      style: {
        touchAction: "pan-y"
      }
    }), list.map(function(item, index2) {
      var _list_currentIndex;
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-bars-inner-item"), true), _define_property(_obj2, "".concat(classPrefix2, "-bars-inner-item-active"), item[floorKey] === ((_list_currentIndex = list[currentIndex]) === null || _list_currentIndex === void 0 ? void 0 : _list_currentIndex[floorKey])), _obj2)),
        "data-index": index2,
        key: index2,
        onClick: function() {
          return handleClickIndex(item[floorKey]);
        }
      }, item[floorKey]);
    })))) : null);
  };
  Elevator.displayName = "NutElevator";
  Elevator.Context = elevatorContext;
  var defaultProps$1m = _object_spread_props(_object_spread({}, ComponentDefaults), {
    value: "",
    dot: false,
    max: 99,
    top: 0,
    right: 0,
    fill: "solid",
    size: "large",
    disabled: false
  });
  var Badge = function(props) {
    var isIcon = function isIcon2() {
      if ((typeof value2 === "undefined" ? "undefined" : _type_of(value2)) === "object" && value2) return value2;
    };
    var isNumber = function isNumber2() {
      if (typeof value2 === "number" && value2) return value2;
    };
    var isString = function isString2() {
      if (typeof value2 === "string" && value2) return value2;
    };
    var _this;
    var rtl = useRtl();
    var _$_object_spread = _object_spread({}, defaultProps$1m, props), className = _$_object_spread.className, style = _$_object_spread.style, value2 = _$_object_spread.value, max = _$_object_spread.max, children = _$_object_spread.children, dot = _$_object_spread.dot, top = _$_object_spread.top, right = _$_object_spread.right, fill = _$_object_spread.fill, size = _$_object_spread.size, disabled = _$_object_spread.disabled;
    var classPrefix2 = "nut-badge";
    var classes = classNames(classPrefix2, className);
    var getContent = function() {
      if (dot || value2 === 0) return null;
      if (typeof value2 === "number") {
        return max < value2 ? "".concat(max, "+") : "".concat(value2);
      }
      return value2;
    };
    var _obj;
    var contentClasses = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-sup"), isNumber() || isString() || dot), _define_property(_obj, "".concat(classPrefix2, "-number"), isNumber()), _define_property(_obj, "".concat(classPrefix2, "-one"), typeof getContent() === "string" && ((_this = "".concat(getContent())) === null || _this === void 0 ? void 0 : _this.length) === 1), _define_property(_obj, "".concat(classPrefix2, "-dot"), dot), _define_property(_obj, "".concat(classPrefix2, "-dot-").concat(size), dot), _define_property(_obj, "".concat(classPrefix2, "-").concat(fill), fill === "outline"), _define_property(_obj, "".concat(classPrefix2, "-content"), children), _define_property(_obj, "".concat(classPrefix2, "-disabled"), disabled), _obj));
    var getPositionStyle = function() {
      return _define_property({
        top: "".concat(Number(top) || 0, "px")
      }, rtl ? "left" : "right", "".concat(Number(right) || 0, "px"));
    };
    var _obj1;
    return /* @__PURE__ */ React.createElement("div", {
      className: classes,
      style
    }, isIcon() && /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-content"), (_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-icon"), true), _define_property(_obj1, "".concat(classPrefix2, "-icon-rtl"), rtl), _obj1)),
      style: getPositionStyle()
    }, value2), children, !isIcon() && (getContent() || dot) && /* @__PURE__ */ React.createElement("div", {
      className: contentClasses,
      style: getPositionStyle()
    }, getContent()));
  };
  Badge.displayName = "NutBadge";
  var defaultProps$1l = _object_spread_props(_object_spread({}, defaultOverlayProps), {
    activeText: "",
    inactiveText: "",
    type: "right",
    list: [],
    overlay: true,
    position: {
      top: "auto",
      bottom: "auto"
    },
    zIndex: 200,
    onChange: function(value2) {
    },
    onSelect: function() {
    }
  });
  var FixedNav = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$1l, props), overlay = _ref.overlay, visible = _ref.visible, list = _ref.list, activeText = _ref.activeText, inactiveText = _ref.inactiveText, position2 = _ref.position, type2 = _ref.type, children = _ref.children, style = _ref.style, className = _ref.className, content2 = _ref.content, zIndex = _ref.zIndex, onChange = _ref.onChange, onSelect = _ref.onSelect, rest = _object_without_properties(_ref, [
      "overlay",
      "visible",
      "list",
      "activeText",
      "inactiveText",
      "position",
      "type",
      "children",
      "style",
      "className",
      "content",
      "zIndex",
      "onChange",
      "onSelect"
    ]);
    var classPrefix2 = "nut-fixednav";
    var classes = classNames(classPrefix2, {
      active: visible
    }, "".concat(classPrefix2, "-").concat(type2), className);
    var renderListItem = function(item, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-list-item"),
        onClick: function(event) {
          return onSelect(item, event);
        },
        key: item.id || index2
      }, /* @__PURE__ */ React.isValidElement(item.icon) ? item.icon : /* @__PURE__ */ React.createElement("img", {
        src: item.icon,
        alt: "",
        className: "".concat(classPrefix2, "-list-image")
      }), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-list-text")
      }, item.text));
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      style: _object_spread({}, position2, style)
    }, rest), overlay && /* @__PURE__ */ React.createElement(Overlay, {
      visible,
      zIndex,
      onClick: function() {
        return onChange(false);
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "list"
    }, children || /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-list")
    }, list.map(function(item, index2) {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, item.num ? /* @__PURE__ */ React.createElement(Badge, {
        value: item.num,
        top: 8,
        right: 6
      }, renderListItem(item, index2)) : /* @__PURE__ */ React.createElement(React.Fragment, null, renderListItem(item, index2)));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-btn"),
      onClick: function() {
        return onChange(!visible);
      }
    }, content2 || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(d$7, {
      color: "#fff"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "text"
    }, visible ? activeText || locale.fixednav.activeText : inactiveText || locale.fixednav.inactiveText))));
  };
  FixedNav.displayName = "NutFixedNav";
  var defaultProps$1k = _object_spread_props(_object_spread({}, ComponentDefaults), {
    left: "",
    right: "",
    back: "",
    fixed: false,
    safeAreaInsetTop: false,
    placeholder: false,
    zIndex: 10
  });
  var NavBar = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1k, props), right = _$_object_spread.right, left = _$_object_spread.left, title = _$_object_spread.title, className = _$_object_spread.className, style = _$_object_spread.style, back = _$_object_spread.back, fixed = _$_object_spread.fixed, safeAreaInsetTop = _$_object_spread.safeAreaInsetTop, placeholder = _$_object_spread.placeholder, zIndex = _$_object_spread.zIndex, onBackClick = _$_object_spread.onBackClick;
    var classPrefix2 = "nut-navbar";
    var rtl = useRtl();
    var children = Array.isArray(props.children) ? props.children : [
      props.children
    ];
    var styles = function() {
      return _object_spread_props(_object_spread({}, style), {
        zIndex
      });
    };
    var renderLeft = function() {
      var _obj2, _obj1;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-left"), true), _define_property(_obj2, "".concat(classPrefix2, "-left-maxwidth"), title), _define_property(_obj2, "".concat(classPrefix2, "-left-hidden"), !left && !back), _define_property(_obj2, "".concat(classPrefix2, "-left-rtl"), rtl), _obj2))
      }, back ? /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-left-back"), true), _define_property(_obj1, "".concat(classPrefix2, "-left-back-children"), left), _define_property(_obj1, "".concat(classPrefix2, "-left-back-children-rtl"), left && rtl), _obj1)),
        onClick: function(e2) {
          return onBackClick(e2);
        }
      }, back) : null, left);
    };
    var renderContent = function() {
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-title"), true), _define_property(_obj2, "".concat(classPrefix2, "-title-center"), title), _obj2))
      }, title || children);
    };
    var renderRight = function() {
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-right"), true), _define_property(_obj2, "".concat(classPrefix2, "-right-maxwidth"), title), _define_property(_obj2, "".concat(classPrefix2, "-right-rtl"), rtl), _obj2))
      }, right);
    };
    var renderWrapper = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: cls,
        style: styles()
      }, renderLeft(), renderContent(), renderRight());
    };
    var _obj;
    var classes = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-fixed"), fixed), _define_property(_obj, "".concat(classPrefix2, "-safe-area-inset-top"), safeAreaInsetTop), _define_property(_obj, "".concat(classPrefix2, "-rtl"), rtl), _obj));
    var cls = classNames(classPrefix2, classes, className, _define_property({}, "".concat(classPrefix2, "-title-wrapper"), title));
    return /* @__PURE__ */ React.createElement(React.Fragment, null, safeAreaInsetTop && /* @__PURE__ */ React.createElement(SafeArea, {
      position: "top"
    }), fixed && placeholder ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-placeholder")
    }, renderWrapper()) : renderWrapper());
  };
  NavBar.displayName = "NutNavBar";
  var defaultProps$1j = {
    title: "",
    value: "",
    disabled: false
  };
  var SideBarItem = function(props) {
    var _mergeProps = mergeProps(defaultProps$1j, props), children = _mergeProps.children, className = _mergeProps.className, disabled = _mergeProps.disabled;
    var classPrefix2 = "nut-sidebaritem";
    var classes = classNames(classPrefix2, {
      active: !disabled && props.active
    }, className);
    return children ? /* @__PURE__ */ React.createElement("div", {
      className: classes
    }, !disabled && children) : null;
  };
  function useForceUpdate() {
    var _React_useState = _sliced_to_array(React.useState(), 2), updateState = _React_useState[1];
    return React.useCallback(function() {
      return updateState({});
    }, []);
  }
  function usePropsValue(param) {
    var value2 = param.value, defaultValue = param.defaultValue, finalValue = param.finalValue, _param_onChange = param.onChange, onChange = _param_onChange === void 0 ? function(value3) {
    } : _param_onChange;
    var forceUpdate = useForceUpdate();
    var dfValue = defaultValue !== void 0 ? defaultValue : finalValue;
    var stateRef = React.useRef(value2 !== void 0 ? value2 : dfValue);
    if (value2 !== void 0) {
      stateRef.current = value2;
    }
    var setState = React.useCallback(function(v) {
      var forceTrigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var prevState = stateRef.current;
      stateRef.current = v;
      if (prevState !== stateRef.current || forceTrigger) {
        forceUpdate();
        onChange === null || onChange === void 0 ? void 0 : onChange(v);
      }
    }, [
      value2,
      onChange
    ]);
    return [
      stateRef.current,
      setState
    ];
  }
  var defaultProps$1i = _object_spread_props(_object_spread({}, ComponentDefaults), {
    contentDuration: 0,
    sidebarDuration: 0
  });
  var classPrefix$l = "nut-sidebar";
  var SideBar = function(props) {
    var _mergeProps = mergeProps(defaultProps$1i, props), contentDuration = _mergeProps.contentDuration, sidebarDuration = _mergeProps.sidebarDuration, children = _mergeProps.children, onClick = _mergeProps.onClick, onChange = _mergeProps.onChange, className = _mergeProps.className, rest = _object_without_properties(_mergeProps, [
      "contentDuration",
      "sidebarDuration",
      "children",
      "onClick",
      "onChange",
      "className"
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: props.value,
      defaultValue: props.defaultValue,
      finalValue: 0,
      onChange
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var titleItemsRef = React.useRef([]);
    var navRef = React.useRef(null);
    var scroll = function(nav, to2) {
      var count = 0;
      var from = nav.scrollTop;
      var frames2 = sidebarDuration === 0 ? 1 : Math.round(sidebarDuration / 16);
      function animate() {
        nav.scrollTop += (to2 - from) / frames2;
        if (++count < frames2) {
          requestAniFrame$1(animate);
        }
      }
      animate();
    };
    var scrollIntoView = function(index2) {
      var nav = navRef.current;
      var titleItem = titleItemsRef.current;
      var titlesLength = titles.current.length;
      var itemLength = titleItemsRef.current.length;
      if (!nav || !titleItem || !titleItem[itemLength - titlesLength + index2]) {
        return;
      }
      var title = titleItem[itemLength - titlesLength + index2];
      var runTop = title.offsetTop - nav.offsetTop + 10;
      var to2 = runTop - (nav.offsetHeight - title.offsetHeight) / 2 + title.offsetHeight;
      scroll(nav, to2);
    };
    var getTitles = function() {
      var titles2 = [];
      React.Children.forEach(children, function(child, idx) {
        if (/* @__PURE__ */ React.isValidElement(child)) {
          var _$props = child === null || child === void 0 ? void 0 : child.props;
          if ((_$props === null || _$props === void 0 ? void 0 : _$props.title) || (_$props === null || _$props === void 0 ? void 0 : _$props.value)) {
            var _props_value;
            titles2.push({
              title: _$props.title,
              value: (_props_value = _$props.value) !== null && _props_value !== void 0 ? _props_value : idx,
              disabled: _$props.disabled
            });
          }
        }
      });
      return titles2;
    };
    var titles = React.useRef(getTitles());
    var forceUpdate = useForceUpdate();
    React.useEffect(function() {
      titles.current = getTitles();
      titles.current.forEach(function(title) {
        if (title.value === value2) ;
      });
      forceUpdate();
    }, [
      children
    ]);
    var classes = classNames(classPrefix$l, className);
    var classesTitle = classNames("".concat(classPrefix$l, "-titles"), "".concat(classPrefix$l, "-titles-scrollable"));
    var getContentStyle = function() {
      var index2 = titles.current.findIndex(function(t) {
        return t.value === value2;
      });
      index2 = index2 < 0 ? 0 : index2;
      return {
        transform: "translate3d( 0,-".concat(index2 * 100, "%, 0)"),
        transitionDuration: "".concat(contentDuration, "ms")
      };
    };
    React.useEffect(function() {
      var index2 = titles.current.findIndex(function(t) {
        return t.value === value2;
      });
      index2 = index2 < 0 ? 0 : index2;
      var rafId = requestAnimationFrame(function() {
        scrollIntoView(index2);
      });
      return function() {
        return cancelAnimationFrame(rafId);
      };
    }, [
      value2
    ]);
    var tabChange = function(item) {
      if (item.disabled) return;
      onClick === null || onClick === void 0 ? void 0 : onClick(item.value);
      setValue(item.value);
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classesTitle,
      ref: navRef
    }, titles.current.map(function(item) {
      var _obj;
      return /* @__PURE__ */ React.createElement("div", {
        onClick: function() {
          tabChange(item);
        },
        className: classNames("".concat(classPrefix$l, "-titles-item"), (_obj = {}, _define_property(_obj, "".concat(classPrefix$l, "-titles-item-active"), !item.disabled && String(item.value) === String(value2)), _define_property(_obj, "".concat(classPrefix$l, "-titles-item-disabled"), item.disabled), _obj)),
        ref: function(ref) {
          return titleItemsRef.current.push(ref);
        },
        key: item.value
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$l, "-titles-item-text")
      }, item.title));
    })), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$l, "-content-wrap")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$l, "-content"),
      style: getContentStyle()
    }, React.Children.map(children, function(child, idx) {
      if (!/* @__PURE__ */ React.isValidElement(child)) {
        return null;
      }
      var childProps = _object_spread_props(_object_spread({}, child.props), {
        active: value2 === child.props.value
      });
      if (String(value2) !== String(child.props.value || idx)) {
        childProps = _object_spread({}, childProps);
      }
      return /* @__PURE__ */ React.cloneElement(child, childProps);
    }))));
  };
  SideBar.displayName = "NutSideBar";
  SideBar.Item = SideBarItem;
  const TabbarContext = React.createContext(null);
  var defaultProps$1h = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: "",
    icon: null,
    value: "",
    dot: false,
    max: 99,
    top: "0",
    right: "0",
    direction: "vertical"
  });
  var TabbarItem = function(props) {
    var ctx2 = React.useContext(TabbarContext);
    var _ref = _object_spread({}, defaultProps$1h, props), className = _ref.className, style = _ref.style, title = _ref.title, icon = _ref.icon, value2 = _ref.value, dot = _ref.dot, max = _ref.max, top = _ref.top, right = _ref.right, index2 = _ref.index, direction = _ref.direction, onActiveClick = _ref.onActiveClick, rest = _object_without_properties(_ref, [
      "className",
      "style",
      "title",
      "icon",
      "value",
      "dot",
      "max",
      "top",
      "right",
      "index",
      "direction",
      "onActiveClick"
    ]);
    var active2 = index2 === (ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.selectIndex);
    var classPrefix2 = "nut-tabbar-item";
    var _obj;
    var tabbarItemClass = classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-active"), active2), _define_property(_obj, "".concat(classPrefix2, "-large"), !icon || !title), _obj), className);
    var renderNodeWithActive = function(node) {
      return node && typeof node === "function" ? node(active2) : node;
    };
    var badgeProps = {
      value: renderNodeWithActive(value2),
      dot,
      max,
      top,
      right,
      color: ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.activeColor
    };
    var renderTitleText = function() {
      return title && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-text")
      }, renderNodeWithActive(title));
    };
    var renderTitle = function() {
      return /* @__PURE__ */ React.createElement(Badge, _object_spread({
        size: "normal"
      }, badgeProps), renderTitleText());
    };
    var renderIcon = function() {
      return renderNodeWithActive(icon);
    };
    var renderIconAndTitle = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Badge, _object_spread_props(_object_spread({
        size: "normal"
      }, badgeProps), {
        top: 3
      }), renderIcon()), renderTitleText());
    };
    var renderDualItem = function() {
      return dot ? null : /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), renderTitleText(), /* @__PURE__ */ React.createElement(Badge, badgeProps));
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: tabbarItemClass,
      style: _object_spread({
        color: active2 ? ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.activeColor : ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.inactiveColor
      }, style),
      onClick: function() {
        return active2 ? onActiveClick === null || onActiveClick === void 0 ? void 0 : onActiveClick() : ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.handleClick(index2);
      }
    }, rest), direction === "horizontal" && !dot ? renderDualItem() : /* @__PURE__ */ React.createElement(React.Fragment, null, icon && renderIconAndTitle(), !icon && renderTitle()));
  };
  var defaultProps$1g = _object_spread_props(_object_spread({}, ComponentDefaults), {
    defaultValue: 0,
    fixed: false,
    inactiveColor: "",
    activeColor: "",
    direction: "vertical",
    safeArea: false,
    onSwitch: function() {
    }
  });
  var Tabbar = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1g, props), children = _$_object_spread.children, defaultValue = _$_object_spread.defaultValue, value2 = _$_object_spread.value, fixed = _$_object_spread.fixed, activeColor = _$_object_spread.activeColor, inactiveColor = _$_object_spread.inactiveColor, direction = _$_object_spread.direction, safeArea = _$_object_spread.safeArea, className = _$_object_spread.className, style = _$_object_spread.style, onSwitch = _$_object_spread.onSwitch;
    var classPrefix2 = "nut-tabbar";
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: 0,
      onChange: onSwitch
    }), 2), selectIndex = _usePropsValue[0], setSelectIndex = _usePropsValue[1];
    var sizeCls = React.useMemo(function() {
      var size = React.Children.count(children);
      var _obj;
      return size > 3 ? "" : classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-wrap-3"), size === 3), _define_property(_obj, "".concat(classPrefix2, "-wrap-2"), size === 2), _define_property(_obj, "".concat(classPrefix2, "-wrap-").concat(direction), size === 2 && direction !== "vertical"), _obj));
    }, [
      children,
      direction
    ]);
    var itemDirection = React.useMemo(function() {
      var size = React.Children.count(children);
      return size === 2 && direction !== "vertical" && direction;
    }, [
      direction,
      children
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, _define_property({}, "".concat(classPrefix2, "-fixed"), fixed), className),
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-wrap ").concat(sizeCls)
    }, /* @__PURE__ */ React.createElement(TabbarContext.Provider, {
      value: {
        selectIndex,
        activeColor,
        inactiveColor,
        handleClick: setSelectIndex
      }
    }, React.Children.map(children, function(child, index2) {
      return /* @__PURE__ */ React.isValidElement(child) ? /* @__PURE__ */ React.cloneElement(child, _object_spread_props(_object_spread({}, child.props), {
        index: index2,
        direction: itemDirection
      })) : null;
    }))), (fixed || safeArea) && /* @__PURE__ */ React.createElement(SafeArea, {
      position: "bottom"
    }));
  };
  Tabbar.displayName = "NutTabbar";
  Tabbar.Item = TabbarItem;
  var defaultProps$1f = {
    title: "",
    value: "",
    disabled: false
  };
  var TabPane = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1f, props), children = _$_object_spread.children, autoHeightClassName = _$_object_spread.autoHeightClassName, className = _$_object_spread.className, disabled = _$_object_spread.disabled;
    var classPrefix2 = "nut-tabpane";
    var classes = classNames(classPrefix2, {
      active: !disabled && props.active
    }, autoHeightClassName, className);
    return children ? /* @__PURE__ */ React.createElement("div", {
      className: classes
    }, !disabled && children) : null;
  };
  var defaultProps$1e = _object_spread_props(_object_spread({}, ComponentDefaults), {
    tabStyle: {},
    activeColor: "",
    direction: "horizontal",
    activeType: "line",
    duration: 300,
    autoHeight: false
  });
  var classPrefix$k = "nut-tabs";
  var Tabs = function(props) {
    var rtl = useRtl();
    var _ref = _object_spread({}, defaultProps$1e, props), activeColor = _ref.activeColor, tabStyle = _ref.tabStyle, direction = _ref.direction, activeType = _ref.activeType, duration = _ref.duration, align = _ref.align, title = _ref.title, children = _ref.children, onClick = _ref.onClick, onChange = _ref.onChange, className = _ref.className, autoHeight = _ref.autoHeight, outerValue = _ref.value, outerDefaultValue = _ref.defaultValue, rest = _object_without_properties(_ref, [
      "activeColor",
      "tabStyle",
      "direction",
      "activeType",
      "duration",
      "align",
      "title",
      "children",
      "onClick",
      "onChange",
      "className",
      "autoHeight",
      "value",
      "defaultValue"
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: outerValue,
      defaultValue: outerDefaultValue,
      onChange
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var titleItemsRef = React.useRef([]);
    var navRef = React.useRef(null);
    var scrollDirection = function(nav, to2, duration2) {
      var from = direction === "horizontal" ? nav.scrollLeft : nav.scrollTop;
      var frames2 = Math.round(duration2 * 1e3 / 16);
      var count = 0;
      var animate = function() {
        if (direction === "horizontal") nav.scrollLeft += (to2 - from) / frames2;
        else nav.scrollTop += (to2 - from) / frames2;
        if (++count < frames2) requestAniFrame$1(animate);
      };
      animate();
    };
    var scrollIntoView = function(index2, immediate) {
      var nav = navRef.current;
      var titleItem = titleItemsRef.current;
      var titlesLength = titles.current.length;
      var itemLength = titleItem.length;
      if (!nav || !titleItem || !titleItem[itemLength - titlesLength + index2]) {
        return;
      }
      var title2 = titleItem[itemLength - titlesLength + index2];
      var to2 = 0;
      if (direction === "vertical") {
        var runTop = title2.offsetTop - nav.offsetTop + 10;
        to2 = runTop - (nav.offsetHeight - title2.offsetHeight) / 2;
      } else {
        to2 = title2.offsetLeft - (nav.offsetWidth - title2.offsetWidth) / 2;
      }
      scrollDirection(nav, to2, 0.3);
    };
    var getTitles = function() {
      var titles2 = [];
      React.Children.forEach(children, function(child, idx) {
        if (/* @__PURE__ */ React.isValidElement(child)) {
          var _$props = child.props;
          if ((_$props === null || _$props === void 0 ? void 0 : _$props.title) || (_$props === null || _$props === void 0 ? void 0 : _$props.value)) {
            titles2.push({
              title: _$props.title,
              value: _$props.value || idx,
              disabled: _$props.disabled
            });
          }
        }
      });
      return titles2;
    };
    var titles = React.useRef(getTitles());
    var forceUpdate = useForceUpdate();
    React.useEffect(function() {
      titles.current = getTitles();
      var current = "";
      titles.current.forEach(function(title2) {
        if (title2.value === value2) {
          current = value2;
        }
      });
      if (current !== "" && current !== value2) {
        setValue(current);
      } else {
        forceUpdate();
      }
    }, [
      children
    ]);
    var classes = classNames(classPrefix$k, "".concat(classPrefix$k, "-").concat(direction), className);
    var _obj;
    var classesTitle = classNames("".concat(classPrefix$k, "-titles"), (_obj = {}, _define_property(_obj, "".concat(classPrefix$k, "-titles-").concat(activeType), activeType), _define_property(_obj, "".concat(classPrefix$k, "-titles-scrollable"), true), _define_property(_obj, "".concat(classPrefix$k, "-titles-").concat(align), align), _obj));
    var getContentStyle = function() {
      var index2 = titles.current.findIndex(function(t) {
        return t.value === value2;
      });
      index2 = index2 < 0 ? 0 : index2;
      return {
        transform: direction === "horizontal" ? "translate3d(".concat(rtl ? "" : "-").concat(index2 * 100, "%, 0, 0)") : "translate3d( 0, -".concat(index2 * 100, "%, 0)"),
        transitionDuration: "".concat(duration, "ms")
      };
    };
    React.useEffect(function() {
      var index2 = titles.current.findIndex(function(t) {
        return t.value === value2;
      });
      index2 = index2 < 0 ? 0 : index2;
      setTimeout(function() {
        scrollIntoView(index2);
      });
    }, [
      value2
    ]);
    var tabChange = function(item) {
      onClick && onClick(item.value);
      if (!item.disabled) {
        setValue(item.value);
      }
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classesTitle,
      style: tabStyle,
      ref: navRef
    }, !!title && typeof title === "function" ? title() : titles.current.map(function(item) {
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        key: item.value,
        ref: function(ref) {
          return titleItemsRef.current.push(ref);
        },
        onClick: function() {
          return tabChange(item);
        },
        className: classNames("".concat(classPrefix$k, "-titles-item"), (_obj2 = {}, _define_property(_obj2, "nut-tabs-titles-item-active", !item.disabled && String(item.value) === String(value2)), _define_property(_obj2, "nut-tabs-titles-item-disabled", item.disabled), _define_property(_obj2, "nut-tabs-titles-item-".concat(align), align), _obj2))
      }, activeType === "line" && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$k, "-titles-item-line"), "".concat(classPrefix$k, "-titles-item-line-").concat(direction)),
        style: {
          background: activeColor
        }
      }), activeType === "smile" && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$k, "-titles-item-smile")
      }, /* @__PURE__ */ React.createElement(c$1, {
        color: activeColor,
        width: 40,
        height: 20
      })), /* @__PURE__ */ React.createElement("div", {
        className: classNames(_define_property({}, "".concat(classPrefix$k, "-ellipsis"), direction === "vertical"), "".concat(classPrefix$k, "-titles-item-text")),
        style: {
          color: activeColor
        }
      }, item.title));
    })), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$k, "-content-wrap")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$k, "-content"),
      style: getContentStyle()
    }, React.Children.map(children, function(child, idx) {
      if (!/* @__PURE__ */ React.isValidElement(child)) return null;
      return /* @__PURE__ */ React.cloneElement(child, _object_spread_props(_object_spread({}, child.props), {
        active: value2 === child.props.value,
        autoHeightClassName: autoHeight && String(value2) !== String(child.props.value || idx) ? "inactive" : ""
      }));
    }))));
  };
  Tabs.displayName = "NutTabs";
  Tabs.TabPane = TabPane;
  var defaultProps$1d = _object_spread_props(_object_spread({}, defaultOverlayProps), {
    position: "center",
    transition: "",
    overlayStyle: {},
    overlayClassName: "",
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    destroyOnClose: false,
    portal: null,
    overlay: true,
    round: false,
    onOpen: function() {
    },
    onClose: function() {
    },
    onOverlayClick: function() {
      return true;
    },
    onCloseIconClick: function() {
      return true;
    }
  });
  var _zIndex = 1100;
  var Popup = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$1d, props), children = _$_object_spread.children, visible = _$_object_spread.visible, overlay = _$_object_spread.overlay, closeOnOverlayClick = _$_object_spread.closeOnOverlayClick, overlayStyle = _$_object_spread.overlayStyle, overlayClassName = _$_object_spread.overlayClassName, zIndex = _$_object_spread.zIndex, lockScroll = _$_object_spread.lockScroll, duration = _$_object_spread.duration, closeable = _$_object_spread.closeable, closeIconPosition = _$_object_spread.closeIconPosition, closeIcon = _$_object_spread.closeIcon, left = _$_object_spread.left, title = _$_object_spread.title, description = _$_object_spread.description, style = _$_object_spread.style, transition = _$_object_spread.transition, round = _$_object_spread.round, position2 = _$_object_spread.position, className = _$_object_spread.className, destroyOnClose = _$_object_spread.destroyOnClose, portal = _$_object_spread.portal, onOpen = _$_object_spread.onOpen, onClose = _$_object_spread.onClose, onOverlayClick = _$_object_spread.onOverlayClick, onCloseIconClick = _$_object_spread.onCloseIconClick, afterShow = _$_object_spread.afterShow, afterClose = _$_object_spread.afterClose, onClick = _$_object_spread.onClick;
    var nodeRef = React.useRef(null);
    var innerIndex = zIndex || _zIndex;
    var _useState = _sliced_to_array(React.useState(innerIndex), 2), index2 = _useState[0], setIndex = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(visible), 2), innerVisible = _useState1[0], setInnerVisible = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(true), 2), showChildren = _useState2[0], setShowChildren = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(""), 2), transitionName = _useState3[0], setTransitionName = _useState3[1];
    useLockScroll(nodeRef, innerVisible && lockScroll);
    var classPrefix2 = "nut-popup";
    var overlayStyles = _object_spread({}, overlayStyle);
    var popStyles = _object_spread_props(_object_spread({}, style), {
      zIndex: index2
    });
    var _obj;
    var popClassName = classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-round"), round || position2 === "bottom"), _define_property(_obj, "".concat(classPrefix2, "-").concat(position2), true), _obj), className);
    var open = function() {
      if (!innerVisible) {
        setInnerVisible(true);
        setIndex(++innerIndex);
      }
      if (destroyOnClose) {
        setShowChildren(true);
      }
      onOpen && onOpen();
    };
    var close = function() {
      if (innerVisible) {
        setInnerVisible(false);
        if (destroyOnClose) {
          setTimeout(function() {
            setShowChildren(false);
          }, Number(duration));
        }
        onClose && onClose();
      }
    };
    var handleOverlayClick = function(e2) {
      e2.stopPropagation();
      if (closeOnOverlayClick && onOverlayClick(e2)) {
        close();
      }
    };
    var handleCloseIconClick = function(e2) {
      onCloseIconClick(e2) && close();
    };
    var renderCloseIcon = function() {
      var closeClasses = classNames("".concat(classPrefix2, "-title-right"), "".concat(classPrefix2, "-title-right-").concat(closeIconPosition));
      return /* @__PURE__ */ React.createElement(React.Fragment, null, closeable && /* @__PURE__ */ React.createElement("div", {
        className: closeClasses,
        onClick: handleCloseIconClick
      }, /* @__PURE__ */ React.isValidElement(closeIcon) ? closeIcon : /* @__PURE__ */ React.createElement(n$6, null)));
    };
    var renderTitle = function() {
      if (left || title || description) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-title")
        }, position2 === "bottom" && /* @__PURE__ */ React.createElement(React.Fragment, null, left && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-title-left")
        }, left), (title || description) && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-title-wrapper")
        }, title && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-title-title")
        }, title), description && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-title-description ").concat(title ? "".concat(classPrefix2, "-title-description-gap") : "")
        }, description))), renderCloseIcon());
      }
      if (closeable) {
        return renderCloseIcon();
      }
    };
    var renderPop = function() {
      return /* @__PURE__ */ React.createElement(CSSTransition, {
        nodeRef,
        classNames: transitionName,
        mountOnEnter: true,
        unmountOnExit: destroyOnClose,
        timeout: duration,
        in: innerVisible,
        onEntered: afterShow,
        onExited: afterClose
      }, /* @__PURE__ */ React.createElement("div", {
        ref: nodeRef,
        style: popStyles,
        className: popClassName,
        onClick
      }, renderTitle(), showChildren && children));
    };
    var renderNode = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, overlay && /* @__PURE__ */ React.createElement(Overlay, {
        zIndex: index2,
        style: overlayStyles,
        className: overlayClassName,
        visible: innerVisible,
        closeOnOverlayClick,
        lockScroll,
        duration,
        onClick: handleOverlayClick
      }), renderPop());
    };
    React.useEffect(function() {
      visible ? open() : close();
    }, [
      visible
    ]);
    React.useEffect(function() {
      setTransitionName(transition || "".concat(classPrefix2, "-slide-").concat(position2));
    }, [
      position2,
      transition
    ]);
    var resolveContainer = function(getContainer) {
      return (typeof getContainer === "function" ? getContainer() : getContainer) || document.body;
    };
    var renderToContainer = function(getContainer, node) {
      if (getContainer) {
        var container = resolveContainer(getContainer);
        return /* @__PURE__ */ ReactDOM.createPortal(node, container);
      }
      return node;
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, renderToContainer(portal, renderNode()));
  };
  Popup.displayName = "NutPopup";
  function _to_primitive(input, hint) {
    if (_type_of(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (_type_of(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  function _to_property_key(arg) {
    var key2 = _to_primitive(arg, "string");
    return _type_of(key2) === "symbol" ? key2 : String(key2);
  }
  var normalizeOptions = function(options2, keyMap) {
    if (!options2) return void 0;
    return options2.map(function(opt) {
      var _keyMap_textKey = keyMap.textKey, _keyMap_valueKey = keyMap.valueKey, _keyMap_childrenKey = keyMap.childrenKey, text2 = opt[_keyMap_textKey], value2 = opt[_keyMap_valueKey], children = opt[_keyMap_childrenKey], others = _object_without_properties(opt, [
        _keyMap_textKey,
        _keyMap_valueKey,
        _keyMap_childrenKey
      ].map(_to_property_key));
      return _object_spread({
        text: text2,
        value: value2,
        children: normalizeOptions(children, keyMap)
      }, others);
    });
  };
  var normalizeListOptions = function(options2, format2) {
    var defaultConvertConfig = {
      topId: null,
      idKey: "id",
      pidKey: "pid",
      sortKey: "sortKey"
    };
    var mergedFormat = _object_spread({}, defaultConvertConfig, format2);
    var topId = mergedFormat.topId, idKey = mergedFormat.idKey, pidKey = mergedFormat.pidKey, sortKey = mergedFormat.sortKey;
    var map = {};
    options2.forEach(function(opt) {
      var pid = opt[pidKey], id = opt[idKey], others = _object_without_properties(opt, [
        pidKey,
        idKey
      ].map(_to_property_key));
      var newNode = _object_spread({
        pid,
        id
      }, others);
      if (map[pid]) {
        map[pid].push(newNode);
      } else {
        map[pid] = [
          newNode
        ];
      }
    });
    for (var key2 in map) {
      if (!Object.prototype.hasOwnProperty.call(map, key2)) continue;
      map[key2].sort(function(a, b) {
        return a[sortKey] - b[sortKey];
      });
      map[key2].forEach(function(option) {
        if (map[option.id]) {
          option.children = map[option.id];
        }
      });
    }
    return map[topId];
  };
  var getRefValue = function(ref) {
    return ref.current;
  };
  var useRefState = function(param) {
    var ref = React.useRef(param);
    var _useState = _sliced_to_array(React.useState(param), 2), setState = _useState[1];
    var updateState = function(p2) {
      ref.current = p2;
      setState(p2);
    };
    return [
      ref,
      updateState
    ];
  };
  var defaultProps$1c = _object_spread_props(_object_spread({}, ComponentDefaults), {
    activeColor: "",
    activeIcon: "checklist",
    popup: true,
    options: [],
    optionKey: {},
    format: {},
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    lazy: false,
    onClose: function() {
    },
    onChange: function() {
    },
    onPathChange: function() {
    }
  });
  var Cascader = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var classPrefix2 = "nut-cascader";
    var classPane = "".concat(classPrefix2, "-pane");
    var _mergeProps = mergeProps(defaultProps$1c, props), activeColor = _mergeProps.activeColor, activeIcon = _mergeProps.activeIcon, popup = _mergeProps.popup, _mergeProps_popupProps = _mergeProps.popupProps, popupProps = _mergeProps_popupProps === void 0 ? {} : _mergeProps_popupProps, outerVisible = _mergeProps.visible, outerOptions = _mergeProps.options, outerValue = _mergeProps.value, outerDefaultValue = _mergeProps.defaultValue, optionKey = _mergeProps.optionKey, format2 = _mergeProps.format, closeable = _mergeProps.closeable, closeIconPosition = _mergeProps.closeIconPosition, closeIcon = _mergeProps.closeIcon, lazy = _mergeProps.lazy, onLoad = _mergeProps.onLoad;
    var locale = useConfig().locale;
    var _useState = _sliced_to_array(React.useState(0), 2), tabActiveIndex = _useState[0], setTabActiveIndex = _useState[1];
    var _useRefState = _sliced_to_array(useRefState(outerOptions), 2), optionsRef = _useRefState[0], setInnerOptions = _useRefState[1];
    var innerOptions = getRefValue(optionsRef);
    var _useState1 = _sliced_to_array(React.useState({}), 2), loading = _useState1[0], setLoading = _useState1[1];
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: outerValue,
      defaultValue: outerDefaultValue,
      finalValue: [],
      onChange: function(value3) {
        var _props_onChange, _props_onPathChange;
        (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, value3, pathNodes.current);
        (_props_onPathChange = props.onPathChange) === null || _props_onPathChange === void 0 ? void 0 : _props_onPathChange.call(props, value3, pathNodes.current);
      }
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var _useState2 = _sliced_to_array(React.useState(value2), 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
    var options2 = React.useMemo(function() {
      if (!isEmpty(format2)) {
        return normalizeListOptions(innerOptions, format2);
      }
      if (!isEmpty(optionKey)) {
        return normalizeOptions(innerOptions, optionKey);
      }
      return innerOptions;
    }, [
      innerOptions,
      optionKey,
      format2,
      innerValue
    ]);
    var pathNodes = React.useRef([]);
    var levels = React.useMemo(function() {
      var next = [];
      var end = false;
      var currentOptions = options2;
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        var _loop = function() {
          var _step_value = _sliced_to_array(_step.value, 2), index2 = _step_value[0], val2 = _step_value[1];
          var opt = currentOptions === null || currentOptions === void 0 ? void 0 : currentOptions.find(function(o) {
            return o.value === val2;
          });
          next.push({
            selected: val2,
            selectedText: opt === null || opt === void 0 ? void 0 : opt.text,
            pane: currentOptions
          });
          pathNodes.current[index2] = opt;
          if (opt === null || opt === void 0 ? void 0 : opt.children) {
            currentOptions = opt.children;
          } else {
            end = true;
            return "break";
          }
        };
        for (var _iterator = innerValue.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ret = _loop();
          if (_ret === "break") break;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      if (!end) {
        next.push({
          selected: null,
          pane: currentOptions
        });
      }
      return next;
    }, [
      innerValue,
      options2,
      innerOptions
    ]);
    var _usePropsValue1 = _sliced_to_array(usePropsValue({
      value: outerVisible,
      defaultValue: void 0,
      onChange: function(value3) {
        if (value3 === false) {
          var _props_onClose;
          (_props_onClose = props.onClose) === null || _props_onClose === void 0 ? void 0 : _props_onClose.call(props);
        }
      }
    }), 2), visible = _usePropsValue1[0], setVisible = _usePropsValue1[1];
    var actions = {
      open: function() {
        setVisible(true);
      },
      close: function() {
        setVisible(false);
      }
    };
    React.useImperativeHandle(ref, function() {
      return actions;
    });
    React.useEffect(function() {
      if (!visible) {
        setInnerValue(value2);
      }
    }, [
      visible,
      value2
    ]);
    React.useEffect(function() {
      setInnerOptions(outerOptions);
    }, [
      outerOptions
    ]);
    React.useEffect(function() {
      setTabActiveIndex(levels.length - 1);
    }, [
      innerValue,
      innerOptions,
      outerOptions
    ]);
    React.useEffect(function() {
      var max = levels.length - 1;
      if (tabActiveIndex > max) {
        setTabActiveIndex(max);
      }
    }, [
      tabActiveIndex,
      levels,
      innerOptions,
      outerOptions
    ]);
    React.useEffect(function() {
      var load = /* @__PURE__ */ function() {
        var _ref = _async_to_generator(function() {
          var parent2, error;
          return __generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                parent2 = {
                  children: []
                };
                _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  3,
                  ,
                  4
                ]);
                return [
                  4,
                  innerValue.reduce(/* @__PURE__ */ function() {
                    var _ref2 = _async_to_generator(function(promise, val2, key2) {
                      var pane, parent3, node;
                      return __generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            return [
                              4,
                              onLoad({
                                value: val2
                              }, key2)
                            ];
                          case 1:
                            pane = _state2.sent();
                            return [
                              4,
                              promise
                            ];
                          case 2:
                            parent3 = _state2.sent();
                            parent3.children = pane;
                            if (key2 === innerValue.length - 1) {
                              return [
                                2,
                                Promise.resolve(parent3)
                              ];
                            }
                            if (pane) {
                              node = pane.find(function(p2) {
                                return p2.value === val2;
                              });
                              return [
                                2,
                                Promise.resolve(node)
                              ];
                            }
                            return [
                              2
                            ];
                        }
                      });
                    });
                    return function(promise, val2, key2) {
                      return _ref2.apply(this, arguments);
                    };
                  }(), Promise.resolve(parent2))
                ];
              case 2:
                _state.sent();
                setInnerOptions(parent2.children);
                return [
                  3,
                  4
                ];
              case 3:
                error = _state.sent();
                console.error("Error loading data:", error);
                return [
                  3,
                  4
                ];
              case 4:
                return [
                  2
                ];
            }
          });
        });
        return function load2() {
          return _ref.apply(this, arguments);
        };
      }();
      if (lazy) load();
    }, [
      lazy
    ]);
    var chooseItem = /* @__PURE__ */ function() {
      var _ref = _async_to_generator(function(pane, levelIndex) {
        var nextValue, nextPathNodes, _props_onPathChange, asyncOptions;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (pane.disabled) return [
                2
              ];
              nextValue = innerValue.slice(0, levelIndex);
              nextPathNodes = pathNodes.current.slice(0, levelIndex);
              if (pane.value) {
                setLoading(!!onLoad && _define_property({}, levelIndex, pane.value));
                nextValue[levelIndex] = pane.value;
                nextPathNodes[levelIndex] = pane;
                pathNodes.current = nextPathNodes;
                props === null || props === void 0 ? void 0 : (_props_onPathChange = props.onPathChange) === null || _props_onPathChange === void 0 ? void 0 : _props_onPathChange.call(props, nextValue, pathNodes.current);
              }
              if (!onLoad) return [
                3,
                3
              ];
              if (!!pane.leaf) return [
                3,
                2
              ];
              return [
                4,
                onLoad(pane, levelIndex)
              ];
            case 1:
              asyncOptions = _state.sent();
              if (asyncOptions) pane.children = asyncOptions;
              return [
                3,
                3
              ];
            case 2:
              setVisible(false);
              setValue(nextValue);
              _state.label = 3;
            case 3:
              if (!pane.children && !onLoad) {
                setVisible(false);
                setValue(nextValue);
              }
              setInnerValue(nextValue);
              setLoading({});
              return [
                2
              ];
          }
        });
      });
      return function chooseItem2(pane, levelIndex) {
        return _ref.apply(this, arguments);
      };
    }();
    var renderCascaderItem = function(item, levelIndex) {
      var _item_pane;
      return (_item_pane = item.pane) === null || _item_pane === void 0 ? void 0 : _item_pane.map(function(pane, index2) {
        var active2 = item.selected === pane.value;
        var classes = classNames({
          active: active2,
          disabled: pane.disabled
        }, "nut-cascader-item");
        var showLoadingIcon = loading[levelIndex] === pane.value;
        return /* @__PURE__ */ React.createElement("div", {
          className: classes,
          style: {
            color: active2 ? activeColor : ""
          },
          key: pane.value,
          onClick: function() {
            chooseItem(pane, levelIndex);
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "nut-cascader-item-title"
        }, pane.text), showLoadingIcon && /* @__PURE__ */ React.createElement(s, {
          color: "#969799",
          className: "nut-cascader-item-icon-loading"
        }), active2 && (React.isValidElement(activeIcon) ? activeIcon : /* @__PURE__ */ React.createElement(d$6, {
          className: "".concat(classPrefix2, "-icon-check")
        })));
      });
    };
    var renderTab = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames(classPrefix2, props.className),
        style: props.style
      }, /* @__PURE__ */ React.createElement(Tabs, {
        value: tabActiveIndex,
        onChange: function(index2) {
          var _props_onTabsChange;
          (_props_onTabsChange = props.onTabsChange) === null || _props_onTabsChange === void 0 ? void 0 : _props_onTabsChange.call(props, Number(index2));
          setTabActiveIndex(Number(index2));
        }
      }, levels.map(function(pane, index2) {
        return /* @__PURE__ */ React.createElement(Tabs.TabPane, {
          title: pane.selectedText || locale.select,
          key: index2
        }, /* @__PURE__ */ React.createElement("div", {
          className: classPane
        }, renderCascaderItem(pane, index2)));
      })));
    };
    return popup ? /* @__PURE__ */ React.createElement(Popup, _object_spread_props(_object_spread({}, popupProps), {
      visible,
      position: "bottom",
      round: true,
      closeIcon,
      closeable,
      closeIconPosition,
      title: props.title,
      left: props.left,
      onOverlayClick: function() {
        return setVisible(false);
      },
      onCloseIconClick: function() {
        return setVisible(false);
      }
    }), renderTab()) : renderTab();
  });
  Cascader.displayName = "NutCascader";
  var defaultProps$1b = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    type: "cascader",
    options: [],
    optionKey: {
      textKey: "text",
      valueKey: "value",
      childrenKey: "children"
    },
    format: {},
    height: "200px"
  });
  var CascaderRender = function(props) {
    var _ref = _object_spread({}, defaultProps$1b, props);
    _ref.children;
    var visible = _ref.visible, type2 = _ref.type;
    _ref.height;
    var options2 = _ref.options, title = _ref.title, left = _ref.left, value2 = _ref.value, defaultValue = _ref.defaultValue, optionKey = _ref.optionKey, format2 = _ref.format, onClose = _ref.onClose, onChange = _ref.onChange, onPathChange = _ref.onPathChange, rest = _object_without_properties(_ref, [
      "children",
      "visible",
      "type",
      "height",
      "options",
      "title",
      "left",
      "value",
      "defaultValue",
      "optionKey",
      "format",
      "onClose",
      "onChange",
      "onPathChange"
    ]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, type2 === "cascader" && /* @__PURE__ */ React.createElement(Cascader, _object_spread({
      visible,
      value: value2,
      defaultValue,
      title,
      left,
      options: options2,
      format: format2,
      optionKey,
      onClose: function() {
        onClose === null || onClose === void 0 ? void 0 : onClose();
      },
      onChange: function(val2, params) {
        onChange === null || onChange === void 0 ? void 0 : onChange(val2, params);
      },
      onPathChange
    }, rest)));
  };
  var generateId = function(name2) {
    return name2.split("").reduce(function(sum2, char) {
      return sum2 + char.charCodeAt(0);
    }, 0);
  };
  var transformData = function(data2) {
    var groupByWordCode = function(data3, parentId, parentName) {
      return data3 === null || data3 === void 0 ? void 0 : data3.reduce(function(acc, item) {
        var wordCode = item.wordCode;
        if (!acc[wordCode]) {
          acc[wordCode] = [];
        }
        var currentId = generateId(item.value);
        acc[wordCode].push({
          name: item.value,
          wordCode: item.wordCode,
          id: currentId,
          pId: parentId,
          pName: parentName,
          children: item.children && groupByWordCode(item.children, currentId, item.text) || null
        });
        return acc;
      }, {});
    };
    var extractTitles = function(obj) {
      return Object.keys(obj).map(function(key2) {
        return {
          title: key2,
          list: obj[key2].map(function(item) {
            if (item.children) {
              item.children = extractTitles(item.children);
            }
            return item;
          })
        };
      });
    };
    var middleData = groupByWordCode(data2, "", "");
    var resultData = extractTitles(middleData);
    return resultData;
  };
  var findDataByName = function(data2, name2) {
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = data2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        var _item_name;
        if (((_item_name = item.name) === null || _item_name === void 0 ? void 0 : _item_name.indexOf(name2)) === 0) return item;
        if (item.children) {
          var found = findDataByName(item.children, name2);
          if (found) return found;
        }
        if (item.list) {
          var found1 = findDataByName(item.list, name2);
          if (found1) return found1;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return null;
  };
  var defaultProps$1a = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    type: "elevator",
    options: [],
    optionKey: {
      textKey: "text",
      valueKey: "value",
      childrenKey: "children"
    },
    format: {},
    height: "200px",
    activeColor: "",
    activeIcon: "checklist",
    popup: true,
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    lazy: false,
    hotList: [],
    onClose: function() {
    },
    onChange: function() {
    },
    onPathChange: function() {
    }
  });
  var ElevatorRender = function(props) {
    var _mergeProps = mergeProps(defaultProps$1a, props), hotList = _mergeProps.hotList, title = _mergeProps.title, left = _mergeProps.left, optionKey = _mergeProps.optionKey, format2 = _mergeProps.format, onClose = _mergeProps.onClose, onChange = _mergeProps.onChange, onPathChange = _mergeProps.onPathChange, popup = _mergeProps.popup, _mergeProps_popupProps = _mergeProps.popupProps, popupProps = _mergeProps_popupProps === void 0 ? {} : _mergeProps_popupProps, outerVisible = _mergeProps.visible, outerOptions = _mergeProps.options, outerValue = _mergeProps.value, outerDefaultValue = _mergeProps.defaultValue, closeable = _mergeProps.closeable, closeIconPosition = _mergeProps.closeIconPosition, closeIcon = _mergeProps.closeIcon;
    var _useConfig = useConfig(), _useConfig_locale = _useConfig.locale, select = _useConfig_locale.select, _useConfig_locale_address = _useConfig_locale.address, hotCity = _useConfig_locale_address.hotCity, selectProvince = _useConfig_locale_address.selectProvince;
    var classPrefix2 = "nut-address";
    var MAX_LENGTH = 10;
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: outerValue,
      defaultValue: outerDefaultValue,
      finalValue: [],
      onChange: function(value3) {
        onChange(value3, []);
        onPathChange(value3, []);
      }
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState(outerOptions), 2), innerOptions = _useState[0], setInnerOptions = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(value2), 2), innerValue = _useState1[0], setInnerValue = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState([]), 2), elevatorOptions = _useState2[0], setElevatorOptions = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(selectProvince), 2), addressTip = _useState3[0], setAddressTip = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState(0), 2), levelIndex = _useState4[0], setLevelIndex = _useState4[1];
    var _useState5 = _sliced_to_array(React.useState(0), 2), tabActiveIndex = _useState5[0], setTabActiveIndex = _useState5[1];
    var options2 = React.useMemo(function() {
      if (!isEmpty(format2)) {
        return transformData(normalizeListOptions(innerOptions, format2));
      }
      if (!isEmpty(optionKey)) {
        return transformData(normalizeOptions(innerOptions, optionKey) || []);
      }
      return transformData(innerOptions);
    }, [
      innerOptions,
      optionKey,
      format2
    ]);
    React.useEffect(function() {
      setElevatorOptions(options2);
    }, [
      options2
    ]);
    var levels = React.useMemo(function() {
      var next = [];
      var end = false;
      var currentOptions = options2;
      innerValue.forEach(function(val2, index2) {
        var opt = currentOptions === null || currentOptions === void 0 ? void 0 : currentOptions.flatMap(function(o) {
          return o.list.find(function(item) {
            return item.name === val2;
          });
        }).filter(function(item) {
          return item !== void 0;
        })[0];
        next.push({
          name: val2,
          children: currentOptions,
          levelIndex: index2,
          current: index2 === tabActiveIndex
        });
        if (opt === null || opt === void 0 ? void 0 : opt.children) {
          currentOptions = opt.children;
        } else {
          end = true;
        }
      });
      if (!end) {
        next.push({
          name: null,
          children: currentOptions,
          levels: -1,
          current: false
        });
      }
      return next;
    }, [
      innerValue,
      options2,
      tabActiveIndex
    ]);
    var _usePropsValue1 = _sliced_to_array(usePropsValue({
      value: outerVisible,
      defaultValue: void 0,
      onChange: function(value3) {
        if (value3 === false) onClose();
      }
    }), 2), visible = _usePropsValue1[0], setVisible = _usePropsValue1[1];
    React.useEffect(function() {
      if (!visible) setInnerValue(value2);
    }, [
      visible,
      value2
    ]);
    React.useEffect(function() {
      setInnerOptions(outerOptions);
    }, [
      outerOptions
    ]);
    React.useEffect(function() {
      setTabActiveIndex(levels.length - 1);
      setAddressTip(innerValue.length ? select : selectProvince);
    }, [
      innerValue
    ]);
    var handleElevatorItemClick = function(elevatorItem, levelIndex2) {
      var _elevatorItem_children;
      var nextValue = innerValue.slice(0, levelIndex2);
      if (elevatorItem.name) {
        nextValue[levelIndex2] = elevatorItem.name;
      }
      setInnerValue(nextValue);
      if ((_elevatorItem_children = elevatorItem.children) === null || _elevatorItem_children === void 0 ? void 0 : _elevatorItem_children.length) {
        setElevatorOptions(elevatorItem.children);
        setLevelIndex(levelIndex2 + 1);
      } else {
        setVisible(false);
        setValue(nextValue);
      }
    };
    var handleHotItemClick = function(hotItem) {
      var distData = findDataByName(options2, hotItem.name);
      if (distData) {
        var nextValue = [
          distData.pName,
          distData.name
        ].filter(function(item) {
          return item !== "";
        });
        setInnerValue(nextValue);
        setElevatorOptions(distData.children);
        setLevelIndex(nextValue.length);
      }
    };
    var renderTabs = function() {
      if (!levels.length || !levels[0].name) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-selected")
      }, levels.map(function(item, index2) {
        var _levels_;
        return /* @__PURE__ */ React.createElement(React.Fragment, {
          key: "adtabs-".concat(index2)
        }, item.name && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-selected-item ").concat(item.current ? "active" : ""),
          onClick: function() {
            var _props_onTabsChange;
            (_props_onTabsChange = props.onTabsChange) === null || _props_onTabsChange === void 0 ? void 0 : _props_onTabsChange.call(props, index2);
            setTabActiveIndex(index2);
            setLevelIndex(index2);
            setElevatorOptions(item.children);
          }
        }, item.name), ((_levels_ = levels[index2 + 1]) === null || _levels_ === void 0 ? void 0 : _levels_.name) && /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-selected-border")
        }, "-"));
      }));
    };
    var renderHotCity = function() {
      if (levels.length && tabActiveIndex !== 0) return null;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-title")
      }, hotCity), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-hotlist ").concat(hotList.length > MAX_LENGTH ? "hotlist-more" : "")
      }, hotList.map(function(item, index2) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-hotlist-item"),
          key: "hot-".concat(index2),
          onClick: function() {
            return handleHotItemClick(item);
          }
        }, item.name);
      })));
    };
    var renderArea = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-title")
      }, addressTip), /* @__PURE__ */ React.createElement(Elevator, {
        className: "".concat(classPrefix2, "-elevator"),
        list: elevatorOptions,
        onItemClick: function(key2, item) {
          return handleElevatorItemClick(item, levelIndex);
        },
        style: {
          height: "100%"
        },
        height: "93%"
      }));
    };
    var renderContent = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderTabs(), /* @__PURE__ */ React.createElement("div", {
        style: {
          height: innerValue.length ? "80%" : "93%",
          overflowY: levels.length && tabActiveIndex !== 0 ? "hidden" : "auto"
        }
      }, renderHotCity(), renderArea()));
    };
    return popup ? /* @__PURE__ */ React.createElement(Popup, _object_spread_props(_object_spread({}, popupProps), {
      visible,
      position: "bottom",
      style: {
        height: "89%"
      },
      round: true,
      closeIcon,
      closeable,
      closeIconPosition,
      title,
      left,
      onOverlayClick: function() {
        return setVisible(false);
      },
      onCloseIconClick: function() {
        return setVisible(false);
      }
    }), renderContent()) : renderContent();
  };
  ElevatorRender.displayName = "NutElevatorRender";
  var defaultProps$19 = {
    type: "exist",
    existList: [],
    defaultIcon: null,
    selectIcon: null,
    custom: false
  };
  var ExistRender = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$19, props);
    _ref.children;
    var type2 = _ref.type, existList = _ref.existList, selectIcon = _ref.selectIcon, defaultIcon = _ref.defaultIcon, custom = _ref.custom, onSelect = _ref.onSelect, onSwitch = _ref.onSwitch;
    _object_without_properties(_ref, [
      "children",
      "type",
      "existList",
      "selectIcon",
      "defaultIcon",
      "custom",
      "onSelect",
      "onSwitch"
    ]);
    var classPrefix2 = "nut-address";
    var selectedExist = function(item) {
      existList.forEach(function(list, index2) {
        list.selectedAddress = false;
      });
      item.selectedAddress = true;
      onSelect && onSelect(item);
    };
    var onClick = function(e2) {
      e2.stopPropagation();
      onSwitch && onSwitch({
        type: type2 === "exist" ? "cascader" : "exist"
      });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("ul", {
      className: "".concat(classPrefix2, "-exist")
    }, existList.map(function(item, index2) {
      return /* @__PURE__ */ React.createElement("li", {
        className: "".concat(classPrefix2, "-exist-item ").concat(item.selectedAddress ? "active" : ""),
        key: index2,
        onClick: function(e2) {
          e2.stopPropagation();
          selectedExist(item);
        }
      }, item.selectedAddress ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.isValidElement(selectIcon) ? selectIcon : /* @__PURE__ */ React.createElement(d$6, {
        color: "var(--nutui-color-primary)"
      })) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.isValidElement(defaultIcon) ? defaultIcon : /* @__PURE__ */ React.createElement(m$3, null)), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-exist-item-info")
      }, item.name && item.phone && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", null, item.name), /* @__PURE__ */ React.createElement("div", null, item.phone)), /* @__PURE__ */ React.createElement("div", null, item.provinceName + item.cityName + item.countyName + item.townName + item.addressDetail)));
    })), (custom || custom && locale.address.chooseAnotherAddress) && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-footer"),
      onClick
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-footer-btn")
    }, custom)));
  };
  var defaultProps$18 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    defaultValue: [],
    type: "cascader",
    options: [],
    optionKey: {
      textKey: "text",
      valueKey: "value",
      childrenKey: "children"
    },
    format: {},
    custom: false,
    existList: [],
    hotList: [],
    height: "200px",
    defaultIcon: null,
    selectIcon: null,
    closeIcon: null,
    backIcon: null
  });
  var InternalAddress = function(props, ref) {
    var locale = useConfig().locale;
    var _mergeProps = mergeProps(defaultProps$18, props), style = _mergeProps.style, className = _mergeProps.className, visible = _mergeProps.visible, defaultVisible = _mergeProps.defaultVisible, defaultValue = _mergeProps.defaultValue;
    _mergeProps.children;
    var type2 = _mergeProps.type, options2 = _mergeProps.options, optionKey = _mergeProps.optionKey, format2 = _mergeProps.format, height2 = _mergeProps.height, title = _mergeProps.title, existList = _mergeProps.existList, custom = _mergeProps.custom, selectIcon = _mergeProps.selectIcon, defaultIcon = _mergeProps.defaultIcon, closeIcon = _mergeProps.closeIcon, backIcon = _mergeProps.backIcon, hotList = _mergeProps.hotList, onChange = _mergeProps.onChange, onExistSelect = _mergeProps.onExistSelect, onClose = _mergeProps.onClose, onSwitch = _mergeProps.onSwitch;
    _object_without_properties(_mergeProps, [
      "style",
      "className",
      "visible",
      "defaultVisible",
      "defaultValue",
      "children",
      "type",
      "options",
      "optionKey",
      "format",
      "height",
      "title",
      "existList",
      "custom",
      "selectIcon",
      "defaultIcon",
      "closeIcon",
      "backIcon",
      "hotList",
      "onChange",
      "onExistSelect",
      "onClose",
      "onSwitch"
    ]);
    var classPrefix2 = "nut-address";
    var _useState = _sliced_to_array(React.useState(type2), 2), currentType = _useState[0], setCurrentType = _useState[1];
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: visible,
      defaultValue: defaultVisible,
      finalValue: defaultVisible
    }), 2), innerVisible = _usePropsValue[0], setInnerVisible = _usePropsValue[1];
    React.useImperativeHandle(ref, function() {
      return {
        open: function open() {
          setInnerVisible(true);
        },
        close: function close() {
          setInnerVisible(false);
        }
      };
    });
    var handleClose = function() {
      setInnerVisible(false);
      onClose && onClose();
    };
    var renderLeftOnCascaderSwitch = function() {
      if (!custom) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-left-icon"),
        onClick: onSwitchModule
      }, /* @__PURE__ */ React.isValidElement(backIcon) ? backIcon : /* @__PURE__ */ React.createElement(d$7, {
        color: "#cccccc"
      }));
    };
    var selectedExistItem = function(data2) {
      onExistSelect && onExistSelect(data2);
      handleClose();
    };
    var onSwitchModule = function() {
      var nextType = currentType === "exist" ? "cascader" : "exist";
      setCurrentType(nextType);
      onSwitch && onSwitch({
        type: nextType
      });
    };
    var renderElevator = function() {
      return /* @__PURE__ */ React.createElement(ElevatorRender, {
        visible: innerVisible,
        closeable: true,
        title: title || locale.address.selectRegion,
        left: backIcon,
        defaultValue,
        closeIcon,
        options: options2,
        hotList,
        format: format2,
        optionKey,
        type: currentType,
        height: height2,
        onClose: handleClose,
        onChange: function(val2, params) {
          onChange === null || onChange === void 0 ? void 0 : onChange(val2, params);
        }
      });
    };
    var renderCascator = function() {
      return /* @__PURE__ */ React.createElement(CascaderRender, {
        visible: innerVisible,
        closeable: true,
        title: title || locale.address.selectRegion,
        left: renderLeftOnCascaderSwitch(),
        defaultValue,
        closeIcon,
        options: options2,
        format: format2,
        optionKey,
        type: currentType,
        height: height2,
        onClose: handleClose,
        onChange: function(val2, params) {
          onChange && onChange(val2, params);
        }
      });
    };
    var renderExist = function() {
      return /* @__PURE__ */ React.createElement(Popup, {
        visible: innerVisible,
        position: "bottom",
        round: true,
        closeable: true,
        closeIcon,
        title: title || locale.address.selectRegion,
        onClose: handleClose
      }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "".concat(classPrefix2, " ").concat(className || ""),
          style: _object_spread({}, style)
        },
        //  close
        /* @__PURE__ */ React.createElement(ExistRender, {
          type: currentType,
          existList,
          selectIcon,
          defaultIcon,
          custom,
          onSelect: selectedExistItem,
          onSwitch: onSwitchModule
        })
      ));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, currentType === "elevator" ? renderElevator() : null, currentType === "cascader" ? renderCascator() : null, currentType === "exist" ? renderExist() : null);
  };
  var Address = /* @__PURE__ */ React.forwardRef(InternalAddress);
  Address.displayName = "NutAddress";
  var splitDate = function(date2) {
    var split = date2.indexOf("-") !== -1 ? "-" : "/";
    return date2.split(split);
  };
  var isMultiple = function(day, days) {
    if (days.length > 0) {
      return days.some(function(item) {
        return Utils.isEqual(item, day);
      });
    }
    return false;
  };
  var isCurrDay = function(month, day) {
    var date2 = "".concat(month.curData[0], "/").concat(month.curData[1], "/").concat(day);
    return Utils.isEqual(date2, Utils.date2Str(/* @__PURE__ */ new Date(), "/"));
  };
  var getCurrDate = function(day, month) {
    return "".concat(month.curData[0], "/").concat(month.curData[1], "/").concat(Utils.getNumTwoBit(+day.day));
  };
  var isStart = function(day, days) {
    return Utils.isEqual(days[0], day);
  };
  var isEnd = function(day, days) {
    return Utils.isEqual(days[1], day);
  };
  var isStartAndEnd = function(days) {
    return days.length >= 2 && Utils.isEqual(days[0], days[1]);
  };
  var defaultProps$17 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "single",
    autoBackfill: false,
    popup: true,
    title: "",
    startDate: Utils.getDay(0),
    endDate: Utils.getDay(365),
    showToday: true,
    startText: "",
    endText: "",
    confirmText: "",
    showTitle: true,
    showSubTitle: true,
    scrollAnimation: true,
    firstDayOfWeek: 0,
    disableDate: function(date2) {
      return false;
    },
    renderHeaderButtons: void 0,
    renderDay: void 0,
    renderDayTop: void 0,
    renderDayBottom: void 0,
    onConfirm: function(data2) {
    },
    onUpdate: function() {
    },
    onDayClick: function(data2) {
    },
    onPageChange: function(data2) {
    }
  });
  var CalendarItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var locale = useConfig().locale;
    var _$_object_spread = _object_spread({}, defaultProps$17, props), style = _$_object_spread.style, className = _$_object_spread.className, children = _$_object_spread.children, popup = _$_object_spread.popup, type2 = _$_object_spread.type, autoBackfill = _$_object_spread.autoBackfill, title = _$_object_spread.title, defaultValue = _$_object_spread.defaultValue, startDate = _$_object_spread.startDate, endDate = _$_object_spread.endDate, showToday = _$_object_spread.showToday, startText = _$_object_spread.startText, endText = _$_object_spread.endText, confirmText = _$_object_spread.confirmText, showTitle = _$_object_spread.showTitle, showSubTitle = _$_object_spread.showSubTitle, scrollAnimation = _$_object_spread.scrollAnimation, firstDayOfWeek = _$_object_spread.firstDayOfWeek, disableDate = _$_object_spread.disableDate, renderHeaderButtons = _$_object_spread.renderHeaderButtons, renderBottomButton = _$_object_spread.renderBottomButton, renderDay = _$_object_spread.renderDay, renderDayTop = _$_object_spread.renderDayTop, renderDayBottom = _$_object_spread.renderDayBottom, value2 = _$_object_spread.value, onConfirm = _$_object_spread.onConfirm, onUpdate = _$_object_spread.onUpdate, onDayClick = _$_object_spread.onDayClick, onPageChange = _$_object_spread.onPageChange;
    var weekdays = locale.calendaritem.weekdays;
    var weeks = _to_consumable_array(weekdays.slice(firstDayOfWeek, 7)).concat(_to_consumable_array(weekdays.slice(0, firstDayOfWeek)));
    var monthTitle = locale.calendaritem.monthTitle;
    var _useState = _sliced_to_array(React.useState(""), 2), yearMonthTitle = _useState[0], setYearMonthTitle = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), monthsData = _useState1[0], setMonthsData = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(0), 2), monthsNum = _useState2[0], setMonthsNum = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(0), 2), translateY = _useState3[0], setTranslateY = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState([]), 2), monthDefaultRange = _useState4[0], setMonthDefaultRange = _useState4[1];
    var propStartDate = startDate || Utils.getDay(0);
    var propEndDate = endDate || Utils.getDay(365);
    var startDates = splitDate(propStartDate);
    var endDates = splitDate(propEndDate);
    var _useState5 = _sliced_to_array(React.useState({
      currDateArray: []
    }), 1), state = _useState5[0];
    var getMonthsPanel = function() {
      return monthsPanel.current;
    };
    var getMonthsRef = function() {
      return monthsRef.current;
    };
    var resetDefaultValue = function() {
      if (defaultValue || Array.isArray(defaultValue) && defaultValue.length > 0) {
        return type2 !== "single" ? _to_consumable_array(defaultValue) : defaultValue;
      }
      return void 0;
    };
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue: resetDefaultValue(),
      finalValue: [],
      onChange: function(val2) {
      }
    }), 2), currentDate = _usePropsValue[0], setCurrentDate = _usePropsValue[1];
    var weeksPanel = React.useRef(null);
    var monthsRef = React.useRef(null);
    var monthsPanel = React.useRef(null);
    var viewAreaRef = React.useRef(null);
    var _useState6 = _sliced_to_array(React.useState(0), 2), avgHeight = _useState6[0], setAvgHeight = _useState6[1];
    var viewHeight = 0;
    var classPrefix2 = "nut-calendar";
    var dayPrefix = "nut-calendar-day";
    var getMonthData = function(curData, monthNum, type3) {
      var i2 = 0;
      var date2 = curData;
      var monthData = monthsData;
      do {
        var y = parseInt(date2[0], 10);
        var m2 = parseInt(date2[1], 10);
        var days = _to_consumable_array(getPreMonthDates("prev", y, m2, firstDayOfWeek)).concat(_to_consumable_array(getDaysStatus("active", y, m2)));
        var cssHeight = 39 + (days.length > 35 ? 384 : 320);
        var scrollTop = 0;
        if (monthData.length > 0) {
          var monthEle = monthData[monthData.length - 1];
          scrollTop = monthEle.scrollTop + monthEle.cssHeight;
        }
        var monthInfo = {
          curData: date2,
          title: monthTitle(y, m2),
          monthData: days,
          cssHeight,
          scrollTop
        };
        {
          if (!endDates || !Utils.compareDate("".concat(endDates[0], "/").concat(endDates[1], "/").concat(Utils.getMonthDays(endDates[0], endDates[1])), "".concat(curData[0], "/").concat(curData[1], "/").concat(curData[2]))) {
            monthData.push(monthInfo);
          }
        }
        date2 = getCurrMonthData("next", y, m2);
      } while (i2++ < monthNum);
      setMonthsData(monthData);
    };
    var setReachedYearMonthInfo = function(current) {
      var currentMonthsData = monthsData[current];
      var _currentMonthsData_curData = _sliced_to_array(currentMonthsData.curData, 2), year = _currentMonthsData_curData[0], month = _currentMonthsData_curData[1];
      if (currentMonthsData.title === yearMonthTitle) return;
      onPageChange && onPageChange([
        year,
        month,
        "".concat(year, "-").concat(month)
      ]);
      setYearMonthTitle(currentMonthsData.title);
    };
    var setDefaultRange = function(monthNum, current) {
      var start2 = 0;
      var end = 0;
      if (monthNum >= 3) {
        if (current > 0 && current < monthNum) {
          start2 = current - 1;
          end = current + 3;
        } else if (current === 0) {
          start2 = current;
          end = current + 4;
        } else if (current === monthNum) {
          start2 = current - 2;
          end = current + 2;
        }
      } else {
        start2 = 0;
        end = monthNum + 2;
      }
      setMonthDefaultRange([
        start2,
        end
      ]);
      setTranslateY(monthsData[start2].scrollTop);
      setReachedYearMonthInfo(current);
    };
    var getMonthNum = function() {
      var monthNum = Number(endDates[1]) - Number(startDates[1]);
      var yearNum = Number(endDates[0]) - Number(startDates[0]);
      if (yearNum > 0) {
        monthNum += 12 * yearNum;
      }
      if (monthNum <= 0) {
        monthNum = 1;
      }
      setMonthsNum(monthNum);
      return monthNum;
    };
    var setDefaultDate = function() {
      var defaultData = [];
      if (type2 === "range" && Array.isArray(currentDate)) {
        if (currentDate.length > 0) {
          if (propStartDate && Utils.compareDate(currentDate[0], propStartDate)) {
            currentDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, currentDate[1])) {
            currentDate.splice(1, 1, propEndDate);
          }
          defaultData = _to_consumable_array(splitDate(currentDate[0])).concat(_to_consumable_array(splitDate(currentDate[1])));
        }
      } else if (type2 === "multiple" && Array.isArray(currentDate)) {
        if (currentDate.length > 0) {
          var _currentDate;
          var defaultArr = [];
          var obj = {};
          currentDate.forEach(function(item) {
            if (propStartDate && !Utils.compareDate(item, propStartDate) && propEndDate && !Utils.compareDate(propEndDate, item)) {
              if (!Object.hasOwnProperty.call(obj, item)) {
                defaultArr.push(item);
                obj[item] = item;
              }
            }
          });
          currentDate.splice(0) && (_currentDate = currentDate).push.apply(_currentDate, _to_consumable_array(defaultArr));
          defaultData = _to_consumable_array(splitDate(defaultArr[0]));
        }
      } else if (type2 === "week" && Array.isArray(currentDate)) {
        if (currentDate.length > 0) {
          var _currentDate1;
          var _splitDate = _sliced_to_array(splitDate(currentDate[0]), 3), y = _splitDate[0], m2 = _splitDate[1], d2 = _splitDate[2];
          var weekArr = Utils.getWeekDate(y, m2, d2, firstDayOfWeek);
          currentDate.splice(0) && (_currentDate1 = currentDate).push.apply(_currentDate1, _to_consumable_array(weekArr));
          if (propStartDate && Utils.compareDate(currentDate[0], propStartDate)) {
            currentDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, currentDate[1])) {
            currentDate.splice(1, 1, propEndDate);
          }
          defaultData = _to_consumable_array(splitDate(currentDate[0])).concat(_to_consumable_array(splitDate(currentDate[1])));
        }
      } else if (currentDate) {
        if (currentDate.length > 0) {
          if (propStartDate && Utils.compareDate(currentDate, propStartDate)) {
            defaultData = _to_consumable_array(splitDate(propStartDate));
          } else if (propEndDate && !Utils.compareDate(currentDate, propEndDate)) {
            defaultData = _to_consumable_array(splitDate(propEndDate));
          } else {
            defaultData = _to_consumable_array(splitDate(currentDate));
          }
        } else {
          defaultData = [];
        }
      }
      return defaultData;
    };
    var getCurrentIndex = function(defaultData) {
      var current = 0;
      var lastCurrent = 0;
      if (defaultData.length > 0) {
        monthsData.forEach(function(item, index3) {
          if (item.title === monthTitle(defaultData[0], defaultData[1])) {
            current = index3;
          }
          if (type2 === "range" || type2 === "week") {
            if (item.title === monthTitle(defaultData[3], defaultData[4])) {
              lastCurrent = index3;
            }
          }
        });
      } else {
        var date2 = /* @__PURE__ */ new Date();
        var year = date2.getFullYear();
        var month = date2.getMonth() + 1;
        var index2 = monthsData.findIndex(function(item) {
          return +item.curData[0] === year && +item.curData[1] === month;
        });
        if (index2 > -1) {
          current = index2;
        }
      }
      return {
        current,
        lastCurrent
      };
    };
    var renderCurrentDate = function() {
      var defaultData = setDefaultDate();
      var current = getCurrentIndex(defaultData);
      if (defaultData.length > 0) {
        if (type2 === "range") {
          chooseDay({
            day: defaultData[2],
            type: "active"
          }, monthsData[current.current], true);
          chooseDay({
            day: defaultData[5],
            type: "active"
          }, monthsData[current.lastCurrent], true);
        } else if (type2 === "week") {
          chooseDay({
            day: defaultData[2],
            type: "curr"
          }, monthsData[current.current], true);
        } else if (type2 === "multiple") {
          _to_consumable_array(currentDate).forEach(function(item) {
            var dateArr = splitDate(item);
            var currentIndex = current.current;
            monthsData.forEach(function(item2, index2) {
              if (item2.title === monthTitle(dateArr[0], dateArr[1])) {
                currentIndex = index2;
              }
            });
            chooseDay({
              day: dateArr[2],
              type: "active"
            }, monthsData[currentIndex], true);
          });
        } else {
          chooseDay({
            day: defaultData[2],
            type: "active"
          }, monthsData[current.current], true);
        }
      }
      return current.current;
    };
    var requestAniFrameFunc = function(current, monthNum) {
      var lastItem = monthsData[monthsData.length - 1];
      var containerHeight = lastItem.cssHeight + lastItem.scrollTop;
      requestAniFrame$1(function() {
        if (monthsRef && monthsPanel && viewAreaRef) {
          viewHeight = getMonthsRef().clientHeight;
          getMonthsPanel().style.height = "".concat(containerHeight, "px");
          getMonthsRef().scrollTop = monthsData[current].scrollTop;
        }
      });
      setAvgHeight(Math.floor(containerHeight / (monthNum + 1)));
    };
    var initData = function() {
      var monthNum = getMonthNum();
      getMonthData(startDates, monthNum);
      var current = renderCurrentDate();
      setDefaultRange(monthNum, current);
      requestAniFrameFunc(current, monthNum);
    };
    React.useEffect(function() {
      initData();
    }, []);
    var resetRender = function() {
      state.currDateArray.splice(0);
      monthsData.splice(0);
      initData();
    };
    React.useEffect(function() {
      setCurrentDate(resetDefaultValue() || []);
    }, [
      defaultValue
    ]);
    React.useEffect(function() {
      popup && resetRender();
    }, [
      currentDate
    ]);
    var scrollToDate = function(date2) {
      if (Utils.compareDate(date2, propStartDate)) {
        date2 = propStartDate;
      } else if (!Utils.compareDate(date2, propEndDate)) {
        date2 = propEndDate;
      }
      var dateArr = splitDate(date2);
      monthsData.forEach(function(item, index2) {
        if (item.title === monthTitle(dateArr[0], dateArr[1])) {
          var currTop = monthsData[index2].scrollTop;
          if (monthsRef.current) {
            var distance = currTop - monthsRef.current.scrollTop;
            if (scrollAnimation) {
              var flag = 0;
              var interval = setInterval(function() {
                flag++;
                if (monthsRef.current) {
                  var offset = distance / 10;
                  monthsRef.current.scrollTop += offset;
                }
                if (flag >= 10) {
                  clearInterval(interval);
                  if (monthsRef.current) {
                    monthsRef.current.scrollTop = currTop;
                  }
                }
              }, 40);
            } else {
              monthsRef.current.scrollTop = currTop;
            }
          }
        }
      });
    };
    var monthsViewScroll = function(e2) {
      if (monthsData.length <= 1) {
        return;
      }
      var scrollTop = e2.target.scrollTop;
      var current = Math.floor(scrollTop / avgHeight);
      if (current < 0) return;
      if (!monthsData[current + 1]) return;
      var nextTop = monthsData[current + 1].scrollTop;
      var nextHeight = monthsData[current + 1].cssHeight;
      if (current === 0) {
        if (scrollTop >= nextTop) {
          current += 1;
        }
      } else if (current > 0 && current < monthsNum - 1) {
        if (scrollTop >= nextTop) {
          current += 1;
        }
        if (scrollTop < monthsData[current].scrollTop) {
          current -= 1;
        }
      } else {
        var viewPosition = Math.round(scrollTop + viewHeight);
        if (current + 1 <= monthsNum && viewPosition >= nextTop + nextHeight) {
          current += 1;
        }
        if (current >= 1 && scrollTop < monthsData[current - 1].scrollTop) {
          current -= 1;
        }
      }
      setDefaultRange(monthsNum, current);
    };
    React.useImperativeHandle(ref, function() {
      return {
        scrollToDate
      };
    });
    var getClasses = function(day, month) {
      var dateStr = getCurrDate(day, month);
      if (day.type === "active") {
        if (propStartDate && Utils.compareDate(dateStr, propStartDate) || propEndDate && Utils.compareDate(propEndDate, dateStr)) {
          return "".concat(dayPrefix, "-disabled");
        }
        if (type2 === "range" || type2 === "week") {
          if (isStart(dateStr, currentDate) || isEnd(dateStr, currentDate)) {
            return "".concat(dayPrefix, "-active ").concat(isStart(dateStr, currentDate) ? "active-start" : "", " ").concat(isEnd(dateStr, currentDate) ? "active-end" : "");
          }
          if (Array.isArray(currentDate) && Object.values(currentDate).length === 2 && Utils.compareDate(currentDate[0], dateStr) && Utils.compareDate(dateStr, currentDate[1])) {
            if (disableDate(day)) {
              return "".concat(dayPrefix, "-choose-disabled");
            }
            return "".concat(dayPrefix, "-choose");
          }
        } else if (type2 === "multiple" && isMultiple(dateStr, currentDate) || !Array.isArray(currentDate) && Utils.isEqual(currentDate, dateStr)) {
          return "".concat(dayPrefix, "-active");
        }
        if (disableDate(day)) {
          return "".concat(dayPrefix, "-disabled");
        }
        return null;
      }
      return "".concat(dayPrefix, "-disabled");
    };
    var chooseDay = function(day, month, isFirst) {
      if (getClasses(day, month) === "".concat(dayPrefix, "-disabled")) {
        return;
      }
      var days = _to_consumable_array(month.curData);
      var _month_curData = _sliced_to_array(month.curData, 2), y = _month_curData[0], m2 = _month_curData[1];
      days[2] = typeof day.day === "number" ? Utils.getNumTwoBit(day.day) : day.day;
      days[3] = "".concat(days[0], "/").concat(days[1], "/").concat(days[2]);
      days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
      if (type2 === "multiple") {
        if (currentDate.length > 0) {
          var hasIndex = "";
          currentDate.forEach(function(item, index2) {
            if (item === days[3]) {
              hasIndex = index2;
            }
          });
          if (isFirst) {
            state.currDateArray.push(_to_consumable_array(days));
          } else if (hasIndex !== "") {
            currentDate.splice(hasIndex, 1);
            state.currDateArray.splice(hasIndex, 1);
          } else {
            currentDate.push(days[3]);
            state.currDateArray.push(_to_consumable_array(days));
          }
        } else {
          currentDate.push(days[3]);
          state.currDateArray = [
            _to_consumable_array(days)
          ];
        }
      } else if (type2 === "range") {
        var curDataLength = Object.values(currentDate).length;
        if (curDataLength === 2 || curDataLength === 0) {
          Array.isArray(currentDate) && currentDate.splice(0) && currentDate.push(days[3]);
          state.currDateArray = [
            _to_consumable_array(days)
          ];
        } else if (Utils.compareDate(currentDate[0], days[3])) {
          Array.isArray(currentDate) && currentDate.push(days[3]);
          state.currDateArray = _to_consumable_array(state.currDateArray).concat([
            _to_consumable_array(days)
          ]);
        } else {
          Array.isArray(currentDate) && currentDate.unshift(days[3]);
          state.currDateArray = [
            _to_consumable_array(days)
          ].concat(_to_consumable_array(state.currDateArray));
        }
      } else if (type2 === "week") {
        var _currentDate;
        var weekArr = Utils.getWeekDate(y, m2, "".concat(day.day), firstDayOfWeek);
        if (propStartDate && Utils.compareDate(weekArr[0], propStartDate)) {
          weekArr.splice(0, 1, propStartDate);
        }
        if (propEndDate && Utils.compareDate(propEndDate, weekArr[1])) {
          weekArr.splice(1, 1, propEndDate);
        }
        Array.isArray(currentDate) && currentDate.splice(0) && (_currentDate = currentDate).push.apply(_currentDate, _to_consumable_array(weekArr));
        state.currDateArray = [
          Utils.formatResultDate(weekArr[0]),
          Utils.formatResultDate(weekArr[1])
        ];
      } else {
        setCurrentDate(days[3]);
        state.currDateArray = _to_consumable_array(days);
      }
      if (!isFirst) {
        onDayClick && onDayClick(state.currDateArray);
        if (autoBackfill || !popup) {
          confirm2();
        }
      }
      setMonthsData(monthsData.slice());
    };
    var confirm2 = function() {
      if (type2 === "range" && state.currDateArray.length === 2 || type2 !== "range") {
        var chooseData = state.currDateArray.slice(0);
        onConfirm && onConfirm(chooseData);
        if (popup) {
          onUpdate && onUpdate();
        }
      }
    };
    var _obj;
    var classes = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-title"), !popup), _define_property(_obj, "".concat(classPrefix2, "-nofooter"), !!autoBackfill), _obj), classPrefix2, className);
    var _obj1;
    var headerClasses = classNames((_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-header"), true), _define_property(_obj1, "".concat(classPrefix2, "-header-title"), !popup), _obj1));
    var isStartTip = function(day, month) {
      return (type2 === "range" || type2 === "week") && day.type === "active" && isStart(getCurrDate(day, month), currentDate);
    };
    var isEndTip = function(day, month) {
      return currentDate.length >= 2 && (type2 === "range" || type2 === "week") && day.type === "active" && isEnd(getCurrDate(day, month), currentDate);
    };
    var renderHeader = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: headerClasses
      }, showTitle && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-title")
      }, title || locale.calendaritem.title), renderHeaderButtons && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-header-buttons")
      }, renderHeaderButtons()), showSubTitle && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-sub-title")
      }, yearMonthTitle), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-weeks"),
        ref: weeksPanel
      }, weeks.map(function(item) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-week-item"),
          key: item
        }, item);
      })));
    };
    var renderContent = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-content"),
        onScroll: monthsViewScroll,
        ref: monthsRef
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-pannel"),
        ref: monthsPanel
      }, /* @__PURE__ */ React.createElement("div", {
        className: "viewArea",
        ref: viewAreaRef,
        style: {
          transform: "translateY(".concat(translateY, "px)")
        }
      }, monthsData.slice(monthDefaultRange[0], monthDefaultRange[1]).map(function(month, key2) {
        return /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-month"),
          key: key2
        }, /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-month-title")
        }, month.title), /* @__PURE__ */ React.createElement("div", {
          className: "".concat(classPrefix2, "-days")
        }, month.monthData.map(function(day, i2) {
          return /* @__PURE__ */ React.createElement("div", {
            className: [
              "".concat(classPrefix2, "-day"),
              getClasses(day, month)
            ].join(" "),
            onClick: function() {
              chooseDay(day, month);
            },
            key: i2
          }, /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-day")
          }, renderDay ? renderDay(day) : day.day), !isStartTip(day, month) && renderDayTop && /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-info-top")
          }, renderDayTop(day)), !isStartTip(day, month) && !isEndTip(day, month) && renderDayBottom && /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-info-bottom")
          }, renderDayBottom(day)), !isStartTip(day, month) && !isEndTip(day, month) && !renderDayBottom && showToday && isCurrDay(month, day.day) && /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-info-curr")
          }, locale.calendaritem.today), isStartTip(day, month) && /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-info ").concat(isStartAndEnd(currentDate) ? "".concat(classPrefix2, "-day-info-top") : "")
          }, startText || locale.calendaritem.start), isEndTip(day, month) && /* @__PURE__ */ React.createElement("div", {
            className: "".concat(classPrefix2, "-day-info")
          }, endText || locale.calendaritem.end));
        })));
      }))));
    };
    var renderFooter = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "nut-calendar-footer"
      }, children, /* @__PURE__ */ React.createElement("div", {
        onClick: confirm2
      }, renderBottomButton ? renderBottomButton() : /* @__PURE__ */ React.createElement("div", {
        className: "calendar-confirm-btn"
      }, confirmText || locale.confirm)));
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: classes,
      style
    }, renderHeader(), renderContent(), popup && !autoBackfill ? renderFooter() : "");
  });
  CalendarItem.displayName = "NutCalendarItem";
  var defaultProps$16 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "single",
    autoBackfill: false,
    popup: true,
    visible: false,
    title: "",
    defaultValue: "",
    startDate: Utils.getDay(0),
    endDate: Utils.getDay(365),
    showToday: true,
    startText: "",
    endText: "",
    confirmText: "",
    showTitle: true,
    showSubTitle: true,
    scrollAnimation: true,
    firstDayOfWeek: 0,
    disableDate: function(date2) {
      return false;
    },
    renderHeaderButtons: void 0,
    renderDay: void 0,
    renderDayTop: void 0,
    renderDayBottom: void 0,
    onClose: function() {
    },
    onConfirm: function(param) {
    },
    onDayClick: function(data2) {
    },
    onPageChange: function(param) {
    }
  });
  var Calendar = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var locale = useConfig().locale;
    var _$_object_spread = _object_spread({}, defaultProps$16, props), style = _$_object_spread.style, className = _$_object_spread.className, children = _$_object_spread.children, popup = _$_object_spread.popup, visible = _$_object_spread.visible, type2 = _$_object_spread.type, autoBackfill = _$_object_spread.autoBackfill, title = _$_object_spread.title, defaultValue = _$_object_spread.defaultValue, startDate = _$_object_spread.startDate, endDate = _$_object_spread.endDate, showToday = _$_object_spread.showToday, startText = _$_object_spread.startText, endText = _$_object_spread.endText, confirmText = _$_object_spread.confirmText, showTitle = _$_object_spread.showTitle, showSubTitle = _$_object_spread.showSubTitle, scrollAnimation = _$_object_spread.scrollAnimation, firstDayOfWeek = _$_object_spread.firstDayOfWeek, closeIcon = _$_object_spread.closeIcon, disableDate = _$_object_spread.disableDate, renderHeaderButtons = _$_object_spread.renderHeaderButtons, renderBottomButton = _$_object_spread.renderBottomButton, renderDay = _$_object_spread.renderDay, renderDayTop = _$_object_spread.renderDayTop, renderDayBottom = _$_object_spread.renderDayBottom, onClose = _$_object_spread.onClose, onConfirm = _$_object_spread.onConfirm, onDayClick = _$_object_spread.onDayClick, onPageChange = _$_object_spread.onPageChange;
    var calendarRef = React.useRef(null);
    var close = function() {
      onClose && onClose();
    };
    var choose = function(param) {
      close();
      onConfirm && onConfirm(param);
    };
    var closePopup = function() {
      close();
    };
    var select = function(param) {
      onDayClick && onDayClick(param);
    };
    var scrollToDate = function(date2) {
      var _calendarRef_current;
      (_calendarRef_current = calendarRef.current) === null || _calendarRef_current === void 0 ? void 0 : _calendarRef_current.scrollToDate(date2);
    };
    var yearMonthChange = function(param) {
      onPageChange && onPageChange(param);
    };
    React.useImperativeHandle(ref, function() {
      return {
        scrollToDate
      };
    });
    var renderItem = function() {
      return /* @__PURE__ */ React.createElement(CalendarItem, {
        ref: calendarRef,
        style,
        className,
        children,
        type: type2,
        autoBackfill,
        renderBottomButton,
        popup,
        title: title || locale.calendaritem.title,
        defaultValue,
        startDate,
        endDate,
        showToday,
        startText: startText || locale.calendaritem.start,
        endText: endText || locale.calendaritem.end,
        confirmText: confirmText || locale.calendaritem.confirm,
        showTitle,
        showSubTitle,
        scrollAnimation,
        firstDayOfWeek,
        disableDate,
        renderHeaderButtons,
        renderDay,
        renderDayTop,
        renderDayBottom,
        onConfirm: choose,
        onDayClick: select,
        onPageChange: yearMonthChange
      });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, popup ? /* @__PURE__ */ React.createElement(Popup, {
      className: "nut-calendar-popup",
      visible,
      position: "bottom",
      round: true,
      closeable: true,
      closeIcon,
      destroyOnClose: true,
      onOverlayClick: closePopup,
      onCloseIconClick: closePopup,
      style: {
        height: "83%"
      }
    }, renderItem()) : renderItem());
  });
  Calendar.displayName = "NutCalendar";
  var ArrowLeft = function() {
    return /* @__PURE__ */ React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M6.605 9.49a.771.771 0 0 1 0-.98l3.6-4.372a.771.771 0 0 1 1.19.981L8.2 9l3.197 3.881a.771.771 0 1 1-1.191.98l-3.6-4.37Z"
    }));
  };
  var ArrowRight = function() {
    return /* @__PURE__ */ React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M11.396 9.49a.771.771 0 0 0 0-.98l-3.6-4.372a.771.771 0 0 0-1.191.981L9.8 9l-3.196 3.881a.771.771 0 0 0 1.19.98l3.6-4.37Z"
    }));
  };
  var DoubleLeft = function() {
    return /* @__PURE__ */ React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M13.853 4.026a.771.771 0 0 1 .12 1.085L10.864 9l3.11 3.889a.771.771 0 1 1-1.204.963L9.272 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.084-.12Zm-5.245 0a.771.771 0 0 1 .12 1.085L5.617 9l3.111 3.889a.771.771 0 0 1-1.205.963L4.026 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.085-.12Z"
    }));
  };
  var DoubleRight = function() {
    return /* @__PURE__ */ React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M4.147 13.974a.771.771 0 0 1-.12-1.085L7.136 9 4.028 5.11a.771.771 0 1 1 1.204-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.084.12Zm5.245 0a.771.771 0 0 1-.12-1.085L12.383 9 9.272 5.11a.771.771 0 1 1 1.205-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.085.12Z"
    }));
  };
  var convertDateToDay = function(date2) {
    return date2 ? {
      year: date2.getFullYear(),
      month: date2.getMonth() + 1,
      date: date2.getDate()
    } : null;
  };
  var convertDayToDate = function(day) {
    return day ? new Date(day.year, day.month - 1, day.date) : null;
  };
  var getPrevMonthDays = function(year, month, firstDayOfWeek) {
    var prevMonth = month - 1;
    var prevYear = year;
    if (prevMonth <= 0) {
      prevMonth = 12;
      prevYear -= 1;
    }
    var days = Utils.getMonthPreDay(year, month);
    days -= firstDayOfWeek;
    if (days >= 7) {
      days -= 7;
    }
    var preDates = Utils.getMonthDays("".concat(prevYear), "".concat(prevMonth));
    var months = Array.from(Array(preDates), function(_, k) {
      return {
        type: "prev",
        year: prevYear,
        month: prevMonth,
        date: k + 1
      };
    });
    return months.slice(preDates - days);
  };
  var getCurrentMonthDays = function(year, month) {
    var days = Utils.getMonthDays("".concat(year), "".concat(month));
    return Array.from(Array(days), function(_, k) {
      return {
        type: "current",
        year,
        month,
        date: k + 1
      };
    });
  };
  var getCurrentWeekDays = function(day, firstDayOfWeek) {
    var current = new Date(day.year, day.month - 1, day.date);
    var count = (current.getDay() + 7 - firstDayOfWeek) % 7;
    return [
      convertDateToDay(new Date(current.getTime() - 24 * 60 * 60 * 1e3 * count)),
      convertDateToDay(new Date(current.getTime() + 24 * 60 * 60 * 1e3 * (6 - count)))
    ];
  };
  var defaultProps$15 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "single",
    firstDayOfWeek: 0
  });
  var prefixCls = "nut-calendarcard";
  var CalendarCard = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var locale = useConfig().locale;
    var _$_object_spread = _object_spread({}, defaultProps$15, props), style = _$_object_spread.style, className = _$_object_spread.className, type2 = _$_object_spread.type, value2 = _$_object_spread.value, defaultValue = _$_object_spread.defaultValue, firstDayOfWeek = _$_object_spread.firstDayOfWeek, startDate = _$_object_spread.startDate, endDate = _$_object_spread.endDate, disableDay = _$_object_spread.disableDay, renderDay = _$_object_spread.renderDay, renderDayTop = _$_object_spread.renderDayTop, renderDayBottom = _$_object_spread.renderDayBottom, onDayClick = _$_object_spread.onDayClick, onPageChange = _$_object_spread.onPageChange, onChange = _$_object_spread.onChange;
    var _useState = _sliced_to_array(React.useState(function() {
      var date2 = new Date(Date.now());
      var val2 = value2 || defaultValue;
      if (Array.isArray(val2)) {
        if (val2.length) {
          date2 = val2[0];
        }
      } else if (val2) {
        date2 = val2;
      }
      return {
        year: date2.getFullYear(),
        month: date2.getMonth() + 1
      };
    }), 2), month = _useState[0], setMonth = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), days = _useState1[0], setDays = _useState1[1];
    var valueToRange = function(val2) {
      if (Array.isArray(val2)) {
        return val2.map(function(date2) {
          return convertDateToDay(date2);
        });
      }
      return val2 ? [
        convertDateToDay(val2)
      ] : [];
    };
    var rangeTovalue = function(range2) {
      if (Array.isArray(range2)) {
        return range2.map(function(day) {
          return convertDayToDate(day);
        });
      }
      return range2 ? [
        convertDayToDate(range2)
      ] : [];
    };
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2 ? valueToRange(value2) : void 0,
      defaultValue: defaultValue ? valueToRange(defaultValue) : void 0,
      finalValue: []
    }), 2), innerValue = _usePropsValue[0], setInnerValue = _usePropsValue[1];
    var change = function(v) {
      setInnerValue(v);
      if (type2 === "single") {
        var date2 = convertDayToDate(v[0]);
        onChange === null || onChange === void 0 ? void 0 : onChange(date2);
      } else if (type2 === "multiple" || type2 === "range" || type2 === "week") {
        var val2 = rangeTovalue(v);
        onChange === null || onChange === void 0 ? void 0 : onChange(val2);
      }
    };
    var getDays = React.useCallback(function(month2) {
      var y = month2.year;
      var m2 = month2.month;
      var days2 = _to_consumable_array(getPrevMonthDays(y, m2, firstDayOfWeek)).concat(_to_consumable_array(getCurrentMonthDays(y, m2)));
      var size = days2.length;
      var yearOfNextMonth = month2.month === 12 ? month2.year + 1 : month2.year;
      var monthOfNextMonth = month2.month === 12 ? 1 : month2.month + 1;
      for (var i2 = 1; i2 <= 42 - size; i2++) {
        days2.push({
          type: "next",
          year: yearOfNextMonth,
          month: monthOfNextMonth,
          date: i2
        });
      }
      return days2;
    }, [
      firstDayOfWeek
    ]);
    React.useEffect(function() {
      var newDays = getDays(month);
      setDays(newDays);
      onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(month);
    }, [
      month,
      getDays,
      onPageChange,
      firstDayOfWeek
    ]);
    var isSameDay = function(day1, day2) {
      return (day1 === null || day1 === void 0 ? void 0 : day1.year) === (day2 === null || day2 === void 0 ? void 0 : day2.year) && (day1 === null || day1 === void 0 ? void 0 : day1.month) === (day2 === null || day2 === void 0 ? void 0 : day2.month) && (day1 === null || day1 === void 0 ? void 0 : day1.date) === (day2 === null || day2 === void 0 ? void 0 : day2.date);
    };
    var compareDay = function(day1, day2) {
      if (day1 && day2) {
        if (day1.year === day2.year) {
          if (day1.month === day2.month) {
            return day1.date - day2.date;
          }
          return day1.month - day2.month;
        }
        return day1.year - day2.year;
      }
    };
    var isDisable = function(day) {
      if (disableDay && disableDay(day)) {
        return true;
      }
      if (startDate && Number(compareDay(day, convertDateToDay(startDate))) < 0) {
        return true;
      }
      if (endDate && Number(compareDay(day, convertDateToDay(endDate))) > 0) {
        return true;
      }
      return false;
    };
    var isActive = function(day) {
      if (type2 === "single" || type2 === "multiple") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
        try {
          for (var _iterator = innerValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var val2 = _step.value;
            if (isSameDay(day, val2)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (type2 === "range" && innerValue.length === 1 && isSameDay(innerValue[0], day)) {
        return true;
      }
      return false;
    };
    var isStart2 = function(day) {
      return (type2 === "range" || type2 === "week") && innerValue.length === 2 && isSameDay(day, innerValue[0]);
    };
    var isEnd2 = function(day) {
      return (type2 === "range" || type2 === "week") && innerValue.length === 2 && isSameDay(day, innerValue[1]);
    };
    var isMid = function(day) {
      if (type2 === "range" || type2 === "week") {
        if (innerValue.length === 2) {
          var c12 = compareDay(innerValue[0], day);
          var c22 = compareDay(day, innerValue[1]);
          if (c12 && c12 < 0 && c22 && c22 < 0) {
            return true;
          }
        }
      }
      return false;
    };
    var isWeekend = function(day) {
      var d2 = new Date(day.year, day.month - 1, day.date).getDay();
      return d2 === 0 || d2 === 6;
    };
    var getClasses = function(day) {
      if (isDisable(day)) {
        return [
          "disabled"
        ];
      }
      var res = [];
      if (day.type === "current") {
        if (isActive(day)) {
          res.push("active");
        }
        if (isStart2(day)) {
          res.push("start");
        }
        if (isEnd2(day)) {
          res.push("end");
        }
        if (isMid(day)) {
          res.push("mid");
        }
        if (isWeekend(day)) {
          res.push("weekend");
        }
      }
      return res;
    };
    var jumpTo = function(year, month2) {
      if (startDate) {
        var c6 = compareDay({
          year,
          month: month2,
          date: 31
        }, convertDateToDay(startDate));
        if (c6 && c6 < 0) {
          return;
        }
      }
      if (endDate) {
        var c12 = compareDay({
          year,
          month: month2,
          date: 1
        }, convertDateToDay(endDate));
        if (c12 && c12 > 0) {
          return;
        }
      }
      setMonth({
        year,
        month: month2
      });
    };
    var jump = function() {
      var step = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      var current = month.year * 12 + month.month;
      var newMonth = (current + step) % 12;
      if (newMonth === 0) {
        newMonth = 12;
      }
      var newYear = Math.floor((current + step - newMonth) / 12);
      jumpTo(newYear, newMonth);
    };
    React.useImperativeHandle(ref, function() {
      return {
        jump,
        jumpTo
      };
    });
    var handleDayClick = function(day) {
      onDayClick === null || onDayClick === void 0 ? void 0 : onDayClick(day);
      if (day.type === "prev" || day.type === "next" || isDisable(day)) {
        return;
      }
      switch (type2) {
        case "single": {
          if (innerValue[0] && isSameDay(innerValue[0], day)) {
            change([]);
          } else {
            change([
              day
            ]);
          }
          break;
        }
        case "multiple": {
          var t = innerValue.find(function(i2) {
            return isSameDay(i2, day);
          });
          if (t) {
            change(innerValue.filter(function(i2) {
              return i2 !== t;
            }));
          } else {
            change(_to_consumable_array(innerValue).concat([
              day
            ]));
          }
          break;
        }
        case "range": {
          var len = innerValue.length;
          if (len === 0 || len === 2) {
            change([
              day
            ]);
          } else if (len === 1) {
            var t1 = compareDay(innerValue[0], day);
            if (t1 === null || t1 === void 0) {
              change([]);
            } else if (t1 < 0) {
              change([
                innerValue[0],
                day
              ]);
            } else {
              change([
                day,
                innerValue[0]
              ]);
            }
          } else {
            console.warn("[NutUI] Calendar range error");
          }
          break;
        }
        case "week": {
          if (innerValue.length === 2 || innerValue.length === 0) {
            var _getCurrentWeekDays = _sliced_to_array(getCurrentWeekDays(day, firstDayOfWeek), 2), left = _getCurrentWeekDays[0], right = _getCurrentWeekDays[1];
            change([
              left,
              right
            ]);
          } else {
            console.warn("[NutUI] Calendar week error");
          }
          break;
        }
        default: {
          console.warn("[NutUI] Calendar type error");
        }
      }
    };
    var monthTitle = locale.calendaritem.monthTitle;
    var renderHeader = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-header")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-header-left")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "double-left",
        onClick: function() {
          return jump(-12);
        }
      }, /* @__PURE__ */ React.createElement(DoubleLeft, null)), /* @__PURE__ */ React.createElement("div", {
        className: "left",
        onClick: function() {
          return jump(-1);
        }
      }, /* @__PURE__ */ React.createElement(ArrowLeft, null))), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-header-title")
      }, monthTitle(month.year, month.month)), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-header-right")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "right",
        onClick: function() {
          return jump(1);
        }
      }, /* @__PURE__ */ React.createElement(ArrowRight, null)), /* @__PURE__ */ React.createElement("div", {
        className: "double-right",
        onClick: function() {
          return jump(12);
        }
      }, /* @__PURE__ */ React.createElement(DoubleRight, null))));
    };
    var _useState2 = _sliced_to_array(React.useState(function() {
      var weekdays = locale.calendaritem.weekdays.map(function(day, index2) {
        return {
          name: day,
          key: index2
        };
      });
      return _to_consumable_array(weekdays.slice(firstDayOfWeek, 7)).concat(_to_consumable_array(weekdays.slice(0, firstDayOfWeek)));
    }), 1), weekHeader = _useState2[0];
    var renderContent = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-content")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-days")
      }, weekHeader.map(function(day) {
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("".concat(prefixCls, "-day"), "header", {
            weekend: day.key === 0 || day.key === 6
          }),
          key: day.key
        }, day.name);
      })), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-days")
      }, days.map(function(day) {
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("".concat(prefixCls, "-day"), day.type, getClasses(day)),
          key: "".concat(day.year, "-").concat(day.month, "-").concat(day.date),
          onClick: function() {
            return handleDayClick(day);
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-day-top")
        }, renderDayTop ? renderDayTop(day) : ""), /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-day-inner")
        }, renderDay ? renderDay(day) : day.date), /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-day-bottom")
        }, renderDayBottom ? renderDayBottom(day) : ""));
      })));
    };
    return days.length > 0 ? /* @__PURE__ */ React.createElement("div", {
      className: classNames(prefixCls, className),
      style
    }, renderHeader(), renderContent()) : null;
  });
  CalendarCard.displayName = "NutCalendarCard";
  var CheckboxGroupContext = React.createContext(null);
  var defaultProps$14 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    disabled: false,
    shape: "round",
    labelPosition: "right",
    icon: null,
    activeIcon: null,
    indeterminateIcon: null,
    onChange: function(value2) {
    }
  });
  var classPrefix$j = "nut-checkbox";
  var Checkbox = function(props) {
    var children = _object_spread({}, defaultProps$14, props).children;
    var icon = props.icon, label = props.label, className = props.className, activeIcon = props.activeIcon, checked = props.checked, value2 = props.value, defaultChecked = props.defaultChecked, shape = props.shape, disabled = props.disabled, onChange = props.onChange, indeterminate = props.indeterminate, indeterminateIcon = props.indeterminateIcon, others = _object_without_properties(props, [
      "icon",
      "label",
      "className",
      "activeIcon",
      "checked",
      "value",
      "defaultChecked",
      "shape",
      "disabled",
      "onChange",
      "indeterminate",
      "indeterminateIcon"
    ]);
    var labelPosition = others.labelPosition, rest = _object_without_properties(others, [
      "labelPosition"
    ]);
    var ctx2 = React.useContext(CheckboxGroupContext);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: checked,
      defaultValue: defaultChecked,
      finalValue: defaultChecked,
      onChange
    }), 2), innerChecked = _usePropsValue[0], setChecked = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState(disabled), 2), innerDisabled = _useState[0], setDisabled = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(indeterminate), 2), innerIndeterminate = _useState1[0], setIndeterminate = _useState1[1];
    React.useEffect(function() {
      setDisabled(disabled);
    }, [
      disabled
    ]);
    React.useEffect(function() {
      setIndeterminate(indeterminate);
    }, [
      indeterminate
    ]);
    if (ctx2) {
      if (ctx2.labelPosition !== void 0) {
        labelPosition = ctx2.labelPosition;
      }
      innerDisabled = ctx2.disabled !== void 0 ? ctx2.disabled : innerDisabled;
      innerChecked = ctx2.value.includes(value2);
      setChecked = function(checked2) {
        if (ctx2.disabled) return;
        if (checked2) ctx2.check(value2);
        if (!checked2) ctx2.uncheck(value2);
      };
    }
    var renderIcon = function() {
      if (innerDisabled) {
        if (innerIndeterminate) {
          return /* @__PURE__ */ React.createElement(n$9, {
            className: color()
          });
        }
        if (innerChecked) {
          return /* @__PURE__ */ React.createElement(n$7, {
            className: color()
          });
        }
        return /* @__PURE__ */ React.createElement(n$9, {
          className: color()
        });
      }
      if (!innerChecked) {
        return /* @__PURE__ */ React.isValidElement(icon) ? icon : /* @__PURE__ */ React.createElement(n$8, {
          className: color()
        });
      }
      if (innerIndeterminate) {
        return /* @__PURE__ */ React.isValidElement(indeterminateIcon) ? indeterminateIcon : /* @__PURE__ */ React.createElement(n$9, {
          className: color()
        });
      }
      return /* @__PURE__ */ React.isValidElement(activeIcon) ? activeIcon : /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$j, "-icon-wrap")
      }, /* @__PURE__ */ React.createElement(n$7, {
        className: color()
      }));
    };
    var color = function() {
      var cls = "".concat(classPrefix$j, "-icon ");
      if (innerDisabled) {
        if (innerChecked && !innerIndeterminate) {
          return "".concat(cls).concat(classPrefix$j, "-icon-checked ").concat(classPrefix$j, "-icon-disabled");
        }
        if (innerChecked && innerIndeterminate) {
          return "".concat(cls).concat(classPrefix$j, "-icon-indeterminate ").concat(classPrefix$j, "-icon-disabled");
        }
        return "".concat(cls).concat(classPrefix$j, "-icon-disabled");
      }
      if (innerChecked) {
        if (innerIndeterminate) {
          return "".concat(cls).concat(classPrefix$j, "-icon-indeterminate");
        }
        return "".concat(cls).concat(classPrefix$j, "-icon-checked");
      }
      return cls;
    };
    var renderLabel = function() {
      return /* @__PURE__ */ React.createElement("span", {
        className: classNames("".concat(classPrefix$j, "-label "), _define_property({}, "".concat(classPrefix$j, "-label-disabled"), innerDisabled))
      }, children || label);
    };
    var handleClick = function() {
      if (disabled) return;
      var latestChecked = !innerChecked;
      setChecked(latestChecked);
    };
    var renderButton = function() {
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$j, "-button"), (_obj2 = {}, _define_property(_obj2, "".concat(classPrefix$j, "-button-active"), innerChecked), _define_property(_obj2, "".concat(classPrefix$j, "-button-disabled"), disabled), _obj2))
      }, children || label, innerChecked && activeIcon ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$j, "-button-icon"))
      }), activeIcon) : null);
    };
    var renderListItem = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), renderLabel());
    };
    var renderCheckboxItem = function() {
      if (ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.list) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, renderListItem());
      }
      if (shape === "button") {
        return renderButton();
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), renderLabel());
    };
    var _obj;
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: classNames(classPrefix$j, (_obj = {}, _define_property(_obj, "".concat(classPrefix$j, "-reverse"), labelPosition === "left"), _define_property(_obj, "nut-checkbox-list-item", ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.list), _obj), className)
    }, rest), {
      onClick: handleClick
    }), renderCheckboxItem());
  };
  Checkbox.displayName = "NutCheckBox";
  var defaultProps$13 = {
    max: void 0,
    min: void 0,
    list: false,
    labelPosition: "right",
    direction: "vertical",
    onChange: function(value2) {
    },
    onLimit: function(type2) {
    },
    options: []
  };
  var classPrefix$i = "nut-checkboxgroup";
  var CheckboxGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _ref = _object_spread({}, defaultProps$13, props), children = _ref.children, className = _ref.className, disabled = _ref.disabled, list = _ref.list, value2 = _ref.value, defaultValue = _ref.defaultValue, max = _ref.max, min = _ref.min, labelPosition = _ref.labelPosition, direction = _ref.direction, options2 = _ref.options, onChange = _ref.onChange, onLimit = _ref.onLimit, rest = _object_without_properties(_ref, [
      "children",
      "className",
      "disabled",
      "list",
      "value",
      "defaultValue",
      "max",
      "min",
      "labelPosition",
      "direction",
      "options",
      "onChange",
      "onLimit"
    ]);
    React.useImperativeHandle(ref, function() {
      return {
        toggle: function toggle(state) {
          if (state === false) {
            setValue([]);
          } else {
            var childrenLabel = [];
            React.Children.map(children, function(child) {
              var childProps = child.props;
              childrenLabel.push(childProps.value);
            });
            setValue(childrenLabel);
          }
        },
        reverse: function reverse() {
          var childrenLabel = [];
          React.Children.map(children, function(child) {
            var childProps = child.props;
            childrenLabel.push(childProps.value);
          });
          var reverse2 = childrenLabel.filter(function(c6) {
            return (_value === null || _value === void 0 ? void 0 : _value.findIndex(function(v) {
              return v === c6;
            })) === -1;
          });
          setValue(reverse2);
        }
      };
    });
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: [],
      onChange
    }), 2), _value = _usePropsValue[0], setValue = _usePropsValue[1];
    var renderOptions = React.useCallback(function() {
      return options2 === null || options2 === void 0 ? void 0 : options2.map(function(_param) {
        var label = _param.label, value3 = _param.value, disabled2 = _param.disabled;
        _param.onChange;
        var rest2 = _object_without_properties(_param, [
          "label",
          "value",
          "disabled",
          "onChange"
        ]);
        return /* @__PURE__ */ React.createElement(Checkbox, _object_spread({
          key: value3 === null || value3 === void 0 ? void 0 : value3.toString(),
          label,
          disabled: disabled2,
          value: value3
        }, rest2));
      });
    }, [
      options2,
      max,
      min
    ]);
    var _obj;
    return /* @__PURE__ */ React.createElement(CheckboxGroupContext.Provider, {
      value: {
        labelPosition: labelPosition || "right",
        disabled,
        max,
        list,
        onLimit,
        value: _value,
        check: function(value3) {
          var combined = _to_consumable_array(_value).concat([
            value3
          ]);
          if (max !== void 0) {
            if (combined.length > max) {
              return onLimit === null || onLimit === void 0 ? void 0 : onLimit("max");
            }
          }
          setValue(combined);
        },
        uncheck: function(value3) {
          var reduced = _value.filter(function(item) {
            return item !== value3;
          });
          if (min !== void 0 && reduced.length < min) {
            return onLimit === null || onLimit === void 0 ? void 0 : onLimit("min");
          }
          setValue(reduced);
        }
      }
    }, /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix$i, (_obj = {}, _define_property(_obj, "nut-checkboxgroup-".concat(direction), direction), _define_property(_obj, "nut-checkboxgroup-list", list), _obj), className)
    }, rest), (options2 === null || options2 === void 0 ? void 0 : options2.length) ? renderOptions() : children));
  });
  CheckboxGroup.displayName = "NutCheckboxGroup";
  var InnerCheckbox = Checkbox;
  InnerCheckbox.Group = CheckboxGroup;
  var momentum = function(distance, duration) {
    var speed = Math.abs(distance / duration);
    return speed / 3e-3 * (distance < 0 ? -1 : 1);
  };
  var useStyles = function(touchTime, touchDeg, scrollDistance, lineSpacing, rotation2) {
    var getTransitionStyle = function(transformValue) {
      return {
        transition: "transform ".concat(touchTime, "ms cubic-bezier(0.17, 0.89, 0.45, 1)"),
        transform: transformValue
      };
    };
    var touchRollerStyle = function() {
      return getTransitionStyle("rotate3d(1, 0, 0, ".concat(touchDeg, ")"));
    };
    var touchTiledStyle = function() {
      return getTransitionStyle("translate3d(0, ".concat(scrollDistance, "px, 0)"));
    };
    var rollerStyle = function(index2) {
      return {
        transform: "rotate3d(1, 0, 0, ".concat(-20 * (index2 + 1), "deg) translate3d(0px, 0px, ").concat(Math.round(lineSpacing.current * 3.2), "px)")
      };
    };
    return {
      touchRollerStyle,
      touchTiledStyle,
      rollerStyle
    };
  };
  var InternalPickerRoller = function(props, ref) {
    var _props_keyIndex = props.keyIndex, keyIndex = _props_keyIndex === void 0 ? 0 : _props_keyIndex, _props_options = props.options, options2 = _props_options === void 0 ? [] : _props_options, _props_threeDimensional = props.threeDimensional, threeDimensional = _props_threeDimensional === void 0 ? true : _props_threeDimensional, _props_duration = props.duration, duration = _props_duration === void 0 ? 1e3 : _props_duration, onSelect = props.onSelect, _props_renderLabel = props.renderLabel, renderLabel = _props_renderLabel === void 0 ? function(item) {
      return item.label;
    } : _props_renderLabel;
    var classPrefix2 = "nut-pickerview-roller";
    var DEFAULT_DURATION = 200;
    var INERTIA_TIME = 300;
    var INERTIA_DISTANCE = 15;
    var ROTATION = 20;
    var touch = useTouch();
    var _useState = _sliced_to_array(React.useState(0), 2), currentIndex = _useState[0], setCurrentIndex = _useState[1];
    var lineSpacing = React.useRef(36);
    var _useState1 = _sliced_to_array(React.useState(0), 2), touchTime = _useState1[0], setTouchTime = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState("0deg"), 2), touchDeg = _useState2[0], setTouchDeg = _useState2[1];
    var isMoving = React.useRef(false);
    var rollerRef = React.useRef(null);
    var pickerRollerRef = React.useRef(null);
    var _useState3 = _sliced_to_array(React.useState(0), 2), startTime = _useState3[0], setStartTime = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState(0), 2), startY = _useState4[0], setStartY = _useState4[1];
    var transformY = React.useRef(0);
    var _useState5 = _sliced_to_array(React.useState(0), 2), scrollDistance = _useState5[0], setScrollDistance = _useState5[1];
    var _useStyles = useStyles(touchTime, touchDeg, scrollDistance, lineSpacing), touchRollerStyle = _useStyles.touchRollerStyle, touchTiledStyle = _useStyles.touchTiledStyle, rollerStyle = _useStyles.rollerStyle;
    var isItemHidden = function(index2) {
      return index2 >= currentIndex + 8 || index2 <= currentIndex - 8;
    };
    var applyTransform = function(type2, deg) {
      var time2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_DURATION, translateY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      setTouchTime(type2 !== "end" ? 0 : time2);
      setTouchDeg(deg);
      setScrollDistance(translateY);
    };
    var handleMove = function(move, type2, time2) {
      var updatedMove = move + transformY.current;
      if (type2 === "end") {
        updatedMove = Math.max(Math.min(updatedMove, 0), -(options2.length - 1) * lineSpacing.current);
        var endMove = Math.round(updatedMove / lineSpacing.current) * lineSpacing.current;
        var deg = "".concat((Math.abs(Math.round(endMove / lineSpacing.current)) + 1) * ROTATION, "deg");
        applyTransform(type2, deg, time2, endMove);
        setCurrentIndex(Math.abs(Math.round(endMove / lineSpacing.current)) + 1);
      } else {
        var currentDeg = (-updatedMove / lineSpacing.current + 1) * ROTATION;
        var deg1 = Math.min(Math.max(currentDeg, 0), (options2.length + 1) * ROTATION);
        if (deg1 >= 0 && deg1 < (options2.length + 1) * ROTATION) {
          applyTransform("", "".concat(deg1, "deg"), void 0, updatedMove);
          deg1 > 0 && setCurrentIndex(Math.abs(Math.round(updatedMove / lineSpacing.current)) + 1);
        }
      }
    };
    var selectValue = function(move) {
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(options2 === null || options2 === void 0 ? void 0 : options2[Math.round(-move / lineSpacing.current)], keyIndex);
    };
    var handleTouchStart = function(event) {
      touch.start(event);
      setStartY(touch.deltaY.current);
      setStartTime(Date.now());
      transformY.current = scrollDistance;
    };
    var handleTouchMove = function(event) {
      touch.move(event);
      if (touch.isVertical) {
        isMoving.current = true;
        preventDefault$1(event, true);
      }
      var move = touch.deltaY.current - startY;
      handleMove(move);
    };
    var handleTouchEnd = function() {
      if (!isMoving.current) return;
      var move = touch.deltaY.current - startY;
      var moveTime = Date.now() - startTime;
      if (moveTime <= INERTIA_TIME && Math.abs(move) > INERTIA_DISTANCE) {
        var distance = momentum(move, moveTime);
        handleMove(distance, "end", +duration);
      } else {
        handleMove(move, "end");
      }
      setTimeout(function() {
        touch.reset();
      }, 0);
    };
    var updateStatus = function(shouldSelect, value2) {
      var selectedValue = props.value;
      var index2 = options2.findIndex(function(item) {
        return item.value === selectedValue;
      });
      setCurrentIndex(index2 === -1 ? 0 : index2 + 1);
      var move = index2 * lineSpacing.current;
      handleMove(-move);
    };
    var stopMomentumScroll = function() {
      isMoving.current = false;
      setTouchTime(0);
      selectValue(scrollDistance);
    };
    React.useEffect(function() {
      var element = pickerRollerRef.current;
      if (element) {
        var computedStyle = getComputedStyle(element);
        var currentLineSpacing = computedStyle.getPropertyValue("--nutui-picker-item-height");
        !!currentLineSpacing && (lineSpacing.current = parseFloat(currentLineSpacing));
      }
    }, [
      pickerRollerRef.current
    ]);
    React.useEffect(function() {
      isMoving.current = false;
      setScrollDistance(0);
      transformY.current = 0;
      updateStatus();
    }, [
      options2,
      props.value
    ]);
    React.useImperativeHandle(ref, function() {
      return {
        stopMomentum: stopMomentumScroll,
        moving: isMoving.current
      };
    });
    React.useEffect(function() {
      var _pickerRollerRef_current, _pickerRollerRef_current1, _pickerRollerRef_current2;
      var options3 = exports.passiveSupported ? {
        passive: false
      } : false;
      (_pickerRollerRef_current = pickerRollerRef.current) === null || _pickerRollerRef_current === void 0 ? void 0 : _pickerRollerRef_current.addEventListener("touchstart", handleTouchStart, options3);
      (_pickerRollerRef_current1 = pickerRollerRef.current) === null || _pickerRollerRef_current1 === void 0 ? void 0 : _pickerRollerRef_current1.addEventListener("touchmove", handleTouchMove, options3);
      (_pickerRollerRef_current2 = pickerRollerRef.current) === null || _pickerRollerRef_current2 === void 0 ? void 0 : _pickerRollerRef_current2.addEventListener("touchend", handleTouchEnd, options3);
      return function() {
        var _pickerRollerRef_current3, _pickerRollerRef_current12, _pickerRollerRef_current22;
        (_pickerRollerRef_current3 = pickerRollerRef.current) === null || _pickerRollerRef_current3 === void 0 ? void 0 : _pickerRollerRef_current3.removeEventListener("touchstart", handleTouchStart);
        (_pickerRollerRef_current12 = pickerRollerRef.current) === null || _pickerRollerRef_current12 === void 0 ? void 0 : _pickerRollerRef_current12.removeEventListener("touchmove", handleTouchMove);
        (_pickerRollerRef_current22 = pickerRollerRef.current) === null || _pickerRollerRef_current22 === void 0 ? void 0 : _pickerRollerRef_current22.removeEventListener("touchend", handleTouchEnd);
      };
    }, [
      pickerRollerRef.current,
      handleTouchStart,
      handleTouchMove,
      handleTouchEnd
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "nut-pickerview-list",
      ref: pickerRollerRef
    }, /* @__PURE__ */ React.createElement("div", {
      className: classPrefix2,
      ref: rollerRef,
      style: threeDimensional ? touchRollerStyle() : touchTiledStyle(),
      onTransitionEnd: stopMomentumScroll
    }, threeDimensional && options2.map(function(item, index2) {
      var _item_value;
      var _obj;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-item"), (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-item-hidden"), isItemHidden(index2 + 1)), _define_property(_obj, "".concat(classPrefix2, "-item-active"), index2 + 1 === currentIndex), _obj)),
        style: rollerStyle(index2),
        key: (_item_value = item.value) !== null && _item_value !== void 0 ? _item_value : index2
      }, renderLabel(item));
    }), !threeDimensional && options2.map(function(item, index2) {
      var _item_value;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-item-tiled"), _define_property({}, "".concat(classPrefix2, "-item-active"), index2 + 1 === currentIndex)),
        key: (_item_value = item.value) !== null && _item_value !== void 0 ? _item_value : index2
      }, renderLabel(item));
    })));
  };
  var PickerRoller = /* @__PURE__ */ React.forwardRef(InternalPickerRoller);
  var defaultProps$12 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    options: [],
    defaultValue: [],
    value: void 0,
    renderLabel: function(item) {
      return item.label;
    }
  });
  var InternalPickerView = function(props, ref) {
    var _$_object_spread = _object_spread({}, defaultProps$12, props), options2 = _$_object_spread.options, _object_spread_defaultValue = _$_object_spread.defaultValue, defaultValue = _object_spread_defaultValue === void 0 ? [] : _object_spread_defaultValue, value2 = _$_object_spread.value, duration = _$_object_spread.duration, threeDimensional = _$_object_spread.threeDimensional, renderLabel = _$_object_spread.renderLabel, className = _$_object_spread.className, style = _$_object_spread.style, onChange = _$_object_spread.onChange;
    var classPrefix2 = "nut-pickerview";
    var cls = classNames(classPrefix2, className);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue: _to_consumable_array(defaultValue),
      finalValue: _to_consumable_array(defaultValue)
    }), 1), selectedValue = _usePropsValue[0];
    var _useState = _sliced_to_array(React.useState(selectedValue), 2), innerValue = _useState[0], setInnerValue = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), innerOptions = _useState1[0], setInnerOptions = _useState1[1];
    var changeIndex = React.useRef(0);
    var columnsType = React.useMemo(function() {
      var firstColumn = props.options[0] || [];
      if (Array.isArray(firstColumn) && firstColumn.length > 0 && "children" in firstColumn[0]) {
        return "cascade";
      }
      return "multiple";
    }, [
      props.options
    ]);
    var formatCascadeOptions = function(options3, value3) {
      var _loop = function() {
        var currentOptions = columnOptions.children;
        formatted.push(currentOptions);
        var currentValue = value3 === null || value3 === void 0 ? void 0 : value3[columnIndex];
        if (currentValue === 0) {
          columnOptions = currentOptions[0];
        } else if (currentValue) {
          var index2 = currentOptions.findIndex(function(columnItem) {
            return columnItem.value === currentValue;
          });
          columnOptions = currentOptions[index2 === -1 ? 0 : index2];
        } else {
          return "break";
        }
        columnIndex++;
      };
      if (!options3.length) return [];
      var formatted = [];
      var columnOptions = {
        label: "",
        value: "",
        children: options3
      };
      var columnIndex = 0;
      while (columnOptions && columnOptions.children) {
        var _ret = _loop();
        if (_ret === "break") break;
      }
      return formatted;
    };
    var formatOptions = React.useMemo(function() {
      if (columnsType === "cascade") {
        var _props_options;
        return formatCascadeOptions(props === null || props === void 0 ? void 0 : (_props_options = props.options) === null || _props_options === void 0 ? void 0 : _props_options[0], innerValue);
      }
      return props.options;
    }, [
      innerValue,
      options2,
      columnsType
    ]);
    React.useEffect(function() {
      var options3 = props.options;
      if (Array.isArray(options3) && options3.length && options3 !== innerOptions) {
        setInnerOptions(formatOptions);
      }
    }, [
      props.options,
      innerValue
    ]);
    React.useEffect(function() {
      if (selectedValue !== innerValue) {
        setInnerValue(selectedValue);
      }
    }, [
      selectedValue
    ]);
    var handleSelect = React.useCallback(function(option, index2) {
      var newValue = option === null || option === void 0 ? void 0 : option.value;
      if (isEmpty(newValue) || innerValue[index2] === newValue) return;
      changeIndex.current = index2;
      if (columnsType === "multiple") {
        setInnerValue(function(prev) {
          var next = _to_consumable_array(prev);
          next[index2] = newValue;
          return next;
        });
      } else {
        var _option_children, _option_children1, _props_options;
        var startIndex = index2;
        var values = [];
        values[index2] = option.value;
        while (option === null || option === void 0 ? void 0 : (_option_children = option.children) === null || _option_children === void 0 ? void 0 : _option_children[0]) {
          values[index2 + 1] = option.children[0].value;
          index2++;
          option = option.children[0];
        }
        if (option === null || option === void 0 ? void 0 : (_option_children1 = option.children) === null || _option_children1 === void 0 ? void 0 : _option_children1.length) {
          values[index2 + 1] = "";
        }
        var combineResult = _to_consumable_array(innerValue.slice(0, startIndex)).concat(_to_consumable_array(values.splice(startIndex)));
        setInnerValue(_to_consumable_array(combineResult));
        var optionFirst = props === null || props === void 0 ? void 0 : (_props_options = props.options) === null || _props_options === void 0 ? void 0 : _props_options[0];
        if (!isEqual$1(formatCascadeOptions(optionFirst, combineResult), innerOptions)) {
          setInnerOptions(formatCascadeOptions(optionFirst, combineResult));
        }
      }
    }, [
      innerValue,
      props.options,
      columnsType,
      innerOptions
    ]);
    var selectedOptions = React.useMemo(function() {
      return innerOptions.map(function(columnOptions, index2) {
        var selectedOption = columnOptions.find(function(item) {
          return item.value === innerValue[index2];
        });
        return selectedOption;
      }).filter(Boolean);
    }, [
      innerOptions,
      innerValue
    ]);
    React.useEffect(function() {
      onChange === null || onChange === void 0 ? void 0 : onChange({
        value: innerValue,
        index: changeIndex.current,
        selectedOptions
      });
    }, [
      innerValue,
      selectedOptions,
      onChange
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, innerOptions.map(function(item, index2) {
      var _props_setRefs;
      return /* @__PURE__ */ React.createElement(PickerRoller, {
        ref: props === null || props === void 0 ? void 0 : (_props_setRefs = props.setRefs) === null || _props_setRefs === void 0 ? void 0 : _props_setRefs.call(props, index2),
        key: index2,
        keyIndex: index2,
        value: innerValue[index2],
        options: item,
        renderLabel,
        onSelect: handleSelect,
        duration,
        threeDimensional
      });
    }), (innerOptions === null || innerOptions === void 0 ? void 0 : innerOptions.length) ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "nut-pickerview-mask"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "nut-pickerview-indicator"
    })) : null);
  };
  var PickerView = /* @__PURE__ */ React.forwardRef(InternalPickerView);
  function useRefs() {
    var refs = React.useRef([]);
    var setRefs = React.useCallback(function(index2) {
      return function(el) {
        if (el) refs.current[index2] = el;
      };
    }, []);
    var reset = React.useCallback(function() {
      refs.current = [];
    }, []);
    return [
      refs.current,
      setRefs,
      reset
    ];
  }
  var defaultProps$11 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: "",
    options: [],
    value: void 0,
    defaultValue: [],
    closeOnOverlayClick: true
  });
  var InternalPicker$1 = function(props, ref) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$11, props), children = _ref.children;
    _ref.visible;
    var title = _ref.title, _ref_options = _ref.options, options2 = _ref_options === void 0 ? [] : _ref_options, closeOnOverlayClick = _ref.closeOnOverlayClick, _ref_popupProps = _ref.popupProps, popupProps = _ref_popupProps === void 0 ? {} : _ref_popupProps, _ref_defaultValue = _ref.defaultValue, defaultValue = _ref_defaultValue === void 0 ? [] : _ref_defaultValue, className = _ref.className, style = _ref.style, threeDimensional = _ref.threeDimensional, duration = _ref.duration;
    _ref.onConfirm;
    var onCancel = _ref.onCancel;
    _ref.onClose;
    var onChange = _ref.onChange, rest = _object_without_properties(_ref, [
      "children",
      "visible",
      "title",
      "options",
      "closeOnOverlayClick",
      "popupProps",
      "defaultValue",
      "className",
      "style",
      "threeDimensional",
      "duration",
      "onConfirm",
      "onCancel",
      "onClose",
      "onChange"
    ]);
    var classPrefix2 = "nut-picker";
    var classes = classNames(classPrefix2, className);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: props.value,
      defaultValue: _to_consumable_array(defaultValue),
      finalValue: _to_consumable_array(defaultValue),
      onChange: function(value2) {
        var _props_onConfirm;
        (_props_onConfirm = props.onConfirm) === null || _props_onConfirm === void 0 ? void 0 : _props_onConfirm.call(props, selectedOptionsRef.current, value2);
      }
    }), 2), selectedValue = _usePropsValue[0], setSelectedValue = _usePropsValue[1];
    var _usePropsValue1 = _sliced_to_array(usePropsValue({
      value: props.visible,
      defaultValue: false,
      finalValue: false,
      onChange: function(v) {
        if (!v) {
          var _props_onClose;
          (_props_onClose = props.onClose) === null || _props_onClose === void 0 ? void 0 : _props_onClose.call(props, selectedOptionsRef.current, innerValue);
        }
      }
    }), 2), innerVisible = _usePropsValue1[0], setInnerVisible = _usePropsValue1[1];
    var actions = {
      open: function() {
        setInnerVisible(true);
      },
      close: function() {
        setInnerVisible(false);
      }
    };
    React.useImperativeHandle(ref, function() {
      return actions;
    });
    var _useState = _sliced_to_array(React.useState(_to_consumable_array(selectedValue)), 2), innerValue = _useState[0], setInnerValue = _useState[1];
    var innerValueRef = React.useRef(innerValue);
    var _useState1 = _sliced_to_array(React.useState([]), 2), innerOptions = _useState1[0], setInnerOptions = _useState1[1];
    var selectedOptionsRef = React.useRef([]);
    var _useRefs = _sliced_to_array(useRefs(), 2), refs = _useRefs[0], setRefs = _useRefs[1];
    React.useEffect(function() {
      if (innerVisible) {
        setInnerValue(selectedValue);
        setInnerOptions(options2);
      }
    }, [
      selectedValue,
      innerOptions,
      innerVisible
    ]);
    var onChangeItem = function(param) {
      var value2 = param.value, index2 = param.index, selectedOptions = param.selectedOptions;
      if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
        selectedOptionsRef.current = selectedOptions;
      }
      if (isEqual$1(value2, innerValueRef.current)) return;
      innerValueRef.current = value2;
      setInnerValue(value2);
      innerVisible && (onChange === null || onChange === void 0 ? void 0 : onChange({
        selectedOptions,
        value: value2,
        index: index2
      }));
    };
    var onConfirmEvent = function() {
      var moving = false;
      refs.forEach(function(ref2) {
        if (ref2.moving) moving = true;
        ref2.stopMomentum();
      });
      if (!moving) {
        setSelectedValue(innerValue, true);
        setInnerVisible(false);
      }
    };
    var onCancelEvent = function() {
      setInnerValue(selectedValue);
      onCancel === null || onCancel === void 0 ? void 0 : onCancel();
      setInnerVisible(false);
    };
    var renderTitleBar = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-control")
      }, /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-cancel-btn"),
        onClick: function(e2) {
          e2.stopPropagation();
          onCancelEvent();
        }
      }, locale === null || locale === void 0 ? void 0 : locale.cancel), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-title")
      }, title || ""), /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-confirm-btn"),
        onClick: function(e2) {
          e2.stopPropagation();
          onConfirmEvent();
        }
      }, locale.confirm));
    };
    var renderPickerElement = function() {
      return /* @__PURE__ */ React.createElement("div", _object_spread({
        className: classes,
        style
      }, rest), renderTitleBar(), typeof children !== "function" && children, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-panel")
      }, /* @__PURE__ */ React.createElement(PickerView, {
        setRefs,
        value: innerValue,
        options: props.options,
        threeDimensional,
        duration,
        onChange: function(param) {
          var value2 = param.value, index2 = param.index, selectedOptions = param.selectedOptions;
          onChangeItem({
            value: value2,
            index: index2,
            selectedOptions
          });
        }
      })));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, typeof children === "function" && children(selectedValue), /* @__PURE__ */ React.createElement(Popup, _object_spread_props(_object_spread({}, popupProps), {
      visible: innerVisible,
      position: "bottom",
      onOverlayClick: function() {
        if (!closeOnOverlayClick) return;
        onCancelEvent();
      }
    }), innerVisible ? /* @__PURE__ */ React.createElement(React.Fragment, null, renderPickerElement(), " ") : null, /* @__PURE__ */ React.createElement(SafeArea, {
      position: "bottom"
    })));
  };
  var Picker = /* @__PURE__ */ React.forwardRef(InternalPicker$1);
  function getLastDayOfMonth(year, month) {
    return new Date(year, month, 0).getDate();
  }
  var calculateDateBoundary = function(type2, value2, startDate, endDate) {
    var boundary = type2 === "min" ? startDate : endDate;
    var year = boundary.getFullYear();
    var isMax = type2 === "max";
    var month = isMax ? 12 : 1;
    var date2 = isMax ? getLastDayOfMonth(value2.getFullYear(), value2.getMonth() + 1) : 1;
    var hour = isMax ? 23 : 0;
    var minute = isMax ? 59 : 0;
    if (value2.getFullYear() === year) {
      month = boundary.getMonth() + 1;
      if (value2.getMonth() + 1 === month) {
        date2 = boundary.getDate();
        if (value2.getDate() === date2) {
          hour = boundary.getHours();
          if (value2.getHours() === hour) {
            minute = boundary.getMinutes();
          }
        }
      }
    }
    var _obj;
    return _obj = {}, _define_property(_obj, "".concat(type2, "Year"), year), _define_property(_obj, "".concat(type2, "Month"), month), _define_property(_obj, "".concat(type2, "Date"), date2), _define_property(_obj, "".concat(type2, "Hour"), hour), _define_property(_obj, "".concat(type2, "Minute"), minute), _define_property(_obj, "".concat(type2, "Seconds"), minute), _obj;
  };
  var generateDatePickerRanges = function(type2, selectedDate, startDate, endDate) {
    var selected = new Date(selectedDate);
    if (!selected) return [];
    var _calculateDateBoundary = calculateDateBoundary("max", selected, startDate, endDate), maxYear = _calculateDateBoundary.maxYear, maxDate = _calculateDateBoundary.maxDate, maxMonth = _calculateDateBoundary.maxMonth, maxHour = _calculateDateBoundary.maxHour, maxMinute = _calculateDateBoundary.maxMinute, maxSeconds = _calculateDateBoundary.maxSeconds;
    var _calculateDateBoundary1 = calculateDateBoundary("min", selected, startDate, endDate), minYear = _calculateDateBoundary1.minYear, minDate = _calculateDateBoundary1.minDate, minMonth = _calculateDateBoundary1.minMonth, minHour = _calculateDateBoundary1.minHour, minMinute = _calculateDateBoundary1.minMinute, minSeconds = _calculateDateBoundary1.minSeconds;
    var fullRanges = [
      {
        type: "year",
        range: [
          minYear,
          maxYear
        ]
      },
      {
        type: "month",
        range: [
          minMonth,
          maxMonth
        ]
      },
      {
        type: "day",
        range: [
          minDate,
          maxDate
        ]
      },
      {
        type: "hour",
        range: [
          minHour,
          maxHour
        ]
      },
      {
        type: "minute",
        range: [
          minMinute,
          maxMinute
        ]
      },
      {
        type: "seconds",
        range: [
          minSeconds,
          maxSeconds
        ]
      }
    ];
    switch (type2.toLocaleLowerCase()) {
      case "date":
        return fullRanges.slice(0, 3);
      case "datetime":
        return fullRanges.slice(0, 5);
      case "time":
        return fullRanges.slice(3, 6);
      case "year-month":
        return fullRanges.slice(0, 2);
      case "hour-minutes":
        return fullRanges.slice(3, 5);
      case "month-day":
        return fullRanges.slice(1, 3);
      case "datehour":
        return fullRanges.slice(0, 4);
      default:
        return fullRanges;
    }
  };
  var getDatePartValue = function(type2, selectedDate) {
    var date2 = new Date(selectedDate);
    if (!selectedDate) return 0;
    switch (type2) {
      case "year":
        return date2.getFullYear();
      case "month":
        return date2.getMonth() + 1;
      case "day":
        return date2.getDate();
      case "hour":
        return date2.getHours();
      case "minute":
        return date2.getMinutes();
      case "seconds":
        return date2.getSeconds();
      default:
        return 0;
    }
  };
  var generatePickerColumnWithCallback = function(min, max, currentValue, type2, minuteStep, callback, showChinese, zhCNType, formatter) {
    var currentMin = min;
    var options2 = [];
    var selectedIndex = 0;
    while (currentMin <= max) {
      options2.push(formatPickerOption(type2, currentMin, showChinese, zhCNType, formatter));
      if (type2 === "minute") {
        currentMin += minuteStep;
      } else {
        currentMin++;
      }
      if (currentMin <= Number(currentValue)) {
        selectedIndex++;
      }
    }
    callback(selectedIndex, options2);
    return options2;
  };
  var formatPickerOption = function(type2, value2, showChinese, zhCNType, formatter) {
    if (formatter) {
      return formatter(type2, {
        label: padZero(value2, 2),
        value: padZero(value2, 2)
      });
    }
    var paddedValue = padZero(value2, 2);
    var chineseText = showChinese ? zhCNType[type2] : "";
    return {
      label: paddedValue + chineseText,
      value: paddedValue
    };
  };
  var formatValue = function(value2, startDate, endDate) {
    if (!value2 || value2 && !isDate(value2)) {
      value2 = startDate;
    }
    return Math.min(Math.max(value2.getTime(), startDate.getTime()), endDate.getTime());
  };
  var handlePickerValueChange = function(selectedOptions, selectedValue, index2, type2, defaultDate, handleDateComparison) {
    var rangeType = type2.toLocaleLowerCase();
    if ([
      "date",
      "datetime",
      "datehour",
      "month-day",
      "year-month"
    ].includes(rangeType)) {
      var formattedDate = [];
      selectedValue.forEach(function(item) {
        formattedDate.push(item);
      });
      if (rangeType === "month-day" && formattedDate.length < 3) {
        formattedDate.unshift(new Date(defaultDate).getFullYear());
      }
      if (rangeType === "year-month" && formattedDate.length < 3) {
        formattedDate.push(new Date(defaultDate).getDate());
      }
      var year = Number(formattedDate[0]);
      var month = Number(formattedDate[1]) - 1;
      var day = Math.min(Number(formattedDate[2]), getLastDayOfMonth(year, month + 1));
      var date2 = null;
      if (rangeType === "date" || rangeType === "month-day" || rangeType === "year-month") {
        date2 = new Date(year, month, day);
      } else if (rangeType === "datetime") {
        date2 = new Date(year, month, day, Number(formattedDate[3]), Number(formattedDate[4]));
      } else if (rangeType === "datehour") {
        date2 = new Date(year, month, day, Number(formattedDate[3]));
      }
      handleDateComparison(date2, selectedOptions, index2);
    } else {
      var _selectedValue = _sliced_to_array(selectedValue, 3), hour = _selectedValue[0], minute = _selectedValue[1], seconds = _selectedValue[2];
      var currentDate = new Date(defaultDate);
      var year1 = currentDate.getFullYear();
      var month1 = currentDate.getMonth();
      var day1 = currentDate.getDate();
      var date1 = new Date(year1, month1, day1, Number(hour), Number(minute), rangeType === "time" ? Number(seconds) : 0);
      handleDateComparison(date1, selectedOptions, index2);
    }
  };
  var currentYear$1 = (/* @__PURE__ */ new Date()).getFullYear();
  var defaultProps$10 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    title: "",
    type: "date",
    showChinese: false,
    threeDimensional: true,
    minuteStep: 1,
    startDate: new Date(currentYear$1 - 10, 0, 1),
    endDate: new Date(currentYear$1 + 10, 11, 31)
  });
  var InternalPicker = function(props, ref) {
    var _ref = _object_spread({}, defaultProps$10, props), startDate = _ref.startDate, endDate = _ref.endDate, type2 = _ref.type, showChinese = _ref.showChinese, minuteStep = _ref.minuteStep;
    _ref.visible;
    var title = _ref.title, defaultValue = _ref.defaultValue, _ref_pickerProps = _ref.pickerProps, pickerProps = _ref_pickerProps === void 0 ? {} : _ref_pickerProps, formatter = _ref.formatter, onClose = _ref.onClose, onCancel = _ref.onCancel, onConfirm = _ref.onConfirm, filter = _ref.filter, onChange = _ref.onChange, threeDimensional = _ref.threeDimensional, className = _ref.className, style = _ref.style, children = _ref.children, rest = _object_without_properties(_ref, [
      "startDate",
      "endDate",
      "type",
      "showChinese",
      "minuteStep",
      "visible",
      "title",
      "defaultValue",
      "pickerProps",
      "formatter",
      "onClose",
      "onCancel",
      "onConfirm",
      "filter",
      "onChange",
      "threeDimensional",
      "className",
      "style",
      "children"
    ]);
    var locale = useConfig().locale;
    var lang = locale.datepicker;
    var zhCNType = {
      day: lang.day,
      year: lang.year,
      month: lang.month,
      hour: lang.hour,
      minute: lang.min,
      seconds: lang.seconds
    };
    var classPrefix2 = "nut-datepicker";
    var cls = classNames(classPrefix2, className);
    var _useState = _sliced_to_array(React.useState([]), 2), pickerValue = _useState[0], setPickerValue = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), pickerOptions = _useState1[0], setPickerOptions = _useState1[1];
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: props.value && formatValue(props.value, startDate, endDate),
      defaultValue: props.defaultValue && formatValue(props.defaultValue, startDate, endDate),
      finalValue: 0
    }), 2), selectedDate = _usePropsValue[0], setSelectedDate = _usePropsValue[1];
    var _useState2 = _sliced_to_array(React.useState(selectedDate), 2), innerDate = _useState2[0], setInnerDate = _useState2[1];
    var _usePropsValue1 = _sliced_to_array(usePropsValue({
      value: props.visible,
      defaultValue: false,
      finalValue: false
    }), 2), innerVisible = _usePropsValue1[0], setInnerVisible = _usePropsValue1[1];
    var actions = {
      open: function() {
        setInnerVisible(true);
      },
      close: function() {
        setInnerVisible(false);
      }
    };
    React.useImperativeHandle(ref, function() {
      return actions;
    });
    var handleDateComparison = function(newDate, selectedOptions, index2) {
      if (newDate && isDate(newDate)) {
        var _this;
        if (!isEqual$1((_this = new Date(selectedDate)) === null || _this === void 0 ? void 0 : _this.getTime(), newDate === null || newDate === void 0 ? void 0 : newDate.getTime())) {
          setInnerDate(formatValue(newDate, startDate, endDate));
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(selectedOptions, [
          String(newDate.getFullYear()),
          String(newDate.getMonth() + 1),
          String(newDate.getDate())
        ], index2);
      }
    };
    var handleConfirmDateComparison = function(newDate) {
      if (newDate && isDate(newDate)) {
        var _this;
        if (!isEqual$1((_this = new Date(selectedDate)) === null || _this === void 0 ? void 0 : _this.getTime(), newDate === null || newDate === void 0 ? void 0 : newDate.getTime())) {
          setSelectedDate(formatValue(newDate, startDate, endDate));
        }
      }
    };
    var handleCancel = function() {
      setInnerDate(selectedDate);
      onCancel === null || onCancel === void 0 ? void 0 : onCancel();
    };
    var handleClose = function() {
      setInnerVisible(false);
      onClose === null || onClose === void 0 ? void 0 : onClose();
    };
    var handleConfirm = function(options2, value2) {
      handlePickerValueChange(options2, value2, 0, type2, defaultValue || startDate || endDate, handleConfirmDateComparison);
      onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(options2, value2);
    };
    var handleChange = function(selectedOptions, selectedValue, index2) {
      innerVisible && handlePickerValueChange(selectedOptions, selectedValue, index2, type2, defaultValue || startDate || endDate, handleDateComparison);
    };
    var generatePickerColumns = function() {
      var dateRanges = generateDatePickerRanges(type2, innerDate, startDate, endDate);
      var columns = dateRanges.map(function(rangeConfig, columnIndex) {
        var columnType = rangeConfig.type, range2 = rangeConfig.range;
        var selectedValue = getDatePartValue(columnType, innerDate);
        var pickerColumn = generatePickerColumnWithCallback(range2[0], range2[1], selectedValue, columnType, minuteStep, function(selectedIndex, options2) {
          var _options_selectedIndex;
          pickerValue[columnIndex] = (_options_selectedIndex = options2[selectedIndex]) === null || _options_selectedIndex === void 0 ? void 0 : _options_selectedIndex.value;
          setPickerValue(_to_consumable_array(pickerValue));
        }, showChinese, zhCNType, formatter);
        if (filter === null || filter === void 0 ? void 0 : filter(columnType, pickerColumn)) {
          return filter(columnType, pickerColumn);
        }
        return pickerColumn;
      });
      return columns || [];
    };
    React.useEffect(function() {
      setInnerDate(selectedDate);
    }, [
      selectedDate
    ]);
    React.useEffect(function() {
      setPickerOptions(generatePickerColumns());
    }, [
      innerDate,
      startDate,
      endDate
    ]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, typeof children === "function" && children(selectedDate), /* @__PURE__ */ React.createElement("div", _object_spread({
      className: cls,
      style
    }, rest), pickerOptions.length && /* @__PURE__ */ React.createElement(Picker, _object_spread_props(_object_spread({}, pickerProps), {
      title,
      visible: innerVisible,
      value: pickerValue,
      options: pickerOptions,
      onClose: handleClose,
      onCancel: handleCancel,
      onConfirm: handleConfirm,
      onChange: function(param) {
        var value2 = param.value, index2 = param.index, selectedOptions = param.selectedOptions;
        handleChange(selectedOptions, value2, index2);
      },
      threeDimensional
    }))));
  };
  var DatePicker = /* @__PURE__ */ React.forwardRef(InternalPicker);
  var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  var defaultProps$$ = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "date",
    showChinese: false,
    threeDimensional: true,
    minuteStep: 1,
    startDate: new Date(currentYear - 10, 0, 1),
    endDate: new Date(currentYear + 10, 11, 31)
  });
  var DatePickerView = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$$, props), startDate = _$_object_spread.startDate, endDate = _$_object_spread.endDate, type2 = _$_object_spread.type, showChinese = _$_object_spread.showChinese, minuteStep = _$_object_spread.minuteStep, defaultValue = _$_object_spread.defaultValue, formatter = _$_object_spread.formatter, filter = _$_object_spread.filter, onChange = _$_object_spread.onChange, threeDimensional = _$_object_spread.threeDimensional, className = _$_object_spread.className, style = _$_object_spread.style;
    var classPrefix2 = "nut-datepickerview";
    var cls = classNames(classPrefix2, className);
    var locale = useConfig().locale;
    var lang = locale.datepicker;
    var zhCNType = {
      day: lang.day,
      year: lang.year,
      month: lang.month,
      hour: lang.hour,
      minute: lang.min,
      seconds: lang.seconds
    };
    var _useState = _sliced_to_array(React.useState([]), 2), pickerValue = _useState[0], setPickerValue = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), pickerOptions = _useState1[0], setPickerOptions = _useState1[1];
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: props.value && formatValue(props.value, startDate, endDate),
      defaultValue: defaultValue && formatValue(defaultValue, startDate, endDate),
      finalValue: 0
    }), 2), selectedDate = _usePropsValue[0], setSelectedDate = _usePropsValue[1];
    var handleDateComparison = function(newDate, selectedOptions, index2) {
      if (newDate && isDate(newDate)) {
        var _this;
        if (!isEqual$1((_this = new Date(selectedDate)) === null || _this === void 0 ? void 0 : _this.getTime(), newDate === null || newDate === void 0 ? void 0 : newDate.getTime())) {
          setSelectedDate(formatValue(newDate, startDate, endDate));
          onChange === null || onChange === void 0 ? void 0 : onChange(selectedOptions, [
            String(newDate.getFullYear()),
            padZero(newDate.getMonth() + 1),
            padZero(newDate.getDate())
          ], index2);
        }
      }
    };
    var handleChange = function(selectedOptions, selectedValue, index2) {
      handlePickerValueChange(selectedOptions, selectedValue, index2, type2, defaultValue || startDate || endDate, handleDateComparison);
    };
    var generatePickerColumns = function() {
      var dateRanges = generateDatePickerRanges(type2, selectedDate, startDate, endDate);
      var columns = dateRanges.map(function(rangeConfig, columnIndex) {
        var columnType = rangeConfig.type, range2 = rangeConfig.range;
        var selectedValue = getDatePartValue(columnType, selectedDate);
        var pickerColumn = generatePickerColumnWithCallback(range2[0], range2[1], selectedValue, columnType, minuteStep, function(selectedIndex, options2) {
          var _options_selectedIndex;
          pickerValue[columnIndex] = (_options_selectedIndex = options2[selectedIndex]) === null || _options_selectedIndex === void 0 ? void 0 : _options_selectedIndex.value;
          setPickerValue(_to_consumable_array(pickerValue));
        }, showChinese, zhCNType, formatter);
        if (filter === null || filter === void 0 ? void 0 : filter(columnType, pickerColumn)) {
          return filter(columnType, pickerColumn);
        }
        return pickerColumn;
      });
      return columns || [];
    };
    React.useEffect(function() {
      var _this, _this1;
      if (!isEqual$1((_this = new Date(selectedDate)) === null || _this === void 0 ? void 0 : _this.getTime(), (_this1 = new Date(selectedDate)) === null || _this1 === void 0 ? void 0 : _this1.getTime())) {
        setSelectedDate(selectedDate);
      }
    }, [
      selectedDate
    ]);
    React.useEffect(function() {
      setPickerOptions(generatePickerColumns());
    }, [
      selectedDate,
      startDate,
      endDate
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, pickerOptions.length && /* @__PURE__ */ React.createElement(PickerView, {
      value: pickerValue,
      options: pickerOptions,
      onChange: function(param) {
        var selectedOptions = param.selectedOptions, value2 = param.value, index2 = param.index;
        handleChange(selectedOptions, value2, index2);
      },
      threeDimensional
    }));
  };
  DatePickerView.displayName = "NutDatePickerView";
  var Context = React.createContext({});
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && process.env && process.env.NODE_ENV !== "production" && typeof window !== "undefined" && typeof document !== "undefined") {
    warning = function warning2(type2, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e2) {
          return typeof e2 === "string";
        })) {
          console.warn(type2, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i2 = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i2 >= len) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type2) {
    return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
  }
  function isEmptyValue(value2, type2) {
    if (value2 === void 0 || value2 === null) {
      return true;
    }
    if (type2 === "array" && Array.isArray(value2) && !value2.length) {
      return true;
    }
    if (isNativeStringType(type2) && typeof value2 === "string" && !value2) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }
    next([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
      ret.push.apply(ret, objArr[k] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next = function next2(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key2) {
        var arr = objArr[key2];
        if (firstFields.indexOf(key2) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value2, path) {
    var v = value2;
    for (var i2 = 0; i2 < path.length; i2++) {
      if (v == void 0) {
        return v;
      }
      v = v[path[i2]];
    }
    return v;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s2 in source) {
        if (source.hasOwnProperty(s2)) {
          var value2 = source[s2];
          if (typeof value2 === "object" && typeof target[s2] === "object") {
            target[s2] = _extends({}, target[s2], value2);
          } else {
            target[s2] = value2;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required2(rule, value2, source, errors, options2, type2) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value2, type2 || rule.type))) {
      errors.push(format(options2.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value2, source, errors, options2) {
    if (/^\s+$/.test(value2) || value2 === "") {
      errors.push(format(options2.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b = function b2(options2) {
      return options2 && options2.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options2) {
      return options2 && options2.exact ? v46Exact : new RegExp("(?:" + b(options2) + v4 + b(options2) + ")|(?:" + b(options2) + v6 + b(options2) + ")", "g");
    };
    ip.v4 = function(options2) {
      return options2 && options2.exact ? v4exact : new RegExp("" + b(options2) + v4 + b(options2), "g");
    };
    ip.v6 = function(options2) {
      return options2 && options2.exact ? v6exact : new RegExp("" + b(options2) + v6 + b(options2), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host2 + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer2(value2) {
      return types.number(value2) && parseInt(value2, 10) === value2;
    },
    "float": function float(value2) {
      return types.number(value2) && !types.integer(value2);
    },
    array: function array2(value2) {
      return Array.isArray(value2);
    },
    regexp: function regexp2(value2) {
      if (value2 instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value2);
      } catch (e2) {
        return false;
      }
    },
    date: function date2(value2) {
      return typeof value2.getTime === "function" && typeof value2.getMonth === "function" && typeof value2.getYear === "function" && !isNaN(value2.getTime());
    },
    number: function number2(value2) {
      if (isNaN(value2)) {
        return false;
      }
      return typeof value2 === "number";
    },
    object: function object2(value2) {
      return typeof value2 === "object" && !types.array(value2);
    },
    method: function method2(value2) {
      return typeof value2 === "function";
    },
    email: function email(value2) {
      return typeof value2 === "string" && value2.length <= 320 && !!value2.match(pattern$2.email);
    },
    url: function url(value2) {
      return typeof value2 === "string" && value2.length <= 2048 && !!value2.match(getUrlRegex());
    },
    hex: function hex(value2) {
      return typeof value2 === "string" && !!value2.match(pattern$2.hex);
    }
  };
  var type$1 = function type2(rule, value2, source, errors, options2) {
    if (rule.required && value2 === void 0) {
      required$1(rule, value2, source, errors, options2);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value2)) {
        errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value2 !== rule.type) {
      errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value2, source, errors, options2) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val2 = value2;
    var key2 = null;
    var num = typeof value2 === "number";
    var str = typeof value2 === "string";
    var arr = Array.isArray(value2);
    if (num) {
      key2 = "number";
    } else if (str) {
      key2 = "string";
    } else if (arr) {
      key2 = "array";
    }
    if (!key2) {
      return false;
    }
    if (arr) {
      val2 = value2.length;
    }
    if (str) {
      val2 = value2.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val2 !== rule.len) {
        errors.push(format(options2.messages[key2].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val2 < rule.min) {
      errors.push(format(options2.messages[key2].min, rule.fullField, rule.min));
    } else if (max && !min && val2 > rule.max) {
      errors.push(format(options2.messages[key2].max, rule.fullField, rule.max));
    } else if (min && max && (val2 < rule.min || val2 > rule.max)) {
      errors.push(format(options2.messages[key2].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable2(rule, value2, source, errors, options2) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value2) === -1) {
      errors.push(format(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern2(rule, value2, source, errors, options2) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value2)) {
          errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value2)) {
          errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2, "string");
      if (!isEmptyValue(value2, "string")) {
        rules.type(rule, value2, source, errors, options2);
        rules.range(rule, value2, source, errors, options2);
        rules.pattern(rule, value2, source, errors, options2);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value2, source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var method = function method2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var number = function number2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value2 === "") {
        value2 = void 0;
      }
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
        rules.range(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var regexp = function regexp2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (!isEmptyValue(value2)) {
        rules.type(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var integer = function integer2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
        rules.range(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
        rules.range(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var array = function array2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value2 === void 0 || value2 === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2, "array");
      if (value2 !== void 0 && value2 !== null) {
        rules.type(rule, value2, source, errors, options2);
        rules.range(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var object = function object2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules.type(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable = function enumerable2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (value2 !== void 0) {
        rules[ENUM](rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var pattern = function pattern2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (!isEmptyValue(value2, "string")) {
        rules.pattern(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var date = function date2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
      if (!isEmptyValue(value2, "date")) {
        var dateObject;
        if (value2 instanceof Date) {
          dateObject = value2;
        } else {
          dateObject = new Date(value2);
        }
        rules.type(rule, dateObject, source, errors, options2);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options2);
        }
      }
    }
    callback(errors);
  };
  var required = function required2(rule, value2, callback, source, options2) {
    var errors = [];
    var type2 = Array.isArray(value2) ? "array" : typeof value2;
    rules.required(rule, value2, source, errors, options2, type2);
    callback(errors);
  };
  var type = function type2(rule, value2, callback, source, options2) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2, ruleType);
      if (!isEmptyValue(value2, ruleType)) {
        rules.type(rule, value2, source, errors, options2);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value2, callback, source, options2) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value2) && !rule.required) {
        return callback();
      }
      rules.required(rule, value2, source, errors, options2);
    }
    callback(errors);
  };
  var validators = {
    string,
    method,
    number,
    "boolean": _boolean,
    regexp,
    integer,
    "float": floatFn,
    array,
    object,
    "enum": enumerable,
    pattern,
    date,
    url: type,
    hex: type,
    email: type,
    required,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone2() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define2(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name2) {
        var item = rules2[name2];
        _this.rules[name2] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options2 = o;
      var callback = oc;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add2(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i2 = 0; i2 < results.length; i2++) {
          add2(results[i2]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options2.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options2.messages);
        options2.messages = messages$1;
      } else {
        options2.messages = this.messages();
      }
      var series = {};
      var keys = options2.keys || Object.keys(this.rules);
      keys.forEach(function(z) {
        var arr = _this2.rules[z];
        var value2 = source[z];
        arr.forEach(function(r) {
          var rule = r;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value2 = source[z] = rule.transform(value2);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule,
            value: value2,
            source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options2, function(data2, doIt) {
        var rule = data2.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data2.value);
        rule.field = data2.field;
        function addFullField(key2, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key2,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options2.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options2.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data2.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options2.error) {
                filledErrors = [options2.error(rule, format(options2.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data2.value).map(function(key2) {
                fieldsSchema[key2] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data2.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options2.messages);
            if (data2.rule.options) {
              data2.rule.options.messages = options2.messages;
              data2.rule.options.error = options2.error;
            }
            schema.validate(data2.value, data2.rule.options || options2, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data2.value, cb, data2.source, options2);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data2.value, cb, data2.source, options2);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options2.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf("message");
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type2, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type2] = validator;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;
  var SECRET = "NUT_FORM_INTERNAL";
  var FormStore = /* @__PURE__ */ function() {
    function FormStore2() {
      var _this = this;
      var _this1 = this;
      _class_call_check(this, FormStore2);
      var _this2 = this;
      _define_property(this, "initialValues", {});
      _define_property(this, "updateList", []);
      _define_property(this, "store", {});
      _define_property(this, "fieldEntities", []);
      _define_property(this, "callbacks", {});
      _define_property(this, "errors", {});
      _define_property(this, "registerField", function(field) {
        _this.fieldEntities.push(field);
        return function() {
          _this.fieldEntities = _this.fieldEntities.filter(function(item) {
            return item !== field;
          });
        };
      });
      _define_property(this, "getFieldValue", function(name2) {
        var _this_store;
        return (_this_store = _this.store) === null || _this_store === void 0 ? void 0 : _this_store[name2];
      });
      _define_property(this, "getFieldsValue", function(nameList) {
        if (typeof nameList === "boolean") {
          return JSON.parse(JSON.stringify(_this.store));
        }
        var fieldsValue = {};
        nameList.forEach(function(field) {
          fieldsValue[field] = _this.getFieldValue(field);
        });
        return fieldsValue;
      });
      _define_property(this, "setInitialValues", function(initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var nextStore = merge(initialValues, _this.store);
          _this.updateStore(nextStore);
          _this.notifyWatch();
        }
      });
      _define_property(this, "setFieldsValue", function(newStore) {
        var nextStore = recursive(true, _this.store, newStore);
        _this.updateStore(nextStore);
        _this.fieldEntities.forEach(function(entity) {
          var name2 = entity.props.name;
          Object.keys(newStore).forEach(function(key2) {
            if (key2 === name2) {
              entity.onStoreChange("update");
            }
          });
        });
        _this.updateList.forEach(function(item) {
          var shouldUpdate = item.condition;
          if (typeof item.condition === "function") {
            shouldUpdate = item.condition();
          }
          if (shouldUpdate) {
            item.entity.onStoreChange("update");
          }
        });
        _this.notifyWatch();
      });
      _define_property(this, "setFieldValue", function(name2, value2) {
        var store = _define_property({}, name2, value2);
        _this.setFieldsValue(store);
        _this.notifyWatch([
          name2
        ]);
      });
      _define_property(this, "setCallback", function(callback) {
        _this.callbacks = _object_spread({}, _this.callbacks, callback);
      });
      _define_property(this, "validateEntities", /* @__PURE__ */ function() {
        var _ref = _async_to_generator(function(entity, errs) {
          var _entity_props, name2, _entity_props_rules, rules2, descriptor, validator, _this_store, param, errors, _errs;
          return __generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                _entity_props = entity.props, name2 = _entity_props.name, _entity_props_rules = _entity_props.rules, rules2 = _entity_props_rules === void 0 ? [] : _entity_props_rules;
                if (!name2) {
                  console.warn("Form field missing name property");
                  return [
                    2
                  ];
                }
                descriptor = {};
                if (rules2.length) {
                  if (rules2.length > 1) {
                    descriptor[name2] = [];
                    rules2.forEach(function(v) {
                      descriptor[name2].push(v);
                    });
                  } else {
                    descriptor[name2] = rules2[0];
                  }
                }
                validator = new Schema(descriptor);
                _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  3,
                  4,
                  5
                ]);
                return [
                  4,
                  validator.validate(_define_property({}, name2, (_this_store = _this2.store) === null || _this_store === void 0 ? void 0 : _this_store[name2]))
                ];
              case 2:
                _state.sent();
                return [
                  3,
                  5
                ];
              case 3:
                param = _state.sent();
                errors = param.errors;
                if (errors) {
                  (_errs = errs).push.apply(_errs, _to_consumable_array(errors));
                  _this2.errors[name2] = errors;
                }
                return [
                  3,
                  5
                ];
              case 4:
                if (!errs || errs.length === 0) {
                  _this2.errors[name2] = [];
                }
                return [
                  7
                ];
              case 5:
                entity.onStoreChange("validate");
                return [
                  2
                ];
            }
          });
        });
        return function(entity, errs) {
          return _ref.apply(this, arguments);
        };
      }());
      _define_property(this, "validateFields", /* @__PURE__ */ function() {
        var _ref = _async_to_generator(function(nameList) {
          var filterEntities, errs;
          return __generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                filterEntities = [];
                if (!nameList || nameList.length === 0) {
                  filterEntities = _this2.fieldEntities;
                } else {
                  filterEntities = _this2.fieldEntities.filter(function(param) {
                    var name2 = param.props.name;
                    return nameList.includes(name2);
                  });
                }
                errs = [];
                return [
                  4,
                  Promise.all(filterEntities.map(/* @__PURE__ */ function() {
                    var _ref2 = _async_to_generator(function(entity) {
                      return __generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            return [
                              4,
                              _this2.validateEntities(entity, errs)
                            ];
                          case 1:
                            _state2.sent();
                            return [
                              2
                            ];
                        }
                      });
                    });
                    return function(entity) {
                      return _ref2.apply(this, arguments);
                    };
                  }()))
                ];
              case 1:
                _state.sent();
                return [
                  2,
                  errs
                ];
            }
          });
        });
        return function(nameList) {
          return _ref.apply(this, arguments);
        };
      }());
      _define_property(this, "submit", /* @__PURE__ */ _async_to_generator(function() {
        var errors, _this_callbacks_onFinish, _this_callbacks, _this_callbacks_onFinishFailed, _this_callbacks1;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                _this2.validateFields()
              ];
            case 1:
              errors = _state.sent();
              if (errors.length === 0) {
                (_this_callbacks_onFinish = (_this_callbacks = _this2.callbacks).onFinish) === null || _this_callbacks_onFinish === void 0 ? void 0 : _this_callbacks_onFinish.call(_this_callbacks, _this2.store);
              } else if (errors.length > 0) {
                (_this_callbacks_onFinishFailed = (_this_callbacks1 = _this2.callbacks).onFinishFailed) === null || _this_callbacks_onFinishFailed === void 0 ? void 0 : _this_callbacks_onFinishFailed.call(_this_callbacks1, _this2.store, errors);
              }
              return [
                2
              ];
          }
        });
      }));
      _define_property(this, "resetFields", function(namePaths) {
        if (namePaths && namePaths.length) {
          namePaths.forEach(function(path) {
            _this.errors[path] = null;
            _this.fieldEntities.forEach(function(entity) {
              var name2 = entity.props.name;
              if (name2 === path) {
                if (path in _this.initialValues) {
                  _this.updateStore(_define_property({}, path, _this.initialValues[path]));
                } else {
                  delete _this.store[path];
                }
                entity.onStoreChange("reset");
              }
            });
          });
        } else {
          var nextStore = merge({}, _this.initialValues);
          _this.updateStore(nextStore);
          _this.fieldEntities.forEach(function(entity) {
            entity.onStoreChange("reset");
          });
        }
      });
      _define_property(this, "registerUpdate", function(field, shouldUpdate) {
        _this.updateList.push({
          entity: field,
          condition: shouldUpdate
        });
        return function() {
          _this.updateList = _this.updateList.filter(function(i2) {
            return i2.entity !== field;
          });
        };
      });
      _define_property(this, "dispatch", function(param) {
        var name2 = param.name;
        _this.validateFields([
          name2
        ]);
      });
      _define_property(this, "getInternal", function(key2) {
        if (key2 === SECRET) {
          return {
            registerField: _this.registerField,
            setCallback: _this.setCallback,
            setInitialValues: _this.setInitialValues,
            dispatch: _this.dispatch,
            store: _this.store,
            fieldEntities: _this.fieldEntities,
            registerUpdate: _this.registerUpdate,
            registerWatch: _this.registerWatch
          };
        }
      });
      _define_property(this, "getForm", function() {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          setFieldsValue: _this.setFieldsValue,
          setFieldValue: _this.setFieldValue,
          resetFields: _this.resetFields,
          validateFields: _this.validateFields,
          submit: _this.submit,
          errors: _this.errors,
          getInternal: _this.getInternal
        };
      });
      _define_property(this, "watchList", []);
      _define_property(this, "registerWatch", function(callback) {
        _this.watchList.push(callback);
        return function() {
          _this.watchList = _this.watchList.filter(function(fn) {
            return fn !== callback;
          });
        };
      });
      _define_property(this, "notifyWatch", function() {
        var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (_this1.watchList.length) {
          var allValues;
          if (!namePath || namePath.length === 0) {
            allValues = _this1.getFieldsValue(true);
          } else {
            allValues = _this1.getFieldsValue(namePath);
          }
          _this1.watchList.forEach(function(callback) {
            callback(allValues, namePath);
          });
        }
      });
      this.callbacks = {
        onFinish: function() {
        },
        onFinishFailed: function() {
        }
      };
    }
    _create_class(FormStore2, [
      {
        key: "updateStore",
        value: function updateStore(nextStore) {
          this.store = nextStore;
        }
      }
    ]);
    return FormStore2;
  }();
  var useForm = function(form) {
    var formRef = React.useRef();
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        var formStore = new FormStore();
        formRef.current = formStore.getForm();
      }
    }
    return [
      formRef.current
    ];
  };
  var useWatch = function(path, form) {
    var formInstance = form.getInternal(SECRET);
    var _useState = _sliced_to_array(React.useState(), 2), value2 = _useState[0], setValue = _useState[1];
    React.useEffect(function() {
      var unsubscribe = formInstance.registerWatch(function(data2, namePath) {
        var value3 = data2[path];
        setValue(value3);
      });
      var initialValue = form.getFieldsValue(true);
      if (value2 !== initialValue[path]) {
        setValue(initialValue[path]);
      }
      return function() {
        return unsubscribe();
      };
    }, [
      form
    ]);
    return value2;
  };
  var defaultProps$_ = _object_spread_props(_object_spread({}, ComponentDefaults), {
    labelPosition: "right",
    starPosition: "left",
    disabled: false,
    divider: false,
    validateTrigger: "onChange",
    onReset: function() {
    },
    onSubmit: function() {
    },
    onFinish: function(values) {
    },
    onFinishFailed: function(values, errorFields) {
    }
  });
  var PositionInfo = {
    top: "form-layout-top",
    left: "form-layout-left",
    right: "form-layout-right"
  };
  var Form = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var classPrefix2 = "nut-form";
    var _$_object_spread = _object_spread({}, defaultProps$_, props), className = _$_object_spread.className, style = _$_object_spread.style, footer = _$_object_spread.footer, children = _$_object_spread.children, initialValues = _$_object_spread.initialValues, divider = _$_object_spread.divider, disabled = _$_object_spread.disabled, onFinish = _$_object_spread.onFinish, onFinishFailed = _$_object_spread.onFinishFailed, onSubmit = _$_object_spread.onSubmit, onReset = _$_object_spread.onReset, validateTrigger = _$_object_spread.validateTrigger, labelPosition = _$_object_spread.labelPosition, starPosition = _$_object_spread.starPosition, form = _$_object_spread.form;
    var formInstance;
    if (form !== void 0) {
      formInstance = form;
    } else {
      var _$ref;
      _$ref = _sliced_to_array(useForm(), 1), formInstance = _$ref[0];
    }
    React.useImperativeHandle(ref, function() {
      return formInstance;
    });
    formInstance.starPosition = starPosition;
    var submit = formInstance.submit, resetFields = formInstance.resetFields;
    var _formInstance_getInternal = formInstance.getInternal(SECRET), setCallback = _formInstance_getInternal.setCallback, setInitialValues = _formInstance_getInternal.setInitialValues;
    setCallback({
      onFinish,
      onFinishFailed
    });
    var mountRef = React.useRef(false);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    return /* @__PURE__ */ React.createElement("form", {
      className: classNames(classPrefix2, PositionInfo[labelPosition], className),
      style,
      onSubmit: function(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        submit();
        onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit();
      },
      onReset: function(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        resetFields();
        onReset === null || onReset === void 0 ? void 0 : onReset();
      }
    }, /* @__PURE__ */ React.createElement(Cell.Group, {
      divider
    }, /* @__PURE__ */ React.createElement(Context.Provider, {
      value: {
        formInstance,
        labelPosition,
        disabled,
        validateTrigger
      }
    }, children), footer ? /* @__PURE__ */ React.createElement(Cell, {
      className: "".concat(classPrefix2, "-footer")
    }, footer) : null));
  });
  Form.displayName = "NutForm";
  function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _get_prototype_of(o);
  }
  function _is_native_reflect_construct() {
    try {
      var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (_) {
    }
    return (_is_native_reflect_construct = function() {
      return !!result;
    })();
  }
  function _assert_this_initialized(self2) {
    if (self2 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self2;
  }
  function _possible_constructor_return(self2, call2) {
    if (call2 && (_type_of(call2) === "object" || typeof call2 === "function")) return call2;
    return _assert_this_initialized(self2);
  }
  function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(
      _this,
      _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args)
    );
  }
  function _set_prototype_of(o, p2) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _set_prototype_of(o, p2);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    if (superClass) _set_prototype_of(subClass, superClass);
  }
  var defaultProps$Z = _object_spread_props(_object_spread({}, ComponentDefaults), {
    required: false,
    name: "",
    label: "",
    rules: [
      {
        required: false,
        message: ""
      }
    ],
    errorMessageAlign: "left",
    shouldUpdate: false,
    noStyle: false
  });
  var FormItem = /* @__PURE__ */ function(_superClass) {
    _inherits(FormItem2, _superClass);
    function FormItem2(props) {
      _class_call_check(this, FormItem2);
      var _this;
      _this = _call_super(this, FormItem2, [
        props
      ]), _define_property(_this, "cancelRegister", void 0), _define_property(_this, "componentRef", void 0), _define_property(_this, "eventOff", void 0), // childrenvalueonChange
      _define_property(_this, "getControlled", function(children) {
        var _children_props;
        var _this_context_formInstance = _this.context.formInstance, setFieldsValue = _this_context_formInstance.setFieldsValue, getFieldValue = _this_context_formInstance.getFieldValue;
        var dispatch = _this.context.formInstance.getInternal(SECRET).dispatch;
        var _this_props = _this.props, _this_props_name = _this_props.name, name2 = _this_props_name === void 0 ? "" : _this_props_name;
        if (children === null || children === void 0 ? void 0 : (_children_props = children.props) === null || _children_props === void 0 ? void 0 : _children_props.defaultValue) {
          if (process.env.NODE_ENV !== "production") {
            console.warn("[NutUI] FormItem:", " initialValue  defaultValue");
          }
        }
        var fieldValue = getFieldValue(name2);
        var _obj;
        var controlled = _object_spread_props(_object_spread({}, children.props), (_obj = {
          className: children.props.className
        }, _define_property(_obj, _this.props.valuePropName || "value", fieldValue !== void 0 ? fieldValue : _this.props.initialValue), _define_property(_obj, _this.props.trigger || "onChange", function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var originOnChange = children.props[_this.props.trigger || "onChange"];
          if (originOnChange) {
            originOnChange.apply(void 0, _to_consumable_array(args));
          }
          var _args = _sliced_to_array(args, 1), next = _args[0];
          if (_this.props.getValueFromEvent) {
            var _this_props2;
            next = (_this_props2 = _this.props).getValueFromEvent.apply(_this_props2, _to_consumable_array(args));
          }
          setFieldsValue(_define_property({}, name2, next));
        }), _obj));
        var validateTrigger = _this.props.validateTrigger;
        var mergedValidateTrigger = validateTrigger || _this.context.validateTrigger;
        var validateTriggers = toArray$1(mergedValidateTrigger);
        validateTriggers.forEach(function(trigger) {
          var originTrigger = controlled[trigger];
          controlled[trigger] = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (originTrigger) {
              originTrigger.apply(void 0, _to_consumable_array(args));
            }
            if (_this.props.rules && _this.props.rules.length) {
              dispatch({
                name: _this.props.name
              });
            }
          };
        });
        if (isForwardRefComponent(children)) {
          controlled.ref = function(componentInstance) {
            var originRef = children.ref;
            if (originRef) {
              if (typeof originRef === "function") {
                originRef(componentInstance);
              }
              if ("current" in originRef) {
                originRef.current = componentInstance;
              }
            }
            _this.componentRef = componentInstance;
          };
        }
        return controlled;
      }), _define_property(_this, "refresh", function() {
        _this.setState(function(param) {
          var resetCount = param.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      }), _define_property(_this, "onStoreChange", function(type2) {
        if (type2 === "reset") {
          _this.context.formInstance.errors[_this.props.name] = [];
          _this.refresh();
        } else {
          _this.forceUpdate();
        }
      }), _define_property(_this, "renderLayout", function(childNode) {
        var _$_object_spread = _object_spread({}, defaultProps$Z, _this.props), label = _$_object_spread.label, name2 = _$_object_spread.name, required2 = _$_object_spread.required, rules2 = _$_object_spread.rules, className = _$_object_spread.className, style = _$_object_spread.style, errorMessageAlign = _$_object_spread.errorMessageAlign, align = _$_object_spread.align;
        var requiredInRules = rules2 === null || rules2 === void 0 ? void 0 : rules2.some(function(rule) {
          return rule.required;
        });
        var item = name2 ? _this.context.formInstance.errors[name2] : [];
        var starPosition = _this.context.formInstance.starPosition;
        var renderStar = (required2 || requiredInRules) && /* @__PURE__ */ React.createElement("div", {
          className: "nut-form-item-label-required required"
        }, "*");
        var renderLabel = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
          className: "nut-form-item-labeltxt"
        }, starPosition === "left" ? renderStar : null, label), starPosition === "right" ? renderStar : null);
        return /* @__PURE__ */ React.createElement(Cell, {
          className: "".concat(_this.getClassNameWithDirection("nut-form-item"), " ").concat(className),
          style,
          align,
          onClick: function(e2) {
            return _this.props.onClick && _this.props.onClick(e2, _this.componentRef);
          }
        }, label ? /* @__PURE__ */ React.createElement("div", {
          className: "nut-cell-title ".concat(_this.getClassNameWithDirection("nut-form-item-label"))
        }, renderLabel) : null, /* @__PURE__ */ React.createElement("div", {
          className: "nut-cell-value ".concat(_this.getClassNameWithDirection("nut-form-item-body"))
        }, /* @__PURE__ */ React.createElement("div", {
          className: "nut-form-item-body-slots"
        }, childNode), item && item.length > 0 && /* @__PURE__ */ React.createElement("div", {
          className: "nut-form-item-body-tips",
          style: {
            textAlign: errorMessageAlign
          }
        }, item[0].message)));
      });
      _this.componentRef = /* @__PURE__ */ React.createRef();
      _this.state = {
        resetCount: 1
      };
      return _this;
    }
    _create_class(FormItem2, [
      {
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this_context_formInstance_getInternal = this.context.formInstance.getInternal(SECRET), _this_context_formInstance_getInternal_store = _this_context_formInstance_getInternal.store, store = _this_context_formInstance_getInternal_store === void 0 ? {} : _this_context_formInstance_getInternal_store, setInitialValues = _this_context_formInstance_getInternal.setInitialValues;
          if (this.props.initialValue && this.props.name && !Object.keys(store).includes(this.props.name)) {
            setInitialValues(_object_spread_props(_object_spread({}, store), _define_property({}, this.props.name, this.props.initialValue)), true);
          }
          var _this_context_formInstance_getInternal1 = this.context.formInstance.getInternal(SECRET), registerField = _this_context_formInstance_getInternal1.registerField, registerUpdate = _this_context_formInstance_getInternal1.registerUpdate;
          this.cancelRegister = registerField(this);
          this.eventOff = registerUpdate(this, this.props.shouldUpdate);
        }
      },
      {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this.cancelRegister) {
            this.cancelRegister();
          }
          if (this.eventOff) {
            this.eventOff();
          }
        }
      },
      {
        key: "getClassNameWithDirection",
        value: function getClassNameWithDirection(className) {
          if (className && this.context.labelPosition) {
            return "".concat(className, " ").concat(className, "-").concat(this.context.labelPosition);
          }
          return className;
        }
      },
      {
        key: "render",
        value: function render2() {
          var children = this.props.children;
          var child = Array.isArray(children) ? children[0] : children;
          var returnChildNode;
          if (!this.props.shouldUpdate) {
            returnChildNode = /* @__PURE__ */ React.cloneElement(child, this.getControlled(child));
          } else {
            returnChildNode = child(this.context.formInstance);
          }
          return /* @__PURE__ */ React.createElement(React.Fragment, {
            key: this.state.resetCount
          }, /* @__PURE__ */ React.createElement("div", {
            className: this.context.disabled ? "nut-form-item-disabled" : ""
          }, this.props.noStyle ? returnChildNode : this.renderLayout(returnChildNode)));
        }
      }
    ]);
    return FormItem2;
  }(React.Component);
  _define_property(FormItem, "defaultProps", defaultProps$Z);
  _define_property(FormItem, "contextType", Context);
  var InnerForm = Form;
  InnerForm.Item = FormItem;
  InnerForm.useForm = useForm;
  InnerForm.useWatch = useWatch;
  function trimExtraChar(value2, char, regExp) {
    var index2 = value2.indexOf(char);
    if (index2 === -1) {
      return value2;
    }
    if (char === "-" && index2 !== 0) {
      return value2.slice(0, index2);
    }
    return value2.slice(0, index2 + 1) + value2.slice(index2).replace(regExp, "");
  }
  function formatNumber(value2) {
    var allowDot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, allowMinus = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (allowDot) {
      value2 = trimExtraChar(value2, ".", /\./g);
    } else {
      value2 = value2.split(".")[0];
    }
    if (allowMinus) {
      value2 = trimExtraChar(value2, "-", /-/g);
    } else {
      value2 = value2.replace(/-/, "");
    }
    var regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value2.replace(regExp, "");
  }
  var defaultProps$Y = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "text",
    name: "",
    placeholder: void 0,
    confirmType: "done",
    align: "left",
    required: false,
    disabled: false,
    readOnly: false,
    maxLength: 9999,
    clearable: false,
    clearIcon: null,
    formatTrigger: "onChange",
    autoFocus: false,
    plain: false
  });
  var Input = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var rtl = useRtl();
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$Y, props), type2 = _ref.type, name2 = _ref.name, placeholder = _ref.placeholder, align = _ref.align, disabled = _ref.disabled, readOnly = _ref.readOnly, maxLength = _ref.maxLength, clearable = _ref.clearable, clearIcon = _ref.clearIcon, formatTrigger = _ref.formatTrigger, autoFocus = _ref.autoFocus, style = _ref.style, className = _ref.className, onChange = _ref.onChange, onFocus = _ref.onFocus, onClear = _ref.onClear, formatter = _ref.formatter, onClick = _ref.onClick, confirmType = _ref.confirmType, plain = _ref.plain, defaultValue = _ref.defaultValue, _value = _ref.value, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, rest = _object_without_properties(_ref, [
      "type",
      "name",
      "placeholder",
      "align",
      "disabled",
      "readOnly",
      "maxLength",
      "clearable",
      "clearIcon",
      "formatTrigger",
      "autoFocus",
      "style",
      "className",
      "onChange",
      "onFocus",
      "onClear",
      "formatter",
      "onClick",
      "confirmType",
      "plain",
      "defaultValue",
      "value",
      "onCompositionStart",
      "onCompositionEnd"
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: _value,
      defaultValue,
      finalValue: "",
      onChange
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var inputRef = React.useRef(null);
    var composingRef = React.useRef(false);
    var _useState = _sliced_to_array(React.useState(false), 2), active2 = _useState[0], setActive = _useState[1];
    React.useImperativeHandle(ref, function() {
      return {
        clear: function() {
          return setValue("");
        },
        focus: function() {
          var _inputRef_current;
          return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
        },
        blur: function() {
          var _inputRef_current;
          return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.blur();
        },
        get nativeElement() {
          return inputRef.current;
        }
      };
    });
    var getInputClass = React.useCallback(function() {
      var classPrefix2 = "nut-input";
      return [
        classPrefix2,
        "".concat(disabled ? "".concat(classPrefix2, "-disabled") : ""),
        readOnly ? "".concat(classPrefix2, "-readonly") : "",
        "".concat(plain ? "".concat(classPrefix2, "-plain") : "".concat(classPrefix2, "-container"))
      ].filter(Boolean).join(" ");
    }, [
      disabled,
      readOnly,
      plain
    ]);
    var handleValueUpdate = function(inputValue, trigger) {
      var updatedValue = inputValue;
      if (type2 === "number") updatedValue = formatNumber(updatedValue, false, true);
      if (type2 === "digit") updatedValue = formatNumber(updatedValue, true, true);
      if (formatter && trigger === formatTrigger) updatedValue = formatter(updatedValue);
      setValue(updatedValue);
      if (trigger !== "onChange") {
        var eventHandler = props[trigger];
        eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler(updatedValue);
      }
    };
    var handleFocus = function(event) {
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(event.target.value);
      setActive(true);
    };
    var handleBlur = function(event) {
      handleValueUpdate(event.target.value, "onBlur");
      setTimeout(function() {
        return setActive(false);
      }, 200);
    };
    var handleInputChange = function(event) {
      handleValueUpdate(event.target.value, "onChange");
    };
    var getInputType = function(inputType) {
      if (inputType === "digit") return "text";
      if (inputType === "number") return "tel";
      return inputType;
    };
    var getTextAlign = function() {
      if (rtl) {
        if (align === "right") return "left";
        if (align === "left") return "right";
      }
      return align;
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: "".concat(getInputClass(), " ").concat(className || ""),
      style,
      onClick
    }, /* @__PURE__ */ React.createElement("input", _object_spread_props(_object_spread({}, rest), {
      ref: inputRef,
      name: name2,
      className: "nut-input-native",
      style: {
        textAlign: getTextAlign()
      },
      type: getInputType(type2),
      maxLength,
      placeholder: placeholder === void 0 ? locale.placeholder : placeholder,
      disabled,
      readOnly,
      value: value2,
      autoFocus,
      enterKeyHint: confirmType,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onChange: handleInputChange,
      onCompositionStart: function(e2) {
        composingRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      },
      onCompositionEnd: function(e2) {
        composingRef.current = false;
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      }
    })), clearable && !readOnly && active2 && value2.length > 0 && /* @__PURE__ */ React.createElement("span", {
      style: {
        display: "flex",
        alignItems: "center",
        cursor: "pointer"
      },
      onClick: function() {
        if (!disabled) {
          setValue("");
          onClear === null || onClear === void 0 ? void 0 : onClear("");
        }
      }
    }, clearIcon || /* @__PURE__ */ React.createElement(n$2, {
      className: "nut-input-clear"
    })));
  });
  Input.displayName = "NutInput";
  var defaultProps$X = _object_spread_props(_object_spread({}, ComponentDefaults), {
    disabled: false,
    readOnly: false,
    allowEmpty: false,
    min: 1,
    max: 9999,
    step: 1,
    digits: 0,
    select: true,
    beforeChange: function(value2) {
      return Promise.resolve(true);
    }
  });
  var classPrefix$h = "nut-inputnumber";
  var InputNumber = function(props) {
    var _ref = _object_spread({}, defaultProps$X, props);
    _ref.children;
    var disabled = _ref.disabled, min = _ref.min, max = _ref.max, readOnly = _ref.readOnly, value2 = _ref.value, defaultValue = _ref.defaultValue, allowEmpty = _ref.allowEmpty, digits = _ref.digits, step = _ref.step, select = _ref.select, className = _ref.className, style = _ref.style, formatter = _ref.formatter, onPlus = _ref.onPlus, onMinus = _ref.onMinus, onOverlimit = _ref.onOverlimit, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onChange = _ref.onChange, beforeChange = _ref.beforeChange, restProps = _object_without_properties(_ref, [
      "children",
      "disabled",
      "min",
      "max",
      "readOnly",
      "value",
      "defaultValue",
      "allowEmpty",
      "digits",
      "step",
      "select",
      "className",
      "style",
      "formatter",
      "onPlus",
      "onMinus",
      "onOverlimit",
      "onBlur",
      "onFocus",
      "onChange",
      "beforeChange"
    ]);
    var classes = classNames(classPrefix$h, className, _define_property({}, "".concat(classPrefix$h, "-disabled"), disabled));
    var _useState = _sliced_to_array(React.useState(false), 2), focused = _useState[0], setFocused = _useState[1];
    var inputRef = React.useRef(null);
    React.useEffect(function() {
      if (select && focused) {
        var _inputRef_current_select, _inputRef_current;
        (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : (_inputRef_current_select = _inputRef_current.select) === null || _inputRef_current_select === void 0 ? void 0 : _inputRef_current_select.call(_inputRef_current);
      }
    }, [
      select,
      focused
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: typeof value2 === "string" ? parseFloat(value2) : value2,
      defaultValue: typeof defaultValue === "string" ? parseFloat(defaultValue) : defaultValue,
      finalValue: 0
    }), 2), shadowValue = _usePropsValue[0], setShadowValue = _usePropsValue[1];
    var format2 = function(value3) {
      if (value3 === null) return "";
      var fixedValue = bound(typeof value3 === "string" ? parseFloat(value3) : value3, Number(min), Number(max));
      if (formatter) {
        return formatter(fixedValue);
      }
      if (digits) {
        return fixedValue.toFixed(digits).toString();
      }
      return fixedValue.toString();
    };
    var _useState1 = _sliced_to_array(React.useState(format2(shadowValue)), 2), inputValue = _useState1[0], setInputValue = _useState1[1];
    React.useEffect(function() {
      if (!focused) {
        setInputValue(format2(shadowValue));
      }
    }, [
      focused,
      shadowValue
    ]);
    var calcNextValue = function(current, stepValue, symbol) {
      var dig = digits + 1;
      var currentValue = parseFloat(current || "0");
      var stepAmount = parseFloat(stepValue) * symbol;
      return (currentValue * dig + stepAmount * dig) / dig;
    };
    var update2 = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function(negative, e2) {
        var shouldOverBoundary, maybeResume, nextValue;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (step === void 0) return [
                2
              ];
              negative ? onMinus === null || onMinus === void 0 ? void 0 : onMinus(e2) : onPlus === null || onPlus === void 0 ? void 0 : onPlus(e2);
              shouldOverBoundary = calcNextValue(bound(Number(shadowValue), Number(min), Number(max)), step, negative ? -1 : 1);
              return [
                4,
                beforeChange(Number(shouldOverBoundary))
              ];
            case 1:
              maybeResume = _state.sent();
              if (!maybeResume) return [
                2
              ];
              nextValue = bound(shouldOverBoundary, Number(min), Number(max));
              setShadowValue(nextValue);
              if (negative ? shouldOverBoundary < Number(min) : shouldOverBoundary > Number(max)) {
                onOverlimit === null || onOverlimit === void 0 ? void 0 : onOverlimit(e2);
              } else {
                onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, e2);
              }
              return [
                2
              ];
          }
        });
      });
      return function update3(negative, e2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var handleReduce = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function(e2) {
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (disabled) return [
                2
              ];
              return [
                4,
                update2(true, e2)
              ];
            case 1:
              _state.sent();
              return [
                2
              ];
          }
        });
      });
      return function handleReduce2(e2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var handlePlus = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function(e2) {
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (disabled) return [
                2
              ];
              return [
                4,
                update2(false, e2)
              ];
            case 1:
              _state.sent();
              return [
                2
              ];
          }
        });
      });
      return function handlePlus2(e2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var parseValue = function(text2) {
      if (text2 === "") return null;
      if (text2 === "-") return null;
      return text2;
    };
    var handleInputChange = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function(e2) {
        var valueStr, maybeResume;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              setInputValue(e2.target.value);
              valueStr = parseValue(e2.target.value);
              return [
                4,
                beforeChange(Number(valueStr))
              ];
            case 1:
              maybeResume = _state.sent();
              if (!maybeResume) return [
                2
              ];
              setShadowValue(
                // eslint-disable-next-line no-nested-ternary
                valueStr === null ? allowEmpty ? null : defaultValue : valueStr
              );
              if (valueStr !== null && (Number(valueStr) < Number(min) || Number(valueStr) > Number(max))) {
                onOverlimit === null || onOverlimit === void 0 ? void 0 : onOverlimit(e2);
              } else {
                onChange === null || onChange === void 0 ? void 0 : onChange(parseFloat(valueStr || "0").toFixed(digits), e2);
              }
              return [
                2
              ];
          }
        });
      });
      return function handleInputChange2(e2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var handleFocus = function(e2) {
      setFocused(true);
      setInputValue(shadowValue !== void 0 && shadowValue !== null ? bound(Number(shadowValue), Number(min), Number(max)).toString() : "");
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
    };
    var handleBlur = function(e2) {
      setFocused(false);
      onBlur && onBlur(e2);
      var valueStr = parseValue(e2.target.value);
      onChange === null || onChange === void 0 ? void 0 : onChange(parseFloat(valueStr || "0").toFixed(digits), e2);
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      style
    }, restProps), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$h, "-minus"),
      onClick: handleReduce
    }, /* @__PURE__ */ React.createElement(i, {
      className: classNames("".concat(classPrefix$h, "-icon ").concat(classPrefix$h, "-icon-minus"), _define_property({}, "".concat(classPrefix$h, "-icon-disabled"), Number(shadowValue) <= Number(min) || disabled))
    })), /* @__PURE__ */ React.createElement("input", {
      className: classNames("".concat(classPrefix$h, "-input"), _define_property({}, "".concat(classPrefix$h, "-input-disabled"), disabled)),
      ref: inputRef,
      inputMode: "decimal",
      disabled,
      readOnly,
      value: inputValue,
      onInput: handleInputChange,
      onBlur: handleBlur,
      onFocus: handleFocus
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$h, "-add"),
      onClick: handlePlus
    }, /* @__PURE__ */ React.createElement(d$2, {
      className: classNames("".concat(classPrefix$h, "-icon ").concat(classPrefix$h, "-icon-plus"), _define_property({}, "".concat(classPrefix$h, "-icon-disabled"), Number(shadowValue) >= Number(max) || disabled))
    })));
  };
  InputNumber.displayName = "NutInputNumber";
  var getTargetElement = function(target) {
    var targetElement;
    if (isFunction(target)) {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  };
  function useClickAway(onClickAway, target) {
    var eventName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "click", useCapture = arguments.length > 3 ? arguments[3] : void 0, isListener = arguments.length > 4 ? arguments[4] : void 0, outerVar = arguments.length > 5 ? arguments[5] : void 0;
    var handler = function(event) {
      var targets = Array.isArray(target) ? target : [
        target
      ];
      if (targets.some(function(item) {
        var targetElement = getTargetElement(item);
        return !targetElement || targetElement.contains(event.target);
      })) {
        return;
      }
      if (outerVar) {
        onClickAway();
      }
    };
    React.useEffect(function() {
      if (isListener) {
        window.addEventListener(eventName, handler, useCapture);
      } else {
        window.removeEventListener(eventName, handler, useCapture);
      }
      return function() {
        window.removeEventListener(eventName, handler, useCapture);
      };
    }, [
      target
    ]);
  }
  var defaultProps$W = _object_spread_props(_object_spread({}, ComponentDefaults), {
    titleIcon: null,
    columns: 1,
    direction: "down",
    icon: null,
    closeOnClickAway: true,
    activeTitleClass: "",
    inactiveTitleClass: "",
    onChange: function(value2) {
      return void 0;
    }
  });
  var MenuItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _$_object_spread = _object_spread({}, defaultProps$W, props), className = _$_object_spread.className, style = _$_object_spread.style, options2 = _$_object_spread.options, value2 = _$_object_spread.value, defaultValue = _$_object_spread.defaultValue, columns = _$_object_spread.columns, title = _$_object_spread.title, icon = _$_object_spread.icon, direction = _$_object_spread.direction, onChange = _$_object_spread.onChange, activeTitleClass = _$_object_spread.activeTitleClass, inactiveTitleClass = _$_object_spread.inactiveTitleClass, closeOnClickAway = _$_object_spread.closeOnClickAway, children = _$_object_spread.children, activeColor = _$_object_spread.activeColor, show2 = _$_object_spread.show, parent2 = _$_object_spread.parent, index2 = _$_object_spread.index;
    var _useState = _sliced_to_array(React.useState(show2), 2), showPopup = _useState[0], setShowPopup = _useState[1];
    var _usePropsValue = _sliced_to_array(usePropsValue({
      defaultValue,
      value: value2,
      finalValue: void 0,
      onChange: function(v) {
        var _options_filter = _sliced_to_array(options2.filter(function(o) {
          return o.value === v;
        }), 1), option = _options_filter[0];
        onChange === null || onChange === void 0 ? void 0 : onChange(option);
      }
    }), 2), innerValue = _usePropsValue[0], setValue = _usePropsValue[1];
    React.useEffect(function() {
      setShowPopup(show2);
    }, [
      show2
    ]);
    var getParentOffset = React.useCallback(function() {
      setTimeout(function() {
        var p2 = parent2.menuRef.current;
        if (p2) {
          var rect = p2.getBoundingClientRect();
          setPosition({
            height: rect.height,
            top: rect.top
          });
        }
      });
    }, [
      parent2.menuRef
    ]);
    React.useEffect(function() {
      getParentOffset();
    }, [
      showPopup,
      getParentOffset
    ]);
    React.useImperativeHandle(ref, function() {
      return {
        toggle: function(s2) {
          var from = "REF";
          s2 ? parent2.toggleMenuItem(index2, from) : parent2.hideMenuItem(index2, from);
        }
      };
    });
    var getIconCName = function(optionVal, value3) {
      var _obj;
      return classNames((_obj = {}, _define_property(_obj, activeTitleClass, optionVal === value3), _define_property(_obj, inactiveTitleClass, optionVal !== value3), _obj));
    };
    var setTitle = function(text2) {
      if (!title) {
        parent2.updateTitle(text2, index2);
      }
    };
    var handleClick = function(item) {
      parent2.toggleMenuItem(index2);
      setTitle(item.text);
      setValue(item.value);
    };
    var isShow = function() {
      if (showPopup) return {};
      return {
        display: "none"
      };
    };
    var _useState1 = _sliced_to_array(React.useState({
      top: 0,
      height: 0
    }), 2), position2 = _useState1[0], setPosition = _useState1[1];
    var scrollParent = React.useMemo(function() {
      return getScrollParent(parent2.menuRef, window);
    }, [
      parent2.menuRef
    ]);
    React.useEffect(function() {
      if (!parent2.lockScroll) {
        scrollParent === null || scrollParent === void 0 ? void 0 : scrollParent.addEventListener("scroll", getParentOffset, false);
        return function() {
          scrollParent === null || scrollParent === void 0 ? void 0 : scrollParent.removeEventListener("scroll", getParentOffset, false);
        };
      }
    }, [
      parent2.lockScroll,
      scrollParent,
      getParentOffset
    ]);
    var getPosition = function() {
      return direction === "down" ? {
        top: "".concat(position2.top + position2.height, "px"),
        bottom: "0",
        height: "initial"
      } : {
        bottom: "".concat(window.innerHeight - position2.top, "px"),
        top: "auto",
        height: "initial"
      };
    };
    var micRef = React.useRef(null);
    var cssRef = React.useRef(null);
    var targetSet = [
      micRef.current
    ];
    useClickAway(
      function() {
        parent2.hideMenuItem(index2);
      },
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      targetSet,
      "click",
      false,
      showPopup,
      closeOnClickAway
    );
    return /* @__PURE__ */ React.createElement("div", {
      className: "nut-menu-container",
      ref: micRef
    }, parent2.overlay ? /* @__PURE__ */ React.createElement(Overlay, {
      className: "nut-menu-container-overlay",
      style: getPosition(),
      lockScroll: parent2.lockScroll,
      visible: showPopup,
      closeOnOverlayClick: parent2.closeOnOverlayClick,
      onClick: function() {
        parent2.closeOnOverlayClick && parent2.hideMenuItem(index2);
      }
    }) : null, /* @__PURE__ */ React.createElement("div", {
      className: classNames({
        "nut-menu-container-wrap": direction === "down",
        "nut-menu-container-wrap-up": direction !== "down"
      }, className),
      style: _object_spread({}, style, isShow())
    }, /* @__PURE__ */ React.createElement(CSSTransition, {
      nodeRef: cssRef,
      in: showPopup,
      timeout: 100,
      classNames: direction === "down" ? "nut-menu-container-down" : "nut-menu-container-up"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "nut-menu-container-content"
    }, options2 === null || options2 === void 0 ? void 0 : options2.map(function(item) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "nut-menu-container-item ".concat(classNames({
          active: item.value === innerValue
        })),
        key: item.text,
        style: {
          flexBasis: "".concat(100 / columns, "%")
        },
        onClick: function() {
          handleClick(item);
        }
      }, item.value === innerValue ? /* @__PURE__ */ React.createElement("i", {
        className: "nut-menu-container-item-icon"
      }, icon || /* @__PURE__ */ React.createElement(d$6, {
        color: activeColor,
        className: getIconCName(item.value, value2)
      })) : null, /* @__PURE__ */ React.createElement("div", {
        className: "nut-menu-container-item-title ".concat(getIconCName(item.value, value2)),
        style: {
          color: "".concat(item.value === innerValue ? activeColor : "")
        }
      }, item.text));
    }), children))));
  });
  MenuItem.displayName = "NutMenuItem";
  var defaultProps$V = _object_spread_props(_object_spread({}, ComponentDefaults), {
    activeColor: "",
    closeOnOverlayClick: true,
    scrollFixed: false,
    lockScroll: true,
    overlay: true,
    icon: null,
    onOpen: function(index2, from) {
    },
    onClose: function(index2, from) {
    }
  });
  var Menu = function(props) {
    var _ref = _object_spread({}, defaultProps$V, props), className = _ref.className, icon = _ref.icon, scrollFixed = _ref.scrollFixed, lockScroll = _ref.lockScroll, overlay = _ref.overlay, closeOnOverlayClick = _ref.closeOnOverlayClick, children = _ref.children, activeColor = _ref.activeColor, onClose = _ref.onClose, onOpen = _ref.onOpen, rest = _object_without_properties(_ref, [
      "className",
      "icon",
      "scrollFixed",
      "lockScroll",
      "overlay",
      "closeOnOverlayClick",
      "children",
      "activeColor",
      "onClose",
      "onOpen"
    ]);
    var menuRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState([]), 2), showMenuItem = _useState[0], setShowMenuItem = _useState[1];
    var _useState1 = _sliced_to_array(React.useState([]), 2), menuItemTitle = _useState1[0], setMenuItemTitle = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(false), 2), isScrollFixed = _useState2[0], setIsScrollFixed = _useState2[1];
    var cls = classNames("nut-menu", className, {
      "scroll-fixed": isScrollFixed
    });
    var getScrollTop = function(el) {
      return Math.max(0, el === window ? window.scrollY : el.scrollTop);
    };
    var onScroll = React.useCallback(function() {
      var scrollTop = getScrollTop(window);
      var isFixed = scrollTop > (typeof scrollFixed === "boolean" ? 30 : Number(scrollFixed));
      setIsScrollFixed(isFixed);
    }, [
      scrollFixed
    ]);
    React.useEffect(function() {
      if (scrollFixed) {
        window.addEventListener("scroll", onScroll);
      }
      return function() {
        return window.removeEventListener("scroll", onScroll);
      };
    }, [
      scrollFixed,
      onScroll
    ]);
    var toggleMenuItem = function(index2) {
      var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "NORMAL";
      showMenuItem[index2] = !showMenuItem[index2];
      if (showMenuItem[index2]) {
        onOpen && onOpen(index2, from);
      } else {
        onClose && onClose(index2, from);
      }
      var temp = showMenuItem.map(function(i2, idx) {
        return idx === index2 ? i2 : false;
      });
      setShowMenuItem(_to_consumable_array(temp));
    };
    var hideMenuItem = function(index2) {
      var from = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "NORMAL";
      showMenuItem[index2] = false;
      setShowMenuItem(_to_consumable_array(showMenuItem));
      onClose && onClose(index2, from);
    };
    var updateTitle = function(text2, index2) {
      menuItemTitle[index2] = text2;
      setMenuItemTitle(_to_consumable_array(menuItemTitle));
    };
    var cloneChildren = function() {
      return React.Children.map(children, function(child, index2) {
        return /* @__PURE__ */ React.cloneElement(child, _object_spread_props(_object_spread({}, child.props), {
          show: showMenuItem[index2],
          index: index2,
          activeColor,
          parent: {
            closeOnOverlayClick,
            overlay,
            lockScroll,
            toggleMenuItem,
            updateTitle,
            hideMenuItem,
            menuRef
          }
        }));
      });
    };
    var menuTitle = function() {
      return React.Children.map(children, function(child, index2) {
        if (/* @__PURE__ */ React.isValidElement(child)) {
          var _child_props = child.props, title = _child_props.title, titleIcon = _child_props.titleIcon, options2 = _child_props.options, value2 = _child_props.value, defaultValue = _child_props.defaultValue, disabled = _child_props.disabled, direction = _child_props.direction;
          var selected = options2 === null || options2 === void 0 ? void 0 : options2.filter(function(option) {
            return option.value === (value2 !== void 0 ? value2 : defaultValue);
          });
          var finallyTitle = function() {
            if (title) return title;
            if (menuItemTitle && menuItemTitle[index2]) return menuItemTitle[index2];
            if (selected && selected.length && selected[0].text) return selected[0].text;
            return "";
          };
          var finallyIcon = function() {
            if (titleIcon) return titleIcon;
            if (icon) return icon;
            return direction === "up" ? /* @__PURE__ */ React.createElement(p$3, {
              className: "nut-menu-title-icon",
              width: "12px",
              height: "12px"
            }) : /* @__PURE__ */ React.createElement(l$1, {
              className: "nut-menu-title-icon",
              width: "12px",
              height: "12px"
            });
          };
          return /* @__PURE__ */ React.createElement("div", {
            className: classNames("nut-menu-title", "nut-menu-title-".concat(index2), {
              active: showMenuItem[index2],
              disabled
            }),
            style: {
              color: showMenuItem[index2] ? activeColor : ""
            },
            key: index2,
            onClick: function(e2) {
              e2.stopPropagation();
              if ((!options2 || !options2.length) && !child.props.children) return;
              !disabled && toggleMenuItem(index2);
            }
          }, /* @__PURE__ */ React.createElement("div", {
            className: "nut-menu-title-text"
          }, finallyTitle()), finallyIcon());
        }
        return null;
      });
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({}, rest), {
      className: cls,
      ref: menuRef
    }), /* @__PURE__ */ React.createElement("div", {
      className: classNames("nut-menu-bar", {
        opened: showMenuItem.includes(true)
      })
    }, menuTitle()), cloneChildren());
  };
  Menu.displayName = "NutMenu";
  Menu.Item = MenuItem;
  var defaultProps$U = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    rightActions: "",
    type: "default",
    custom: [],
    random: false,
    onClose: function() {
    }
  });
  var NumberKeyboard = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$U, props), title = _ref.title, rightActions = _ref.rightActions, confirmText = _ref.confirmText, visible = _ref.visible, type2 = _ref.type, custom = _ref.custom, random2 = _ref.random, style = _ref.style, className = _ref.className, onChange = _ref.onChange, onDelete = _ref.onDelete, onClose = _ref.onClose, onConfirm = _ref.onConfirm, rest = _object_without_properties(_ref, [
      "title",
      "rightActions",
      "confirmText",
      "visible",
      "type",
      "custom",
      "random",
      "style",
      "className",
      "onChange",
      "onDelete",
      "onClose",
      "onConfirm"
    ]);
    var classPrefix2 = "nut-numberkeyboard";
    var getBasicKeys = function() {
      var keys = new Array(9).fill(0).map(function(_, index2) {
        return {
          id: String(index2 + 1),
          type: "num"
        };
      });
      return random2 ? keys.sort(function() {
        return Math.random() > 0.5 ? 1 : -1;
      }) : keys;
    };
    var getCustomKeys = function() {
      var customKeys = [
        {
          id: "close",
          type: "close"
        },
        {
          id: "0",
          type: "num"
        },
        {
          id: "delete",
          type: "delete"
        }
      ];
      if (!custom) return customKeys;
      if (custom.length > 0) {
        customKeys[0] = {
          id: custom[0],
          type: "custom"
        };
      }
      if (custom.length > 1) {
        customKeys[2] = {
          id: custom[1],
          type: "custom"
        };
      }
      return customKeys;
    };
    var keysList = React.useMemo(function() {
      return _to_consumable_array(getBasicKeys()).concat(_to_consumable_array(getCustomKeys()));
    }, [
      type2,
      random2,
      custom
    ]);
    var DeleteIcon = function() {
      return /* @__PURE__ */ React.createElement("svg", {
        viewBox: "0 0 1024 1024",
        width: "28",
        height: "28"
      }, /* @__PURE__ */ React.createElement("path", {
        d: "M875.594 186.122H390.803a51.162 51.162 0 0 0-36.18 14.986L79.91 475.821a51.166 51.166 0 0 0 0 72.358l274.714 274.712a51.164 51.164 0 0 0 36.179 14.986h484.791c46.033 0 83.484-37.45 83.484-83.483V269.606c.001-46.033-37.45-83.484-83.483-83.484zm32.32 568.274c0 17.85-14.473 32.318-32.32 32.318H390.803L116.089 512l274.714-274.714h484.791c17.849 0 32.32 14.47 32.32 32.32v484.789z",
        fill: "currentColor"
      }), /* @__PURE__ */ React.createElement("path", {
        d: "M753.945 360.214l-121.43 121.429-121.43-121.429s-16.062-8.224-30.356 6.072c-14.295 14.295-6.073 30.357-6.073 30.357l121.43 121.428L486.8 627.357s-8.222 16.062 6.072 30.357c14.297 14.296 30.358 6.072 30.358 6.072l109.286-109.285 109.286 109.285s16.062 8.224 30.357-6.072c14.295-14.295 6.07-30.357 6.07-30.357L668.944 518.072l121.431-121.43s8.22-16.061-6.074-30.356c-14.294-14.296-30.356-6.072-30.356-6.072z",
        fill: "currentColor"
      }));
    };
    var NumberKeyboardKey = function(props2) {
      var item = props2.item;
      var _useState = _sliced_to_array(React.useState(false), 2), active2 = _useState[0], setActive = _useState[1];
      var onTouchStart = function() {
        setActive(true);
      };
      var onTouchEnd = function(item2) {
        setActive(false);
        switch (item2.type) {
          case "num":
          case "custom":
            onChange === null || onChange === void 0 ? void 0 : onChange(item2.id);
            break;
          case "close":
            onClose === null || onClose === void 0 ? void 0 : onClose();
            break;
          case "delete":
            onDelete === null || onDelete === void 0 ? void 0 : onDelete();
            break;
          case "confirm":
            onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm();
            break;
        }
      };
      var renderContent = function(item2) {
        switch (item2.type) {
          case "num":
          case "custom":
            return /* @__PURE__ */ React.createElement("div", null, item2.id);
          case "delete":
            return /* @__PURE__ */ React.createElement(DeleteIcon, null);
          case "close":
            return /* @__PURE__ */ React.createElement(l$1, {
              width: 18,
              height: 18
            });
          case "confirm":
            return /* @__PURE__ */ React.createElement(React.Fragment, null, confirmText || locale.done);
          default:
            return null;
        }
      };
      return /* @__PURE__ */ React.createElement("div", {
        key: item.id,
        className: "".concat(classPrefix2, "-body-wrapper")
      }, /* @__PURE__ */ React.createElement("div", {
        className: classNames({
          key: true,
          active: active2,
          close: item.type === "close",
          delete: item.type === "delete",
          confirm: item.type === "confirm"
        }),
        onTouchStart: function() {
          return onTouchStart();
        },
        onTouchEnd: function() {
          return onTouchEnd(item);
        },
        onTouchCancel: function() {
          return onTouchEnd(item);
        }
      }, renderContent(item)));
    };
    return /* @__PURE__ */ React.createElement(Popup, _object_spread_props(_object_spread({}, rest), {
      visible,
      position: "bottom",
      onOverlayClick: onClose,
      onCloseIconClick: onClose,
      zIndex: 9999,
      overlayStyle: {
        backgroundColor: "rgba(0, 0, 0, 0)"
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className),
      style
    }, title && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-header")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-header-title")
    }, title), type2 === "default" && /* @__PURE__ */ React.createElement("span", {
      className: "".concat(classPrefix2, "-header-close"),
      onClick: onConfirm
    }, rightActions || locale.done)), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-body")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-body-keys")
    }, keysList === null || keysList === void 0 ? void 0 : keysList.map(function(item) {
      return /* @__PURE__ */ React.createElement(NumberKeyboardKey, {
        key: item.id,
        item
      });
    })), type2 === "rightColumn" && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-sidebar")
    }, /* @__PURE__ */ React.createElement(NumberKeyboardKey, {
      key: "delete",
      item: {
        id: "delete",
        type: "delete"
      }
    }), /* @__PURE__ */ React.createElement(NumberKeyboardKey, {
      key: "confirm",
      item: {
        id: "confirm",
        type: "confirm"
      }
    })))));
  };
  NumberKeyboard.displayName = "NutNumberKeyboard";
  const RadioContext = React.createContext(null);
  var defaultProps$T = _object_spread_props(_object_spread({}, ComponentDefaults), {
    disabled: false,
    shape: "round",
    value: "",
    labelPosition: "right",
    icon: null,
    activeIcon: null,
    onChange: function(checked) {
    }
  });
  var Radio = function(props) {
    var classPrefix2 = "nut-radio";
    var _ref = _object_spread({}, defaultProps$T, props), children = _ref.children, className = _ref.className, style = _ref.style, checked = _ref.checked, defaultChecked = _ref.defaultChecked, shape = _ref.shape, value2 = _ref.value;
    _ref.icon;
    _ref.activeIcon;
    var onChange = _ref.onChange, others = _object_without_properties(_ref, [
      "children",
      "className",
      "style",
      "checked",
      "defaultChecked",
      "shape",
      "value",
      "icon",
      "activeIcon",
      "onChange"
    ]);
    var labelPosition = others.labelPosition, disabled = others.disabled, rest = _object_without_properties(others, [
      "labelPosition",
      "disabled"
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: checked,
      defaultValue: defaultChecked,
      finalValue: false,
      onChange
    }), 2), checkedStatement = _usePropsValue[0], setCheckedStatement = _usePropsValue[1];
    var context2 = React.useContext(RadioContext);
    if (context2) {
      checkedStatement = context2.value === value2;
      if (context2.labelPosition !== void 0) {
        labelPosition = context2.labelPosition;
      }
      if (context2.disabled !== void 0) {
        disabled = context2.disabled;
      }
      setCheckedStatement = function(value3) {
        if (value3) {
          context2.check(props.value === void 0 ? "" : props.value);
        } else {
          context2.uncheck();
        }
      };
    }
    var color = function() {
      var _obj;
      return _obj = {}, _define_property(_obj, "".concat(classPrefix2, "-icon-disabled"), disabled), _define_property(_obj, "".concat(classPrefix2, "-icon"), !checkedStatement), _define_property(_obj, "".concat(classPrefix2, "-icon-checked"), checkedStatement), _obj;
    };
    var renderIcon = function() {
      var icon = props.icon, activeIcon = props.activeIcon;
      if (disabled && !checkedStatement) {
        return /* @__PURE__ */ React.createElement(n$9, {
          className: classNames(color())
        });
      }
      if (checkedStatement) {
        return /* @__PURE__ */ React.isValidElement(activeIcon) ? /* @__PURE__ */ React.cloneElement(activeIcon, _object_spread_props(_object_spread({}, activeIcon.props), {
          className: classNames(activeIcon.props.className, color())
        })) : /* @__PURE__ */ React.createElement(c$2, {
          className: classNames(color())
        });
      }
      return /* @__PURE__ */ React.isValidElement(icon) ? /* @__PURE__ */ React.cloneElement(icon, _object_spread_props(_object_spread({}, icon.props), {
        className: classNames(icon.props.className, color())
      })) : /* @__PURE__ */ React.createElement(n$8, {
        className: classNames(color())
      });
    };
    var renderLabel = function() {
      var labelcls = classNames("".concat(classPrefix2, "-label"), _define_property({}, "".concat(classPrefix2, "-label-disabled"), disabled));
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), /* @__PURE__ */ React.createElement("div", {
        className: labelcls
      }, children));
    };
    var renderButton = function() {
      var _obj;
      var buttoncls = classNames("".concat(classPrefix2, "-button"), (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-button-active"), checkedStatement), _define_property(_obj, "".concat(classPrefix2, "-button-disabled"), disabled), _obj));
      return /* @__PURE__ */ React.createElement("div", {
        className: buttoncls
      }, children);
    };
    var renderByShape = function(shape2) {
      return shape2 === "button" ? renderButton() : renderLabel();
    };
    var renderRadioItem = function() {
      return renderByShape(context2 && context2.shape ? context2.shape : shape);
    };
    var handleClick = function(e2) {
      if (disabled || checkedStatement) return;
      setCheckedStatement(!checkedStatement);
    };
    var cls = classNames(classPrefix2, _define_property({}, "".concat(classPrefix2, "-reverse"), labelPosition === "left"), className);
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: cls,
      style,
      onClick: handleClick
    }, rest), renderRadioItem());
  };
  Radio.displayName = "NutRadio";
  var defaultProps$S = {
    labelPosition: "right",
    onChange: function(value2) {
    },
    direction: "vertical",
    options: []
  };
  var classPrefix$g = "nut-radiogroup";
  var RadioGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _ref = _object_spread({}, defaultProps$S, props), children = _ref.children, className = _ref.className;
    _ref.value;
    _ref.defaultValue;
    var onChange = _ref.onChange, shape = _ref.shape, labelPosition = _ref.labelPosition, direction = _ref.direction, options2 = _ref.options, disabled = _ref.disabled, rest = _object_without_properties(_ref, [
      "children",
      "className",
      "value",
      "defaultValue",
      "onChange",
      "shape",
      "labelPosition",
      "direction",
      "options",
      "disabled"
    ]);
    var cls = classNames(classPrefix$g, _define_property({}, "".concat(classPrefix$g, "-").concat(direction), direction), className);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      defaultValue: props.defaultValue,
      value: props.value,
      finalValue: "",
      onChange
    }), 2), val2State = _usePropsValue[0], setVal2State = _usePropsValue[1];
    var renderOptionsChildren = React.useCallback(function() {
      return options2 === null || options2 === void 0 ? void 0 : options2.map(function(_param) {
        var label = _param.label, value2 = _param.value, disabled2 = _param.disabled, onChange2 = _param.onChange, rest2 = _object_without_properties(_param, [
          "label",
          "value",
          "disabled",
          "onChange"
        ]);
        return /* @__PURE__ */ React.createElement(InnerRadio, _object_spread_props(_object_spread({}, rest2), {
          key: value2 === null || value2 === void 0 ? void 0 : value2.toString(),
          children: label,
          value: value2,
          disabled: disabled2,
          onChange: onChange2,
          labelPosition,
          checked: value2 === val2State
        }));
      });
    }, [
      options2,
      labelPosition,
      val2State
    ]);
    return /* @__PURE__ */ React.createElement(RadioContext.Provider, {
      value: {
        labelPosition: labelPosition || "right",
        disabled,
        shape,
        value: val2State,
        check: function(value2) {
          setVal2State(value2);
        },
        uncheck: function() {
          setVal2State("");
        }
      }
    }, /* @__PURE__ */ React.createElement("div", _object_spread({
      className: cls
    }, rest), (options2 === null || options2 === void 0 ? void 0 : options2.length) ? renderOptionsChildren() : children));
  });
  RadioGroup.displayName = "NutRadioGroup";
  var InnerRadio = Radio;
  InnerRadio.Group = RadioGroup;
  var defaultProps$R = _object_spread_props(_object_spread({}, ComponentDefaults), {
    range: false,
    min: 0,
    max: 100,
    step: 1,
    vertical: false,
    marks: {}
  });
  var classPrefix$f = "nut-range";
  var verticalClassPrefix = "".concat(classPrefix$f, "-vertical");
  var isSameValue = function(newValue, oldValue) {
    return JSON.stringify(newValue) === JSON.stringify(oldValue);
  };
  var handleOverlap = function(value2) {
    if (value2[0] > value2[1]) {
      return value2.slice(0).reverse();
    }
    return value2;
  };
  var Range = function(props) {
    var rtl = useRtl();
    var _$_object_spread = _object_spread({}, defaultProps$R, props), className = _$_object_spread.className, style = _$_object_spread.style, range2 = _$_object_spread.range, disabled = _$_object_spread.disabled, button = _$_object_spread.button, vertical = _$_object_spread.vertical, marks = _$_object_spread.marks, minDescription = _$_object_spread.minDescription, maxDescription = _$_object_spread.maxDescription, currentDescription = _$_object_spread.currentDescription, min = _$_object_spread.min, max = _$_object_spread.max, step = _$_object_spread.step, value2 = _$_object_spread.value, defaultValue = _$_object_spread.defaultValue, onChange = _$_object_spread.onChange, onStart = _$_object_spread.onStart, onEnd = _$_object_spread.onEnd;
    var rtlClassPrefix = React.useMemo(function() {
      return "rtl-".concat(vertical ? verticalClassPrefix : classPrefix$f);
    }, [
      vertical
    ]);
    var _useState = _sliced_to_array(React.useState(0), 2), buttonIndex = _useState[0], setButtonIndex = _useState[1];
    var _useState1 = _sliced_to_array(React.useState("start"), 2), dragStatus = _useState1[0], setDragStatus = _useState1[1];
    var touch = useTouch();
    var root2 = React.useRef(null);
    var _useState2 = _sliced_to_array(React.useState([]), 2), marksList = _useState2[0], setMarksList = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(0), 2), startValue = _useState3[0], setStartValue = _useState3[1];
    var scope = React.useMemo(function() {
      if (max < min || max === min) {
        console.log("max  min");
      }
      return max - min;
    }, [
      max,
      min
    ]);
    var handleChange = function(value3) {
      onChange && onChange(value3);
    };
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: 0,
      onChange: handleChange
    }), 2), current = _usePropsValue[0], setCurrent = _usePropsValue[1];
    var _useState4 = _sliced_to_array(React.useState(function() {
      return value2 || defaultValue || 0;
    }), 2), exactValue = _useState4[0], setExactValue = _useState4[1];
    var marksRef = React.useRef({});
    React.useEffect(function() {
      if (marks) {
        if (Array.isArray(marks)) {
          var list = marks.sort(function(a, b) {
            return a.value - b.value;
          }).filter(function(point) {
            return point.value >= min && point.value <= max;
          });
          setMarksList(list.map(function(mark) {
            return mark.value;
          }));
          list.forEach(function(mark) {
            marksRef.current[mark.value] = mark.label !== void 0 ? mark.label : mark.value;
          });
        } else {
          var marksKeys = Object.keys(marks);
          var list1 = marksKeys.map(parseFloat).sort(function(a, b) {
            return a - b;
          }).filter(function(point) {
            return point >= min && point <= max;
          });
          setMarksList(list1);
        }
      }
    }, [
      marks,
      max,
      min
    ]);
    var _obj;
    var classes = classNames(classPrefix$f, (_obj = {}, _define_property(_obj, "".concat(classPrefix$f, "-disabled"), disabled), _define_property(_obj, verticalClassPrefix, vertical), _obj));
    var containerClasses = classNames("".concat(classPrefix$f, "-container"), _define_property({}, "".concat(verticalClassPrefix, "-container"), vertical), className);
    var markClassName = React.useCallback(function(mark) {
      var classPrefix2 = "nut-range-mark";
      var verticalClassPrefix2 = "nut-range-vertical-mark";
      var lowerBound = min;
      var upperBound = max;
      if (range2 && Array.isArray(current)) {
        lowerBound = current[0];
        upperBound = current[1];
      } else {
        upperBound = current;
      }
      var isActive = mark <= upperBound && mark >= lowerBound;
      var _$classNames = [
        "".concat(classPrefix2, "-text-wrapper"),
        "".concat(isActive ? "".concat(classPrefix2, "-text-wrapper-active") : "")
      ];
      if (vertical) {
        _$classNames.push("".concat(verticalClassPrefix2, "-text-wrapper"));
        isActive && _$classNames.push("".concat(verticalClassPrefix2, "-text-active-wrapper"));
      }
      if (rtl) {
        _$classNames.push("".concat(rtlClassPrefix, "-mark-text-wrapper"));
      }
      return _$classNames.join(" ");
    }, [
      min,
      max,
      range2,
      current,
      vertical,
      rtl,
      rtlClassPrefix
    ]);
    var isRange = React.useCallback(function(val2) {
      return !!range2 && Array.isArray(val2);
    }, [
      range2
    ]);
    var calcMainAxis = React.useCallback(function() {
      var modelVal = current;
      return isRange(modelVal) ? "".concat((modelVal[1] - modelVal[0]) * 100 / scope, "%") : "".concat((modelVal - min) * 100 / scope, "%");
    }, [
      current,
      isRange,
      min,
      scope
    ]);
    var calcOffset = React.useCallback(function() {
      var modelVal = current;
      return isRange(modelVal) ? "".concat((modelVal[0] - min) * 100 / scope, "%") : "0%";
    }, [
      current,
      isRange,
      min,
      scope
    ]);
    var barStyle = React.useCallback(function() {
      if (vertical) {
        return {
          height: calcMainAxis(),
          top: calcOffset(),
          transition: dragStatus ? "none" : void 0
        };
      }
      var dir = rtl ? "right" : "left";
      var _obj2;
      return _obj2 = {
        width: calcMainAxis()
      }, _define_property(_obj2, dir, calcOffset()), _define_property(_obj2, "transition", dragStatus ? "none" : void 0), _obj2;
    }, [
      calcMainAxis,
      calcOffset,
      dragStatus,
      rtl,
      vertical
    ]);
    var marksStyle = React.useCallback(function(mark) {
      var dir = rtl ? "right" : "left";
      var style2 = _define_property({}, dir, "".concat((mark - min) / scope * 100, "%"));
      if (vertical) {
        style2 = {
          top: "".concat((mark - min) / scope * 100, "%")
        };
      }
      return style2;
    }, [
      min,
      rtl,
      scope,
      vertical
    ]);
    var tickClass = React.useCallback(function(mark) {
      if (range2 && Array.isArray(current)) {
        return mark <= current[1] && mark >= current[0];
      }
      return mark <= current;
    }, [
      current,
      range2
    ]);
    var format2 = React.useCallback(function(value3) {
      value3 = Math.max(+min, Math.min(value3, +max));
      return Math.round(value3 / +step) * +step;
    }, [
      max,
      min,
      step
    ]);
    var updateValue = React.useCallback(function(value3, end) {
      if (isRange(value3)) {
        value3 = handleOverlap(value3).map(format2);
      } else {
        value3 = format2(value3);
      }
      if (!isSameValue(value3, current)) {
        setCurrent(value3);
      }
      end && onEnd && onEnd(value3);
    }, [
      current,
      format2,
      isRange,
      onEnd,
      setCurrent
    ]);
    var handleClick = React.useCallback(function(event) {
      if (disabled || !root2.current) return;
      setDragStatus("");
      var rect = getRect(root2.current);
      var delta = event.clientX - rect.left;
      var total = rect.width;
      if (vertical) {
        delta = event.clientY - rect.top;
        total = rect.height;
      }
      var value3 = min + delta / total * scope;
      setExactValue(current);
      if (isRange(current)) {
        var _current = _sliced_to_array(current, 2), left = _current[0], right = _current[1];
        var middle = (left + right) / 2;
        if (value3 <= middle) {
          updateValue([
            value3,
            right
          ], true);
        } else {
          updateValue([
            left,
            value3
          ], true);
        }
      } else {
        updateValue(value3, true);
      }
    }, [
      current,
      disabled,
      isRange,
      min,
      scope,
      updateValue,
      vertical
    ]);
    var onTouchStart = React.useCallback(function(event) {
      if (disabled) return;
      touch.start(event);
      setExactValue(current);
      if (isRange(current)) {
        setStartValue(current.map(format2));
      } else {
        setStartValue(format2(current));
      }
      setDragStatus("start");
    }, [
      current,
      disabled,
      format2,
      isRange,
      touch
    ]);
    var onTouchMove = React.useCallback(function(event) {
      event.stopPropagation();
      if (disabled || !root2.current) {
        return;
      }
      if (dragStatus === "start") {
        onStart && onStart();
      }
      touch.move(event);
      setDragStatus("draging");
      var rect = getRect(root2.current);
      var delta = touch.deltaX.current;
      var total = rect.width;
      var diff = delta / total * scope;
      diff = rtl ? -diff : diff;
      if (vertical) {
        delta = touch.deltaY.current;
        total = rect.height;
        diff = delta / total * scope;
      }
      var newValue;
      if (isRange(startValue)) {
        newValue = exactValue.slice();
        newValue[buttonIndex] = startValue[buttonIndex] + diff;
      } else {
        newValue = startValue + diff;
      }
      setExactValue(newValue);
      updateValue(newValue);
    }, [
      buttonIndex,
      disabled,
      dragStatus,
      exactValue,
      isRange,
      onStart,
      rtl,
      scope,
      startValue,
      touch,
      updateValue,
      vertical
    ]);
    var onTouchEnd = React.useCallback(function() {
      if (disabled) {
        return;
      }
      if (dragStatus === "draging") {
        updateValue(current, true);
      }
      setDragStatus("");
    }, [
      current,
      disabled,
      dragStatus,
      updateValue
    ]);
    var curValue = React.useCallback(function(idx) {
      var modelVal = current;
      var value3 = typeof idx === "number" ? modelVal[idx] : modelVal;
      return value3;
    }, [
      current
    ]);
    var renderButton = React.useCallback(function(index2) {
      var buttonNumberTransform = vertical ? "translate(100%, -50%)" : "translate(-50%, -100%)";
      var _obj2, _obj1;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, button || /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$f, "-button"), (_obj2 = {}, _define_property(_obj2, "".concat(verticalClassPrefix, "-button"), vertical), _define_property(_obj2, "".concat(rtlClassPrefix, "-button"), rtl), _obj2)),
        style: {
          transform: "translate(-50%, -50%)"
        }
      }, currentDescription !== null && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$f, "-button-number"), (_obj1 = {}, _define_property(_obj1, "".concat(verticalClassPrefix, "-button-number"), vertical), _define_property(_obj1, "".concat(rtlClassPrefix, "-button-number"), rtl), _obj1)),
        style: {
          transform: buttonNumberTransform
        }
      }, currentDescription ? currentDescription(curValue(index2)) : curValue(index2))));
    }, [
      button,
      curValue,
      currentDescription,
      rtl,
      rtlClassPrefix,
      vertical
    ]);
    var renderMarks = React.useCallback(function() {
      if (marksList.length <= 0) return null;
      var _obj2;
      var markcls = classNames("".concat(classPrefix$f, "-mark"), (_obj2 = {}, _define_property(_obj2, "".concat(verticalClassPrefix, "-mark"), vertical), _define_property(_obj2, "".concat(rtlClassPrefix, "-mark"), rtl), _obj2));
      var textcls = classNames("".concat(classPrefix$f, "-mark-text"), _define_property({}, "".concat(verticalClassPrefix, "-mark-text"), vertical));
      return /* @__PURE__ */ React.createElement("div", {
        className: markcls
      }, marksList.map(function(mark) {
        var _obj3;
        return /* @__PURE__ */ React.createElement("span", {
          key: mark,
          className: markClassName(mark),
          style: marksStyle(mark)
        }, /* @__PURE__ */ React.createElement("span", {
          className: textcls
        }, Array.isArray(marks) ? marksRef.current[mark] : marks[mark]), /* @__PURE__ */ React.createElement("span", {
          className: classNames("".concat(vertical ? verticalClassPrefix : classPrefix$f, "-tick"), (_obj3 = {}, _define_property(_obj3, "".concat(vertical ? verticalClassPrefix : classPrefix$f, "-tick-active"), tickClass(mark)), _define_property(_obj3, "".concat(rtlClassPrefix, "-tick"), rtl), _obj3))
        }));
      }));
    }, [
      markClassName,
      marks,
      marksList,
      marksStyle,
      rtl,
      rtlClassPrefix,
      tickClass,
      vertical
    ]);
    var getWrapperTransform = React.useCallback(function() {
      var wrapperTransform = "translate(-50%, -50%)";
      return wrapperTransform;
    }, []);
    var renderRangeButton = React.useCallback(function() {
      return [
        0,
        1
      ].map(function(item, index2) {
        var isLeft = index2 === 0;
        var suffix = isLeft ? "left" : "right";
        var transform2 = "translate(-50%, -50%)";
        var _obj2;
        var cls = classNames("".concat(classPrefix$f, "-button-wrapper-").concat(suffix), (_obj2 = {}, _define_property(_obj2, "".concat(verticalClassPrefix, "-button-wrapper-").concat(suffix), vertical), _define_property(_obj2, "".concat(rtlClassPrefix, "-button-wrapper-").concat(suffix), rtl), _obj2));
        return /* @__PURE__ */ React.createElement("div", {
          key: index2,
          className: cls,
          style: {
            transform: transform2
          },
          onTouchStart: function(e2) {
            setButtonIndex(index2);
            onTouchStart(e2);
          },
          onTouchMove,
          onTouchEnd,
          onTouchCancel: onTouchEnd,
          onClick: function(e2) {
            return e2.stopPropagation();
          }
        }, renderButton(index2));
      });
    }, [
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      renderButton,
      vertical,
      rtl,
      rtlClassPrefix
    ]);
    var renderSingleButton = React.useCallback(function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix$f, "-button-wrapper"), _define_property({}, "".concat(verticalClassPrefix, "-button-wrapper"), vertical)),
        style: {
          // @ts-ignore
          transform: getWrapperTransform()
        },
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel: onTouchEnd,
        onClick: function(e2) {
          return e2.stopPropagation();
        }
      }, renderButton());
    }, [
      getWrapperTransform,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      renderButton,
      vertical
    ]);
    var renderButtonWrapper = React.useCallback(function() {
      if (range2) {
        return renderRangeButton();
      }
      return renderSingleButton();
    }, [
      renderRangeButton,
      renderSingleButton,
      range2
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: containerClasses,
      style
    }, minDescription !== null && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$f, "-min")
    }, minDescription || min), /* @__PURE__ */ React.createElement("div", {
      ref: root2,
      className: classes,
      onClick: handleClick
    }, renderMarks(), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$f, "-bar ").concat(classPrefix$f, "-bar-animate"),
      style: barStyle()
    }, renderButtonWrapper())), maxDescription !== null && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$f, "-max")
    }, maxDescription || max));
  };
  Range.displayName = "NutRange";
  var defaultProps$Q = _object_spread_props(_object_spread({}, ComponentDefaults), {
    size: "normal",
    showScore: false,
    count: 5,
    min: 0,
    checkedIcon: null,
    uncheckedIcon: null,
    disabled: false,
    readOnly: false,
    allowHalf: false,
    touchable: false
  });
  var Rate = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$Q, props), className = _$_object_spread.className, style = _$_object_spread.style, size = _$_object_spread.size, showScore = _$_object_spread.showScore, count = _$_object_spread.count, value2 = _$_object_spread.value, defaultValue = _$_object_spread.defaultValue, min = _$_object_spread.min, checkedIcon = _$_object_spread.checkedIcon, uncheckedIcon = _$_object_spread.uncheckedIcon, disabled = _$_object_spread.disabled, readOnly = _$_object_spread.readOnly, allowHalf = _$_object_spread.allowHalf, touchable = _$_object_spread.touchable, onChange = _$_object_spread.onChange, onTouchEnd = _$_object_spread.onTouchEnd;
    var classPrefix2 = "nut-rate";
    var _useState = _sliced_to_array(React.useState([
      1,
      2,
      3,
      4,
      5
    ]), 2), countArray = _useState[0], setCountArray = _useState[1];
    var _useRefs = _sliced_to_array(useRefs(), 2), refs = _useRefs[0], setRefs = _useRefs[1];
    var rateRects = React.useRef([]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue: Math.max(defaultValue || 0, min),
      finalValue: 0,
      onChange
    }), 2), score = _usePropsValue[0], setScore = _usePropsValue[1];
    React.useEffect(function() {
      var tmp = [];
      for (var i2 = 1; i2 <= Number(count); i2++) {
        tmp.push(i2);
      }
      setCountArray(tmp);
    }, [
      count
    ]);
    var renderIcon = function(n2) {
      return n2 <= score ? checkedIcon || /* @__PURE__ */ React.createElement(d$1, null) : uncheckedIcon || (checkedIcon ? /* @__PURE__ */ React.cloneElement(checkedIcon, {
        color: void 0
      }) : /* @__PURE__ */ React.createElement(d$1, null));
    };
    var onClick = function(e2, index2) {
      e2.preventDefault();
      e2.stopPropagation();
      if (disabled || readOnly) return;
      var value3 = 0;
      if (!(index2 === 1 && score === index2)) {
        value3 = index2;
      }
      value3 = Math.max(value3, min);
      setScore(value3);
    };
    var onHalfClick = function(event, n2) {
      event.preventDefault();
      event.stopPropagation();
      var value3 = Math.max(min, n2 - 0.5);
      setScore(value3);
    };
    var getScoreByPosition = function(x) {
      var _rateRects_current;
      if ((_rateRects_current = rateRects.current) === null || _rateRects_current === void 0 ? void 0 : _rateRects_current.length) {
        for (var index2 = rateRects.current.length - 1; index2 >= 0; index2--) {
          var item = rateRects.current[index2];
          if (item && x > item.left) {
            return allowHalf ? index2 + (x > item.left + item.width / 2 ? 1 : 0.5) : index2 + 1;
          }
        }
        return 0;
      }
    };
    var updateRects = function() {
      for (var index2 = 0; index2 < refs.length; index2++) {
        var item = refs[index2];
        if (item) {
          rateRects.current[index2] = getRect(item);
        }
      }
    };
    var handleTouchStart = function(e2) {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e2.cancelable) {
        e2.preventDefault();
      }
      e2.stopPropagation();
      updateRects();
    };
    var handleTouchMove = function(e2) {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e2.cancelable) {
        e2.preventDefault();
      }
      e2.stopPropagation();
      var val2 = getScoreByPosition(e2.touches[0].clientX);
      if (val2 !== void 0) {
        setScore(Math.max(min, val2));
      }
    };
    var handleTouchEnd = function(e2) {
      if (!touchable || readOnly || disabled) {
        return;
      }
      if (e2.cancelable) {
        e2.preventDefault();
      }
      e2.stopPropagation();
      var val2 = getScoreByPosition(e2.changedTouches[0].clientX);
      if (val2 !== void 0) {
        setScore(Math.max(min, val2));
        onTouchEnd && onTouchEnd(e2, Math.max(min, val2));
      }
    };
    var rateRef = React.useRef(null);
    React.useEffect(function() {
      var element = rateRef.current;
      if (element) {
        element.addEventListener("touchstart", handleTouchStart, {
          passive: false
        });
        element.addEventListener("touchmove", handleTouchMove, {
          passive: false
        });
        element.addEventListener("touchend", handleTouchEnd, {
          passive: false
        });
      }
      return function() {
        if (element) {
          element.removeEventListener("touchstart", handleTouchStart);
          element.removeEventListener("touchmove", handleTouchMove);
          element.removeEventListener("touchend", handleTouchEnd);
        }
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, {
        disabled,
        readonly: readOnly
      }, className),
      ref: rateRef,
      style
    }, countArray.map(function(n2, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-item ").concat(classPrefix2, "-item-").concat(size),
        key: n2,
        ref: setRefs(index2),
        onClick: function(event) {
          return onClick(event, n2);
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-item-icon"), _define_property({}, "".concat(classPrefix2, "-item-icon-disabled"), disabled || n2 > score))
      }, renderIcon(n2)), allowHalf && score > n2 - 1 && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-item-half"), "".concat(classPrefix2, "-item-icon"), "".concat(classPrefix2, "-item-icon-half")),
        onClick: function(event) {
          return onHalfClick(event, n2);
        }
      }, renderIcon(n2)));
    }), showScore ? /* @__PURE__ */ React.createElement("span", {
      className: classNames("".concat(classPrefix2, "-score"), "".concat(classPrefix2, "-score-").concat(size), _define_property({}, "".concat(classPrefix2, "-score-disabled"), disabled))
    }, score.toFixed(1)) : null);
  };
  Rate.displayName = "NutRate";
  var defaultProps$P = _object_spread_props(_object_spread({}, ComponentDefaults), {
    placeholder: "",
    shape: "square",
    disabled: false,
    maxLength: 9999,
    clearable: true,
    readOnly: false,
    autoFocus: false,
    backable: false,
    left: "",
    right: "",
    rightIn: "",
    leftIn: /* @__PURE__ */ React.createElement(n, null),
    tag: false
  });
  var SearchBar = function(props) {
    var classPrefix2 = "nut-searchbar";
    var locale = useConfig().locale;
    var searchInputRef = React.useRef(null);
    var _$_object_spread = _object_spread({}, defaultProps$P, props), outerValue = _$_object_spread.value, defaultValue = _$_object_spread.defaultValue, style = _$_object_spread.style, placeholder = _$_object_spread.placeholder, shape = _$_object_spread.shape, className = _$_object_spread.className, disabled = _$_object_spread.disabled, maxLength = _$_object_spread.maxLength, clearable = _$_object_spread.clearable, readOnly = _$_object_spread.readOnly, autoFocus = _$_object_spread.autoFocus, backable = _$_object_spread.backable, right = _$_object_spread.right, left = _$_object_spread.left, leftIn = _$_object_spread.leftIn, rightIn = _$_object_spread.rightIn, tag = _$_object_spread.tag, onChange = _$_object_spread.onChange, onFocus = _$_object_spread.onFocus, onBlur = _$_object_spread.onBlur, onClear = _$_object_spread.onClear, onSearch = _$_object_spread.onSearch, onInputClick = _$_object_spread.onInputClick, onItemClick = _$_object_spread.onItemClick;
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: outerValue,
      defaultValue,
      finalValue: ""
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState(tag), 2), innerTag = _useState[0], setInnerTag = _useState[1];
    var forceFocus = React.useCallback(function() {
      var _searchInputRef_current;
      (_searchInputRef_current = searchInputRef.current) === null || _searchInputRef_current === void 0 ? void 0 : _searchInputRef_current.focus();
    }, []);
    var handleChange = React.useCallback(function(event) {
      var value3 = event.target.value;
      onChange && onChange(value3, event);
      setValue(value3);
    }, [
      onChange,
      setValue
    ]);
    var handleInputClick = React.useCallback(function(event) {
      onInputClick === null || onInputClick === void 0 ? void 0 : onInputClick(event);
    }, [
      onInputClick
    ]);
    var handleFocus = React.useCallback(function(event) {
      var _event_target;
      onFocus && onFocus((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.value, event);
      if (tag) setInnerTag(false);
    }, [
      onFocus,
      tag
    ]);
    var _useState1 = _sliced_to_array(React.useState(null), 2), blurTimer = _useState1[0], setBlurTimer = _useState1[1];
    var handleBlur = React.useCallback(function(event) {
      var _searchInputRef_current, _event_target;
      (_searchInputRef_current = searchInputRef.current) === null || _searchInputRef_current === void 0 ? void 0 : _searchInputRef_current.blur();
      onBlur && onBlur((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.value, event);
      if (tag) {
        var timer = setTimeout(function() {
          var _event_target2;
          setInnerTag(((_event_target2 = event.target) === null || _event_target2 === void 0 ? void 0 : _event_target2.value) ? tag : false);
        }, 150);
        setBlurTimer(timer);
      }
    }, [
      onBlur,
      tag
    ]);
    React.useEffect(function() {
      return function() {
        if (blurTimer) clearTimeout(blurTimer);
      };
    }, [
      blurTimer
    ]);
    var clearaVal = React.useCallback(function(event) {
      if (disabled || readOnly) return;
      setValue("");
      forceFocus();
      onChange && onChange("");
      onClear && onClear(event);
    }, [
      disabled,
      readOnly,
      onChange,
      onClear,
      setValue,
      forceFocus
    ]);
    var onKeydown = React.useCallback(function(e2) {
      if (e2.key === "Enter") {
        var event = e2.nativeEvent;
        if (typeof event.cancelable !== "boolean" || event.cancelable) {
          event.preventDefault();
        }
        onSearch && onSearch(value2);
      }
    }, [
      onSearch,
      value2
    ]);
    var cls = React.useMemo(function() {
      var _obj;
      return classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-disabled"), disabled), _define_property(_obj, "".concat(classPrefix2, "-focus"), left || backable), _obj), className);
    }, [
      disabled,
      backable,
      left,
      className
    ]);
    React.useEffect(function() {
      if (autoFocus) {
        forceFocus();
      }
    }, [
      autoFocus,
      forceFocus
    ]);
    var renderField = function() {
      var inputCls = classNames("".concat(classPrefix2, "-input"));
      return /* @__PURE__ */ React.createElement("input", {
        className: inputCls,
        ref: searchInputRef,
        value: value2 || "",
        placeholder: placeholder || locale.placeholder,
        disabled,
        readOnly,
        maxLength,
        onKeyDown: onKeydown,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onClick: handleInputClick
      });
    };
    var renderValueByTags = React.useCallback(function() {
      if (!value2) {
        setTimeout(function() {
          forceFocus();
        }, 0);
        return null;
      }
      var list = value2.split(",");
      if (!list) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "nut-searchbar-values"
      }, list.map(function(item, index2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: "def-".concat(index2),
          className: "nut-searchbar-value",
          onClick: function(e2) {
            return onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(item, e2);
          }
        }, item, /* @__PURE__ */ React.createElement(n$6, null));
      }));
    }, [
      value2,
      onItemClick
    ]);
    var renderLeftIn = React.useCallback(function() {
      if (!leftIn) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-leftin ").concat(classPrefix2, "-icon")
      }, leftIn);
    }, [
      leftIn
    ]);
    var renderLeft = React.useCallback(function() {
      if (!backable && !left) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-left")
      }, backable ? /* @__PURE__ */ React.createElement(d$7, null) : left);
    }, [
      backable,
      left
    ]);
    var renderRightIn = React.useCallback(function() {
      if (!rightIn) return null;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.isValidElement(rightIn) ? /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-rightin ").concat(classPrefix2, "-icon")
      }, rightIn) : /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-rightin")
      }, rightIn));
    }, [
      rightIn
    ]);
    var renderRight = React.useCallback(function() {
      if (!right) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-right")
      }, right);
    }, [
      right
    ]);
    var renderClear = React.useCallback(function() {
      if (!value2 || !clearable) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-clear ").concat(classPrefix2, "-icon"),
        onClick: clearaVal,
        "aria-label": ""
      }, /* @__PURE__ */ React.createElement(n$2, null));
    }, [
      value2,
      clearable,
      clearaVal
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, renderLeft(), /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-content"), _define_property({}, "".concat(classPrefix2, "-round"), shape === "round"))
    }, renderLeftIn(), renderField(), innerTag ? renderValueByTags() : renderClear(), renderRightIn()), renderRight());
  };
  SearchBar.displayName = "NutSearchBar";
  var defaultProps$O = _object_spread_props(_object_spread({}, ComponentDefaults), {
    value: "",
    visible: false,
    plain: false,
    hideFooter: true,
    length: 6,
    autoFocus: false
  });
  var InternalShortPassword = function(props, ref) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$O, props), title = _ref.title, description = _ref.description, tips = _ref.tips, outerVisible = _ref.visible, value2 = _ref.value, error = _ref.error, hideFooter = _ref.hideFooter, length2 = _ref.length, plain = _ref.plain, style = _ref.style, className = _ref.className;
    _ref.closeable;
    var autoFocus = _ref.autoFocus, round = _ref.round, onFocus = _ref.onFocus, onChange = _ref.onChange, onConfirm = _ref.onConfirm, onTips = _ref.onTips, onCancel = _ref.onCancel, onClose = _ref.onClose, onComplete = _ref.onComplete;
    _ref.onOverlayClick;
    _ref.onCloseIconClick;
    var rest = _object_without_properties(_ref, [
      "title",
      "description",
      "tips",
      "visible",
      "value",
      "error",
      "hideFooter",
      "length",
      "plain",
      "style",
      "className",
      "closeable",
      "autoFocus",
      "round",
      "onFocus",
      "onChange",
      "onConfirm",
      "onTips",
      "onCancel",
      "onClose",
      "onComplete",
      "onOverlayClick",
      "onCloseIconClick"
    ]);
    var classPrefix2 = "nut-shortpassword";
    var comLen = React.useMemo(function() {
      return Math.min(Math.max(4, length2 || 4), 6);
    }, [
      length2
    ]);
    var format2 = function(val2) {
      return val2.slice(0, comLen);
    };
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: outerVisible,
      defaultValue: false,
      finalValue: false
    }), 2), visible = _usePropsValue[0], setVisible = _usePropsValue[1];
    var handleClose = function() {
      onClose === null || onClose === void 0 ? void 0 : onClose();
      setVisible(false);
    };
    var actions = {
      open: function() {
        setVisible(true);
      },
      close: function() {
        setVisible(false);
      }
    };
    React.useImperativeHandle(ref, function() {
      return actions;
    });
    var _usePropsValue1 = _sliced_to_array(usePropsValue({
      value: value2,
      onChange
    }), 2), inputValue = _usePropsValue1[0], setInputValue = _usePropsValue1[1];
    React.useEffect(function() {
      if (visible && autoFocus) {
        onFocus && onFocus();
      }
    }, [
      visible
    ]);
    React.useEffect(function() {
      var val2 = format2(value2);
      if (val2.length >= comLen) {
        onComplete && onComplete(val2);
      }
      setInputValue(format2(value2));
    }, [
      value2
    ]);
    var sure = function() {
      onConfirm && onConfirm(inputValue);
    };
    return /* @__PURE__ */ React.createElement(Popup, _object_spread({
      className: "".concat(classPrefix2, "-popup"),
      visible,
      closeable: true,
      onOverlayClick: handleClose,
      onCloseIconClick: handleClose,
      round
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className),
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-title")
    }, title || locale.shortpassword.title), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-description")
    }, description || locale.shortpassword.description), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-input"),
      onClick: onFocus
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-input-site")
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-input-fake")
    }, _to_consumable_array(new Array(comLen).keys()).map(function(item, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-input-fake-li"),
        key: index2
      }, inputValue.length > index2 && /* @__PURE__ */ React.createElement(React.Fragment, null, plain ? inputValue[index2] : /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-input-fake-li-icon")
      })));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-message")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-message-error")
    }, error), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-message-forget"),
      onClick: onTips
    }, tips || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(p$2, {
      width: 11,
      height: 11
    }), locale.shortpassword.tips))), !hideFooter && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-footer")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-footer-cancel"),
      onClick: onCancel
    }, locale.cancel), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-footer-sure"),
      onClick: sure
    }, locale.confirm))));
  };
  var ShortPassword = /* @__PURE__ */ React.forwardRef(InternalShortPassword);
  var defaultProps$N = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "png",
    lineWidth: 2,
    strokeStyle: "#1A1A1A",
    unsupported: ""
  });
  var InternalSignature = function(props, ref) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$N, props), type2 = _ref.type, lineWidth = _ref.lineWidth, strokeStyle = _ref.strokeStyle, unsupported = _ref.unsupported, className = _ref.className, style = _ref.style, onConfirm = _ref.onConfirm, onClear = _ref.onClear, rest = _object_without_properties(_ref, [
      "type",
      "lineWidth",
      "strokeStyle",
      "unsupported",
      "className",
      "style",
      "onConfirm",
      "onClear"
    ]);
    var classPrefix2 = "nut-signature";
    var canvasRef = React.useRef(null);
    var wrapRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(0), 2), canvasHeight = _useState[0], setCanvasHeight = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(0), 2), canvasWidth = _useState1[0], setCanvasWidth = _useState1[1];
    var ctx2 = React.useRef(null);
    var checkCanvas = function() {
      var elem2 = document.createElement("canvas");
      return !!(elem2.getContext && elem2.getContext("2d"));
    };
    var _useState2 = _sliced_to_array(React.useState(false), 2), isCanvasSupported = _useState2[0], setIsCanvasSupported = _useState2[1];
    var isSignedRef = React.useRef(false);
    var isSupportTouch = canUseDom ? "ontouchstart" in window : false;
    var events = isSupportTouch ? [
      "touchstart",
      "touchmove",
      "touchend",
      "touchleave"
    ] : [
      "mousedown",
      "mousemove",
      "mouseup",
      "mouseleave"
    ];
    React.useEffect(function() {
      setIsCanvasSupported(checkCanvas);
    }, []);
    React.useEffect(function() {
      if (isCanvasSupported && canvasRef.current && wrapRef.current) {
        ctx2.current = canvasRef.current.getContext("2d");
        setCanvasWidth(wrapRef.current.offsetWidth);
        setCanvasHeight(wrapRef.current.offsetHeight);
        addEvent();
      }
    }, [
      isCanvasSupported
    ]);
    var startEventHandler = function(event) {
      event.preventDefault();
      isSignedRef.current = true;
      if (ctx2.current && canvasRef.current) {
        ctx2.current.beginPath();
        ctx2.current.lineWidth = lineWidth;
        ctx2.current.strokeStyle = strokeStyle;
        canvasRef.current.addEventListener(events[1], moveEventHandler, false);
        canvasRef.current.addEventListener(events[2], endEventHandler, false);
        canvasRef.current.addEventListener(events[3], leaveEventHandler, false);
      }
    };
    var addEvent = function() {
      if (canvasRef.current) {
        canvasRef.current.addEventListener(events[0], startEventHandler, false);
      }
    };
    var moveEventHandler = function(event) {
      event.preventDefault();
      var evt = isSupportTouch ? event.touches[0] : event;
      if (canvasRef.current && ctx2.current) {
        var coverPos = canvasRef.current.getBoundingClientRect();
        var mouseX = evt.clientX - coverPos.left;
        var mouseY = evt.clientY - coverPos.top;
        ctx2.current.lineTo(mouseX, mouseY);
        ctx2.current.stroke();
      }
    };
    var endEventHandler = function(event) {
      event.preventDefault();
      if (canvasRef.current) {
        canvasRef.current.removeEventListener(events[1], moveEventHandler, false);
        canvasRef.current.removeEventListener(events[2], endEventHandler, false);
      }
    };
    var leaveEventHandler = function(event) {
      event.preventDefault();
      if (canvasRef.current) {
        canvasRef.current.removeEventListener(events[1], moveEventHandler, false);
        canvasRef.current.removeEventListener(events[2], endEventHandler, false);
      }
    };
    var handleClearBtn = function() {
      isSignedRef.current = false;
      if (canvasRef.current && ctx2.current) {
        canvasRef.current.addEventListener(events[2], endEventHandler, false);
        ctx2.current.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx2.current.closePath();
      }
      onClear && onClear();
    };
    var onSave = function(canvas) {
      var dataurl = "";
      if (!isSignedRef.current) {
        onConfirm && onConfirm(canvas, dataurl, isSignedRef.current);
        return;
      }
      switch (type2) {
        case "png":
          dataurl = canvas.toDataURL("image/png");
          break;
        case "jpg":
          dataurl = canvas.toDataURL("image/jpeg", 0.8);
          break;
        default:
          dataurl = canvas.toDataURL("image/png");
      }
      onConfirm && onConfirm(canvas, dataurl, isSignedRef.current);
    };
    React.useImperativeHandle(ref, function() {
      return {
        confirm: function() {
          onSave(canvasRef.current);
        },
        clear: function() {
          handleClearBtn();
        }
      };
    });
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classPrefix2, " ").concat(className),
      style
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-inner"),
      ref: wrapRef
    }, /* @__PURE__ */ React.createElement(React.Fragment, null, isCanvasSupported ? /* @__PURE__ */ React.createElement("canvas", {
      ref: canvasRef,
      height: canvasHeight,
      width: canvasWidth
    }) : unsupported ? /* @__PURE__ */ React.createElement(React.Fragment, null, unsupported) : /* @__PURE__ */ React.createElement("p", {
      className: "".concat(classPrefix2, "-unsupport")
    }, locale.signature.unsupported))));
  };
  var Signature = /* @__PURE__ */ React.forwardRef(InternalSignature);
  Signature.displayName = "NutSignature";
  var defaultProps$M = _object_spread_props(_object_spread({}, ComponentDefaults), {
    disabled: false,
    activeText: "",
    inactiveText: "",
    loadingIcon: /* @__PURE__ */ React.createElement(d$3, null),
    loading: void 0,
    onLoadingChange: function(loading) {
    }
  });
  var Switch = function(props) {
    var _ref = _object_spread({}, defaultProps$M, props), checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, activeText = _ref.activeText, inactiveText = _ref.inactiveText, loadingIcon = _ref.loadingIcon, className = _ref.className, style = _ref.style, onChange = _ref.onChange, propLoading = _ref.loading, onLoadingChange = _ref.onLoadingChange, rest = _object_without_properties(_ref, [
      "checked",
      "defaultChecked",
      "disabled",
      "activeText",
      "inactiveText",
      "loadingIcon",
      "className",
      "style",
      "onChange",
      "loading",
      "onLoadingChange"
    ]);
    var classPrefix2 = "nut-switch";
    var rtl = useRtl();
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: checked,
      defaultValue: defaultChecked
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState(false), 2), internalLoading = _useState[0], setInternalLoading = _useState[1];
    var loading = propLoading !== void 0 ? propLoading : internalLoading;
    var setLoading = function(val2) {
      if (propLoading !== void 0) {
        onLoadingChange(val2);
      } else {
        setInternalLoading(val2);
      }
    };
    React.useEffect(function() {
      loading && setLoading(false);
    }, [
      value2
    ]);
    var classes = function() {
      var _obj2;
      return classNames([
        classPrefix2,
        className,
        (_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-close"), !value2), _define_property(_obj2, "".concat(classPrefix2, "-disabled"), disabled), _define_property(_obj2, "".concat(classPrefix2, "-disabled-close"), disabled && !value2), _obj2)
      ]);
    };
    var onClick = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function() {
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (disabled || loading) return [
                2
              ];
              if (!onChange) return [
                3,
                4
              ];
              loadingIcon && setLoading(true);
              _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                3,
                ,
                4
              ]);
              return [
                4,
                onChange(!value2)
              ];
            case 2:
              _state.sent();
              return [
                3,
                4
              ];
            case 3:
              _state.sent();
              setLoading(false);
              return [
                3,
                4
              ];
            case 4:
              setValue(!value2);
              return [
                2
              ];
          }
        });
      });
      return function onClick2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var _obj, _obj1;
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes(),
      onClick,
      style
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classNames([
        [
          "".concat(classPrefix2, "-button")
        ],
        [
          value2 ? "".concat(classPrefix2, "-button-open") : "".concat(classPrefix2, "-button-close")
        ],
        (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-button-open-rtl"), rtl && value2), _define_property(_obj, "".concat(classPrefix2, "-button-close-rtl"), rtl && !value2), _obj)
      ])
    }, loading && loadingIcon ? /* @__PURE__ */ React.createElement(React.Fragment, null, loadingIcon) : /* @__PURE__ */ React.createElement(React.Fragment, null, !value2 && !activeText && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-close-line")
    }))), activeText && /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-label"), (_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-label-open"), value2), _define_property(_obj1, "".concat(classPrefix2, "-label-close"), !value2), _define_property(_obj1, "".concat(classPrefix2, "-label-open-rtl"), rtl && value2), _define_property(_obj1, "".concat(classPrefix2, "-label-close-rtl"), rtl && !value2), _define_property(_obj1, "".concat(classPrefix2, "-label-close-disabled"), disabled && !value2), _obj1))
    }, value2 ? activeText : inactiveText));
  };
  Switch.displayName = "NutSwitch";
  var defaultProps$L = _object_spread_props(_object_spread({}, ComponentDefaults), {
    defaultValue: "",
    showCount: false,
    rows: 2,
    maxLength: 140,
    placeholder: "",
    readOnly: false,
    disabled: false,
    autoSize: false,
    plain: false,
    status: "default"
  });
  var TextArea = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$L, props), className = _ref.className, value2 = _ref.value, defaultValue = _ref.defaultValue, showCount = _ref.showCount, maxLength = _ref.maxLength, rows = _ref.rows, placeholder = _ref.placeholder, readOnly = _ref.readOnly, disabled = _ref.disabled, autoSize = _ref.autoSize, style = _ref.style, plain = _ref.plain, status = _ref.status, onChange = _ref.onChange, onBlur = _ref.onBlur, onFocus = _ref.onFocus, rest = _object_without_properties(_ref, [
      "className",
      "value",
      "defaultValue",
      "showCount",
      "maxLength",
      "rows",
      "placeholder",
      "readOnly",
      "disabled",
      "autoSize",
      "style",
      "plain",
      "status",
      "onChange",
      "onBlur",
      "onFocus"
    ]);
    var classPrefix2 = "nut-textarea";
    var textareaRef = React.useRef(null);
    var compositionRef = React.useRef(false);
    var rtl = useRtl();
    var format2 = function(value3) {
      if (maxLength !== -1 && value3.length > maxLength) {
        return value3.substring(0, maxLength);
      }
      return value3;
    };
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: format2(defaultValue),
      onChange
    }), 2), inputValue = _usePropsValue[0], setInputValue = _usePropsValue[1];
    React.useEffect(function() {
      if (autoSize) setContentHeight();
    }, [
      autoSize,
      defaultValue,
      inputValue
    ]);
    var setContentHeight = function() {
      var textarea = textareaRef.current;
      if (textarea) {
        textarea.style.height = "auto";
        var height2 = textarea === null || textarea === void 0 ? void 0 : textarea.scrollHeight;
        if (height2) {
          textarea.style.height = "".concat(height2, "px");
        }
      }
    };
    var handleChange = function(event) {
      var text2 = event.target;
      var value3 = compositionRef.current ? text2.value : format2(text2.value);
      setInputValue(value3);
    };
    var isDisabled = function() {
      return disabled || readOnly;
    };
    var handleFocus = function(event) {
      if (isDisabled()) return;
      onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
    };
    var handleBlur = function(event) {
      if (isDisabled()) return;
      onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
    };
    var _obj;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-disabled"), disabled), _define_property(_obj, "".concat(classPrefix2, "-readonly"), readOnly), _define_property(_obj, "".concat(classPrefix2, "-rtl"), rtl), _define_property(_obj, "".concat(classPrefix2, "-plain"), plain), _define_property(_obj, "".concat(classPrefix2, "-container"), !plain), _define_property(_obj, "".concat(classPrefix2, "-").concat(status), status), _obj), className)
    }, /* @__PURE__ */ React.createElement("textarea", _object_spread_props(_object_spread({}, rest), {
      ref: textareaRef,
      className: classNames("".concat(classPrefix2, "-textarea"), _define_property({}, "".concat(classPrefix2, "-textarea-disabled"), disabled)),
      style,
      disabled,
      readOnly,
      value: inputValue,
      onChange: handleChange,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onCompositionEnd: function() {
        compositionRef.current = false;
      },
      onCompositionStart: function() {
        compositionRef.current = true;
      },
      rows,
      maxLength: maxLength === -1 ? void 0 : maxLength,
      placeholder: placeholder !== void 0 ? placeholder : locale.placeholder
    })), showCount && /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-limit"), _define_property({}, "".concat(classPrefix2, "-limit-disabled"), disabled))
    }, inputValue.length, "/", maxLength < 0 ? 0 : maxLength)));
  };
  TextArea.displayName = "NutTextArea";
  var defaultProps$K = _object_spread_props(_object_spread({}, ComponentDefaults), {
    percent: 0,
    showText: false,
    animated: false,
    lazy: false,
    delay: 0
  });
  var Progress = function(props) {
    useRtl();
    var _ref = _object_spread({}, defaultProps$K, props), className = _ref.className, style = _ref.style, percent = _ref.percent, background = _ref.background, color = _ref.color, strokeWidth = _ref.strokeWidth, showText = _ref.showText, animated2 = _ref.animated, children = _ref.children, lazy = _ref.lazy, delay = _ref.delay, borderRadius = _ref.borderRadius, fontSize = _ref.fontSize, activeMode = _ref.activeMode, duration = _ref.duration, ariaLabel = _ref.ariaLabel, onActiveEnd = _ref.onActiveEnd, rest = _object_without_properties(_ref, [
      "className",
      "style",
      "percent",
      "background",
      "color",
      "strokeWidth",
      "showText",
      "animated",
      "children",
      "lazy",
      "delay",
      "borderRadius",
      "fontSize",
      "activeMode",
      "duration",
      "ariaLabel",
      "onActiveEnd"
    ]);
    var classPrefix2 = "nut-progress";
    var _obj;
    var classesInner = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-inner"), true), _define_property(_obj, "".concat(classPrefix2, "-active"), animated2), _obj));
    var stylesOuter = {
      height: "".concat(strokeWidth, "px"),
      borderRadius: borderRadius && parseInt(borderRadius.toString()),
      background
    };
    var _useState = _sliced_to_array(React.useState(0), 2), displayPercent = _useState[0], setDispalyPercent = _useState[1];
    var stylesInner = {
      width: "".concat(displayPercent, "%"),
      background: color || "#FF0F23",
      borderRadius: borderRadius && parseInt(borderRadius.toString()),
      transition: "width ".concat(duration || 300, "ms ease-in-out")
    };
    React.useEffect(function() {
      var timer = null;
      if (activeMode === "backwards") {
        setDispalyPercent(0);
        timer = setTimeout(function() {
          setDispalyPercent(percent);
        }, duration || 300);
      } else {
        setDispalyPercent(percent);
      }
      return function() {
        if (timer) {
          clearTimeout(timer);
        }
      };
    }, [
      percent,
      activeMode,
      duration
    ]);
    var _useState1 = _sliced_to_array(React.useState(false), 2), intersecting = _useState1[0], setIntersecting = _useState1[1];
    var progressRef = React.useRef(null);
    var observer = React.useRef(null);
    var initObserver = function() {
      var options2 = {
        threshold: [
          0
        ],
        rootMargin: "0px"
      };
      observer.current = new IntersectionObserver(function(entires, self2) {
        entires.forEach(function(item) {
          setIntersecting(item.isIntersecting);
        });
      }, options2);
      observer.current.observe(progressRef.current);
    };
    var resetObserver = function() {
      observer.current.disconnect && observer.current.disconnect();
    };
    React.useEffect(function() {
      if (lazy) {
        setTimeout(function() {
          if (intersecting) {
            setDispalyPercent(percent);
          } else {
            setDispalyPercent(0);
          }
        }, delay);
      }
    }, [
      intersecting
    ]);
    React.useEffect(function() {
      lazy && initObserver();
      var timer = null;
      if (delay) {
        setDispalyPercent(0);
        timer = setTimeout(function() {
          setDispalyPercent(percent);
        }, delay);
      }
      return function() {
        lazy && resetObserver();
        timer && clearTimeout(timer);
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      ref: progressRef,
      className: classNames(classPrefix2, className),
      style,
      "aria-label": ariaLabel
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-outer"),
      style: stylesOuter
    }, /* @__PURE__ */ React.createElement("div", {
      className: classesInner,
      style: stylesInner,
      onTransitionEnd: function() {
        onActiveEnd === null || onActiveEnd === void 0 ? void 0 : onActiveEnd();
      }
    })), showText && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-text"),
      style: {
        fontSize: fontSize && parseInt(fontSize.toString())
      }
    }, children || "".concat(percent, "%")));
  };
  Progress.displayName = "NutProgress";
  var Preview = function(param) {
    var fileList = param.fileList, previewType = param.previewType, deletable = param.deletable, onDeleteItem = param.onDeleteItem, handleItemClick = param.handleItemClick, previewUrl = param.previewUrl, deleteIcon = param.deleteIcon, children = param.children;
    var renderIcon = function(item) {
      if (item.status === "error") {
        return item.failIcon || /* @__PURE__ */ React.createElement(n$4, {
          color: "#fff"
        });
      }
      return item.loadingIcon || /* @__PURE__ */ React.createElement(s, {
        className: "nut-icon-loading",
        color: "#fff"
      });
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, fileList.length !== 0 && fileList.map(function(item, index2) {
      var _item_status = item.status, status = _item_status === void 0 ? "success" : _item_status, _item_uid = item.uid, uid = _item_uid === void 0 ? index2 : _item_uid, url = item.url, _item_message = item.message, message = _item_message === void 0 ? "" : _item_message, _item_name = item.name, name2 = _item_name === void 0 ? "" : _item_name, _item_type = item.type, type2 = _item_type === void 0 ? "image" : _item_type;
      return /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview ".concat(previewType),
        key: uid
      }, previewType === "picture" && !children && deletable && /* @__PURE__ */ React.createElement("div", {
        onClick: function() {
          return onDeleteItem(item, index2);
        },
        className: "close"
      }, deleteIcon), previewType === "picture" && !children && /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-img"
      }, status === "ready" ? /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-progress"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-progress-msg"
      }, message)) : status !== "success" && /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-progress"
      }, renderIcon(item), /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-progress-msg"
      }, message)), type2.includes("image") ? /* @__PURE__ */ React.createElement(React.Fragment, null, url && /* @__PURE__ */ React.createElement(Image$1, {
        className: "nut-uploader-preview-img-c",
        style: {
          objectFit: "fill"
        },
        src: url,
        alt: "",
        onClick: function() {
          return handleItemClick(item, index2);
        }
      })) : /* @__PURE__ */ React.createElement(React.Fragment, null, previewUrl ? /* @__PURE__ */ React.createElement(Image$1, {
        className: "nut-uploader-preview-img-c",
        src: previewUrl,
        alt: "",
        onClick: function() {
          return handleItemClick(item, index2);
        }
      }) : /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-img-file"
      }, /* @__PURE__ */ React.createElement("div", {
        onClick: function() {
          return handleItemClick(item, index2);
        },
        className: "nut-uploader-preview-img-file-name"
      }, /* @__PURE__ */ React.createElement(d$4, {
        color: "#808080"
      }), /* @__PURE__ */ React.createElement("span", null, "", name2)))), status === "success" && name2 ? /* @__PURE__ */ React.createElement("div", {
        className: "tips"
      }, name2) : null), previewType === "list" && /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-list"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-preview-img-file-name ".concat(status),
        onClick: function() {
          return handleItemClick(item, index2);
        }
      }, /* @__PURE__ */ React.createElement(d$4, null), /* @__PURE__ */ React.createElement("span", null, "", name2)), deletable && /* @__PURE__ */ React.createElement(n$5, {
        color: "#808080",
        className: "nut-uploader-preview-img-file-del",
        onClick: function() {
          return onDeleteItem(item, index2);
        }
      }), item.status === "uploading" && item.percentage && /* @__PURE__ */ React.createElement(Progress, {
        percent: item.percentage,
        color: "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
        showText: false
      })));
    }));
  };
  var defaultProps$J = _object_spread_props(_object_spread({}, ComponentDefaults), {
    maxCount: Number.MAX_VALUE,
    previewType: "picture",
    fit: "cover",
    name: "file",
    accept: "*",
    disabled: false,
    autoUpload: true,
    multiple: false,
    maxFileSize: Number.MAX_VALUE,
    clearInput: true,
    preview: true,
    deletable: true,
    capture: false,
    uploadIcon: /* @__PURE__ */ React.createElement(e, {
      width: "20px",
      height: "20px",
      color: "#808080"
    }),
    deleteIcon: /* @__PURE__ */ React.createElement(n$4, {
      color: "rgba(0,0,0,0.6)"
    }),
    beforeDelete: function(file, files) {
      return true;
    }
  });
  var InternalUploader = function(props, ref) {
    var locale = useConfig().locale;
    var fileListRef = React.useRef([]);
    var _mergeProps = mergeProps(defaultProps$J, props), children = _mergeProps.children, uploadIcon = _mergeProps.uploadIcon, deleteIcon = _mergeProps.deleteIcon, uploadLabel = _mergeProps.uploadLabel, name2 = _mergeProps.name, accept = _mergeProps.accept, defaultValue = _mergeProps.defaultValue, value2 = _mergeProps.value, previewType = _mergeProps.previewType;
    _mergeProps.fit;
    var disabled = _mergeProps.disabled, multiple = _mergeProps.multiple, previewUrl = _mergeProps.previewUrl, preview = _mergeProps.preview, deletable = _mergeProps.deletable, maxCount = _mergeProps.maxCount, capture = _mergeProps.capture, maxFileSize = _mergeProps.maxFileSize, className = _mergeProps.className, autoUpload = _mergeProps.autoUpload, clearInput = _mergeProps.clearInput, upload = _mergeProps.upload, onDelete = _mergeProps.onDelete, onChange = _mergeProps.onChange, onFileItemClick = _mergeProps.onFileItemClick, onOversize = _mergeProps.onOversize, onOverCount = _mergeProps.onOverCount, beforeUpload = _mergeProps.beforeUpload, beforeDelete = _mergeProps.beforeDelete, onUploadQueueChange = _mergeProps.onUploadQueueChange, listUploadRender = _mergeProps.listUploadRender, restProps = _object_without_properties(_mergeProps, [
      "children",
      "uploadIcon",
      "deleteIcon",
      "uploadLabel",
      "name",
      "accept",
      "defaultValue",
      "value",
      "previewType",
      "fit",
      "disabled",
      "multiple",
      "previewUrl",
      "preview",
      "deletable",
      "maxCount",
      "capture",
      "maxFileSize",
      "className",
      "autoUpload",
      "clearInput",
      "upload",
      "onDelete",
      "onChange",
      "onFileItemClick",
      "onOversize",
      "onOverCount",
      "beforeUpload",
      "beforeDelete",
      "onUploadQueueChange",
      "listUploadRender"
    ]);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: [],
      onChange: function(v) {
        onChange === null || onChange === void 0 ? void 0 : onChange(v);
      }
    }), 2), fileList = _usePropsValue[0], setFileList = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState([]), 2), uploadQueue = _useState[0], setUploadQueue = _useState[1];
    var classes = classNames(className, "nut-uploader");
    React.useEffect(function() {
      fileListRef.current = fileList;
    }, [
      fileList
    ]);
    React.useEffect(function() {
      onUploadQueueChange === null || onUploadQueueChange === void 0 ? void 0 : onUploadQueueChange(uploadQueue);
    }, [
      uploadQueue
    ]);
    React.useImperativeHandle(ref, function() {
      return {
        submit: /* @__PURE__ */ _async_to_generator(function() {
          return __generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                return [
                  4,
                  uploadAction(uploadQueue)
                ];
              case 1:
                _state.sent();
                return [
                  2
                ];
            }
          });
        }),
        clear: function() {
          clearUploadQueue();
        }
      };
    });
    var clearUploadQueue = function() {
      var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
      if (index2 > -1) {
        uploadQueue.splice(index2, 1);
        setUploadQueue(uploadQueue);
      } else {
        setUploadQueue([]);
        setFileList([]);
      }
    };
    var idCountRef = React.useRef(0);
    var filterFiles = function(files) {
      var maximum = maxCount * 1;
      var oversizes = new Array();
      var filterFile = files.filter(function(file) {
        if (file.size > maxFileSize) {
          oversizes.push(file);
          return false;
        }
        return true;
      });
      oversizes.length && (onOversize === null || onOversize === void 0 ? void 0 : onOversize(files));
      if (filterFile.length > maximum) {
        onOverCount === null || onOverCount === void 0 ? void 0 : onOverCount(filterFile.length);
        filterFile.splice(maximum, filterFile.length - maximum);
      }
      if (fileList.length !== 0) {
        var index2 = maximum - fileList.length;
        filterFile.splice(index2, filterFile.length - index2);
      }
      return filterFile;
    };
    var deleted = function(file, index2) {
      var deletedFileList = fileListRef.current.filter(function(file2, idx) {
        return idx !== index2;
      });
      onDelete === null || onDelete === void 0 ? void 0 : onDelete(file, deletedFileList);
      setFileList(deletedFileList);
    };
    var onDeleteItem = function(file, index2) {
      clearUploadQueue(index2);
      funcInterceptor(beforeDelete, {
        args: [
          file,
          fileList
        ],
        done: function() {
          return deleted(file, index2);
        }
      });
    };
    var fileChange = /* @__PURE__ */ function() {
      var _ref = _async_to_generator(function(event) {
        var $el, files, _files, filesArr, tasks;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (disabled) return [
                2
              ];
              $el = event.target;
              files = $el.files;
              _files = [];
              filesArr = new Array().slice.call(files);
              if (!beforeUpload) return [
                3,
                2
              ];
              return [
                4,
                beforeUpload(filesArr)
              ];
            case 1:
              _files = _state.sent();
              if (!_files.length) {
                $el.value = "";
                return [
                  2
                ];
              }
              return [
                3,
                3
              ];
            case 2:
              _files = filesArr;
              _state.label = 3;
            case 3:
              _files = filterFiles(_files);
              tasks = _files.map(function(file) {
                var _file_type;
                var info = {
                  uid: idCountRef.current++,
                  status: autoUpload ? "uploading" : "ready",
                  file,
                  message: autoUpload ? locale.uploader.uploading : locale.uploader.waitingUpload,
                  name: file.name,
                  type: file.type
                };
                if (preview && ((_file_type = file.type) === null || _file_type === void 0 ? void 0 : _file_type.includes("image"))) {
                  var reader = new FileReader();
                  reader.onload = function(event2) {
                    fileListRef.current = _to_consumable_array(fileListRef.current).concat([
                      _object_spread_props(_object_spread({}, info), {
                        url: event2.target.result
                      })
                    ]);
                    setFileList(fileListRef.current);
                  };
                  reader.readAsDataURL(file);
                }
                return info;
              });
              if (!!autoUpload) return [
                3,
                4
              ];
              setUploadQueue(tasks);
              return [
                3,
                6
              ];
            case 4:
              return [
                4,
                uploadAction(tasks)
              ];
            case 5:
              _state.sent();
              _state.label = 6;
            case 6:
              if (clearInput) {
                $el.value = "";
              }
              return [
                2
              ];
          }
        });
      });
      return function fileChange2(event) {
        return _ref.apply(this, arguments);
      };
    }();
    var uploadAction = /* @__PURE__ */ function() {
      var _ref = _async_to_generator(function(tasks) {
        var taskIds;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              taskIds = tasks.map(function(task) {
                return task.uid;
              });
              setFileList(fileList.map(function(file) {
                if (taskIds.includes(file.uid)) {
                  return _object_spread_props(_object_spread({}, file), {
                    status: "uploading",
                    message: locale.uploader.uploading
                  });
                }
                return file;
              }));
              return [
                4,
                Promise.all(tasks.map(/* @__PURE__ */ function() {
                  var _ref2 = _async_to_generator(function(currentTask, index2) {
                    var result, list, e2, list1;
                    return __generator(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          _state2.trys.push([
                            0,
                            2,
                            ,
                            3
                          ]);
                          return [
                            4,
                            upload(currentTask.file)
                          ];
                        case 1:
                          result = _state2.sent();
                          list = fileListRef.current.map(function(item) {
                            if (item.uid === currentTask.uid) {
                              item.status = "success";
                              item.message = locale.uploader.success;
                              item.url = result.url;
                            }
                            return item;
                          });
                          setFileList(list);
                          return [
                            3,
                            3
                          ];
                        case 2:
                          e2 = _state2.sent();
                          list1 = fileListRef.current.map(function(item) {
                            if (item.uid === currentTask.uid) {
                              item.status = "error";
                              item.message = locale.uploader.error;
                            }
                            return item;
                          });
                          setFileList(list1);
                          throw e2;
                        case 3:
                          return [
                            2
                          ];
                      }
                    });
                  });
                  return function(currentTask, index2) {
                    return _ref2.apply(this, arguments);
                  };
                }())).catch(function(errs) {
                  return console.error(errs);
                })
              ];
            case 1:
              _state.sent();
              return [
                2
              ];
          }
        });
      });
      return function uploadAction2(tasks) {
        return _ref.apply(this, arguments);
      };
    }();
    var handleItemClick = function(file, index2) {
      onFileItemClick === null || onFileItemClick === void 0 ? void 0 : onFileItemClick(file, index2);
    };
    var renderImageUploader = function() {
      var shouldShow = Number(maxCount) > fileList.length && previewType === "picture";
      return shouldShow && /* @__PURE__ */ React.createElement("div", {
        className: classNames("nut-uploader-upload", previewType, {
          "nut-uploader-upload-disabled": disabled
        })
      }, /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-icon"
      }, uploadIcon, /* @__PURE__ */ React.createElement("span", {
        className: "nut-uploader-icon-tip"
      }, uploadLabel)), /* @__PURE__ */ React.createElement("input", {
        className: "nut-uploader-input",
        type: "file",
        capture,
        name: name2,
        accept,
        disabled,
        multiple,
        onChange: fileChange
      }));
    };
    var renderListUploader = function() {
      if (previewType !== "list") return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "nut-uploader-slot"
      }, listUploadRender || /* @__PURE__ */ React.createElement(Button, {
        size: "small",
        type: "primary"
      }, locale.uploader.list), Number(maxCount) > fileList.length && /* @__PURE__ */ React.createElement("input", {
        className: "nut-uploader-input",
        type: "file",
        capture,
        name: name2,
        accept,
        disabled,
        multiple,
        onChange: fileChange
      }));
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, restProps), renderListUploader(), /* @__PURE__ */ React.createElement(Preview, {
      fileList,
      previewType,
      deletable,
      onDeleteItem,
      handleItemClick,
      previewUrl,
      children,
      deleteIcon
    }), renderImageUploader());
  };
  var Uploader = /* @__PURE__ */ React.forwardRef(InternalUploader);
  Uploader.displayName = "NutUploader";
  var defaultProps$I = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    description: "",
    options: [],
    optionKey: {
      name: "name",
      description: "description"
    },
    cancelText: "",
    onCancel: function() {
    },
    onSelect: function() {
    }
  });
  var ActionSheet = function(props) {
    var _mergeProps = mergeProps(defaultProps$I, props), children = _mergeProps.children, cancelText = _mergeProps.cancelText, optionKey = _mergeProps.optionKey, title = _mergeProps.title, description = _mergeProps.description, options2 = _mergeProps.options, onCancel = _mergeProps.onCancel, onSelect = _mergeProps.onSelect, visible = _mergeProps.visible, className = _mergeProps.className, style = _mergeProps.style, rest = _object_without_properties(_mergeProps, [
      "children",
      "cancelText",
      "optionKey",
      "title",
      "description",
      "options",
      "onCancel",
      "onSelect",
      "visible",
      "className",
      "style"
    ]);
    var classPrefix2 = "nut-actionsheet";
    var cancelActionSheet = function() {
      onCancel && onCancel();
    };
    var chooseItem = function(item, index2) {
      if (!item.disabled) {
        onSelect && onSelect(item, index2);
      }
    };
    return /* @__PURE__ */ React.createElement(Popup, _object_spread_props(_object_spread({}, rest), {
      round: true,
      visible,
      position: "bottom",
      title,
      description,
      className: classPrefix2,
      onClose: function() {
        onCancel && onCancel();
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(className),
      style
    }, options2.length ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-list")
    }, options2.map(function(item, index2) {
      var statusClass = "".concat(item.disabled ? "".concat(classPrefix2, "-item-disabled") : "", " ").concat(item.danger ? "".concat(classPrefix2, "-item-danger") : "");
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-item ").concat(statusClass),
        key: index2,
        onClick: function() {
          return chooseItem(item, index2);
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-item-name ").concat(statusClass)
      }, item[optionKey.name]), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-item-description ").concat(statusClass)
      }, item[optionKey.description]));
    })) : children, cancelText && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-cancel"),
      onClick: function() {
        return cancelActionSheet();
      }
    }, cancelText)), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-safe-area")
    }));
  };
  ActionSheet.displayName = "NutActionSheet";
  var destroyList = [];
  function ConfirmDialog(props) {
    return /* @__PURE__ */ React.createElement(Dialog, props, props.content);
  }
  var confirm = function(config2, renderFunc) {
    var div2 = document.createElement("div");
    document.body.appendChild(div2);
    var dialogConfig = _object_spread_props(_object_spread({}, config2), {
      visible: false
    });
    var render$1 = function(props, callback) {
      render(/* @__PURE__ */ React.createElement(ConfirmDialog, _object_spread_props(_object_spread({}, props), {
        onCancel: function() {
          return onCancel();
        }
      })), div2);
      callback && callback();
    };
    var renderFunction = render$1;
    var onConfirm = function() {
      var _onConfirm = config2.onConfirm || config2.onConfirm;
      var ret = _onConfirm === null || _onConfirm === void 0 ? void 0 : _onConfirm();
      if (ret && ret.then) {
        renderFunction(dialogConfig);
        return ret.then(function() {
          onCancel(true);
        }, function(e2) {
          console.error(e2);
          renderFunction(dialogConfig);
        });
      }
      if (!ret) {
        onCancel(true);
      }
    };
    dialogConfig.onConfirm = onConfirm;
    dialogConfig.visible = true;
    renderFunction(dialogConfig);
    var destroy = function() {
      unmount(div2);
      if (div2 === null || div2 === void 0 ? void 0 : div2.parentNode) {
        div2.parentNode.removeChild(div2);
      }
      for (var i2 = 0; i2 < destroyList.length; i2++) {
        var fn = destroyList[i2];
        if (fn === close) {
          destroyList.splice(i2, 1);
          break;
        }
      }
    };
    var onCancel = function(confirm2) {
      !confirm2 && config2.onCancel && config2.onCancel();
      dialogConfig.visible = false;
      dialogConfig.onClose = function() {
        config2.onClose && config2.onClose();
      };
      renderFunction(dialogConfig, function() {
        destroy();
      });
    };
    var update2 = function(newConfig) {
      dialogConfig = _object_spread({}, dialogConfig, newConfig);
      renderFunction(dialogConfig);
    };
    var close = function() {
      dialogConfig.visible = false;
      dialogConfig.onClose = function() {
        config2.onClose && config2.onClose();
        destroy();
      };
      renderFunction(dialogConfig);
    };
    destroyList.push(close);
    return {
      close,
      update: update2
    };
  };
  var defaultContentProps = {
    visible: false,
    title: "",
    header: "",
    footer: "",
    close: "",
    footerDirection: "horizontal",
    onClick: function() {
    }
  };
  var Content = function(props) {
    var _$_object_spread = _object_spread({}, defaultContentProps, props), visible = _$_object_spread.visible, title = _$_object_spread.title, header = _$_object_spread.header, footer = _$_object_spread.footer, close = _$_object_spread.close, footerDirection = _$_object_spread.footerDirection, children = _$_object_spread.children, style = _$_object_spread.style, className = _$_object_spread.className, onClick = _$_object_spread.onClick;
    var classPrefix2 = "nut-dialog";
    var renderHeader = function() {
      return title && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-header")
      }, title);
    };
    var renderFooter = function() {
      return footer && /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-footer"), _define_property({}, footerDirection, footerDirection))
      }, footer);
    };
    var handleClick = function(e2) {
      onClick && onClick(e2);
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-outer"), className),
      style,
      onClick: handleClick
    }, close, header, /* @__PURE__ */ React.createElement("div", {
      className: classPrefix2,
      style: {
        display: visible ? "flex" : "none"
      }
    }, renderHeader(), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-content")
    }, children), renderFooter()));
  };
  Content.displayName = "NutContent";
  var defaultProps$H = _object_spread_props(_object_spread({}, defaultOverlayProps, defaultContentProps), {
    title: "",
    content: "",
    header: "",
    footer: "",
    confirmText: "",
    cancelText: "",
    closeOnOverlayClick: true,
    hideConfirmButton: false,
    hideCancelButton: false,
    disableConfirmButton: false,
    footerDirection: "horizontal",
    lockScroll: true,
    closeIconPosition: "bottom",
    closeIcon: false,
    overlay: true,
    overlayStyle: {},
    overlayClassName: "nut-dialog-overlay",
    zIndex: 1200,
    beforeCancel: function() {
      return true;
    },
    beforeClose: function() {
      return true;
    },
    onCancel: function() {
    },
    onClose: function() {
    },
    onOverlayClick: function() {
      return true;
    }
  });
  var BaseDialog = function(props, ref) {
    var _mergeProps = mergeProps(defaultProps$H, props), closeOnOverlayClick = _mergeProps.closeOnOverlayClick, confirmText = _mergeProps.confirmText, cancelText = _mergeProps.cancelText, children = _mergeProps.children, className = _mergeProps.className, closeIconPosition = _mergeProps.closeIconPosition, closeIcon = _mergeProps.closeIcon, content2 = _mergeProps.content, disableConfirmButton = _mergeProps.disableConfirmButton, footer = _mergeProps.footer, footerDirection = _mergeProps.footerDirection, header = _mergeProps.header, hideConfirmButton = _mergeProps.hideConfirmButton, hideCancelButton = _mergeProps.hideCancelButton, lockScroll = _mergeProps.lockScroll, overlay = _mergeProps.overlay, overlayStyle = _mergeProps.overlayStyle, overlayClassName = _mergeProps.overlayClassName, style = _mergeProps.style, title = _mergeProps.title, visible = _mergeProps.visible, zIndex = _mergeProps.zIndex, beforeCancel = _mergeProps.beforeCancel, beforeClose = _mergeProps.beforeClose, onClose = _mergeProps.onClose, onCancel = _mergeProps.onCancel, onConfirm = _mergeProps.onConfirm, onOverlayClick = _mergeProps.onOverlayClick;
    var classPrefix2 = "nut-dialog";
    var locale = useConfig().locale;
    var _useState = _sliced_to_array(React.useState(false), 2), loading = _useState[0], setLoading = _useState[1];
    var renderFooter = function() {
      if (footer === null) return "";
      var handleCancel = function(e2) {
        e2.stopPropagation();
        if (!(beforeCancel === null || beforeCancel === void 0 ? void 0 : beforeCancel())) return;
        if (!(beforeClose === null || beforeClose === void 0 ? void 0 : beforeClose())) return;
        onClose();
        onCancel();
      };
      var handleOk = /* @__PURE__ */ function() {
        var _ref = _async_to_generator(function(e2) {
          return __generator(this, function(_state) {
            switch (_state.label) {
              case 0:
                e2.stopPropagation();
                setLoading(true);
                _state.label = 1;
              case 1:
                _state.trys.push([
                  1,
                  3,
                  ,
                  4
                ]);
                return [
                  4,
                  onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(e2)
                ];
              case 2:
                _state.sent();
                setLoading(false);
                onClose();
                return [
                  3,
                  4
                ];
              case 3:
                _state.sent();
                setLoading(false);
                return [
                  3,
                  4
                ];
              case 4:
                return [
                  2
                ];
            }
          });
        });
        return function handleOk2(e2) {
          return _ref.apply(this, arguments);
        };
      }();
      var btnClass = hideCancelButton || hideConfirmButton ? "".concat(classPrefix2, "-footer-block") : "";
      var renderCancelOfVertical = function() {
        return !hideCancelButton && /* @__PURE__ */ React.createElement("div", {
          style: {
            order: 2
          },
          className: "".concat(classPrefix2, "-footer-cancel ").concat(btnClass),
          onClick: function(e2) {
            return handleCancel(e2);
          }
        }, cancelText || locale.cancel);
      };
      var renderCancel = function() {
        return !hideCancelButton && /* @__PURE__ */ React.createElement(Button, {
          type: "default",
          size: "large",
          className: "".concat(classPrefix2, "-footer-cancel ").concat(btnClass),
          onClick: function(e2) {
            return handleCancel(e2);
          }
        }, cancelText || locale.cancel);
      };
      var renderConfirm = function() {
        return !hideConfirmButton && /* @__PURE__ */ React.createElement(Button, {
          type: "primary",
          size: "large",
          className: classNames("".concat(classPrefix2, "-footer-ok ").concat(btnClass), {
            disabled: disableConfirmButton
          }),
          disabled: disableConfirmButton,
          onClick: function(e2) {
            return handleOk(e2);
          },
          loading
        }, confirmText || locale.confirm);
      };
      return footer || /* @__PURE__ */ React.createElement(React.Fragment, null, footerDirection === "vertical" ? /* @__PURE__ */ React.createElement(React.Fragment, null, renderConfirm(), renderCancelOfVertical()) : /* @__PURE__ */ React.createElement(React.Fragment, null, renderCancel(), renderConfirm()));
    };
    var renderCloseIcon = function() {
      if (!closeIcon) return null;
      var handleCancel = function() {
        if (!(beforeCancel === null || beforeCancel === void 0 ? void 0 : beforeCancel())) return;
        if (!(beforeClose === null || beforeClose === void 0 ? void 0 : beforeClose())) return;
        onClose();
        onCancel();
      };
      var _obj;
      var closeClasses = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-close"), true), _define_property(_obj, "".concat(classPrefix2, "-close-").concat(closeIconPosition), true), _obj));
      var systomIcon = closeIconPosition !== "bottom" ? /* @__PURE__ */ React.createElement(n$6, null) : /* @__PURE__ */ React.createElement(n$4, null);
      return /* @__PURE__ */ React.createElement("div", {
        className: closeClasses,
        onClick: handleCancel
      }, /* @__PURE__ */ React.isValidElement(closeIcon) ? closeIcon : systomIcon);
    };
    var onHandleClickOverlay = function(e2) {
      if (closeOnOverlayClick && visible && e2.target === e2.currentTarget) {
        var closed = onOverlayClick && onOverlayClick(e2);
        closed && onClose();
        closed && onCancel();
      }
    };
    var renderContent = function() {
      return /* @__PURE__ */ React.createElement(CSSTransition, {
        in: visible,
        timeout: 300,
        classNames: "fadeDialog",
        unmountOnExit: true,
        appear: true
      }, /* @__PURE__ */ React.createElement(Content, {
        className,
        style: _object_spread({
          zIndex
        }, style),
        title,
        header,
        close: renderCloseIcon(),
        footer: renderFooter(),
        footerDirection,
        visible
      }, content2 || children));
    };
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        display: visible ? "block" : "none"
      }
    }, overlay && /* @__PURE__ */ React.createElement(Overlay, {
      zIndex,
      visible,
      style: overlayStyle,
      className: overlayClassName,
      closeOnOverlayClick,
      lockScroll,
      onClick: onHandleClickOverlay
    }), renderContent());
  };
  var Dialog = /* @__PURE__ */ React.forwardRef(BaseDialog);
  Dialog.confirm = function(props) {
    return confirm(props);
  };
  [
    "alert"
  ].forEach(function() {
    Dialog.alert = function(props) {
      return confirm(_object_spread({}, props));
    };
  });
  Dialog.displayName = "NutDialog";
  var defaultProps$G = _object_spread_props(_object_spread({}, ComponentDefaults), {
    attract: false,
    direction: void 0,
    boundary: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  });
  var Drag = function(props) {
    var _ref = _object_spread({}, defaultProps$G, props), attract = _ref.attract, direction = _ref.direction, boundary = _ref.boundary, onDrag = _ref.onDrag, onDragStart = _ref.onDragStart, onDragEnd = _ref.onDragEnd, children = _ref.children, className = _ref.className, style = _ref.style, reset = _object_without_properties(_ref, [
      "attract",
      "direction",
      "boundary",
      "onDrag",
      "onDragStart",
      "onDragEnd",
      "children",
      "className",
      "style"
    ]);
    var classPrefix2 = "nut-drag";
    var _useState = _sliced_to_array(React.useState(boundary), 2), boundaryState = _useState[0], setBoundaryState = _useState[1];
    var myDrag = React.useRef(null);
    var _useSpring = _sliced_to_array(useSpring(function() {
      return {
        x: 0,
        y: 0
      };
    }), 2), currstyle = _useSpring[0], api = _useSpring[1];
    var middleLine = React.useRef(0);
    var getInfo = function() {
      var el = myDrag.current;
      if (el) {
        var offsetTop = el.offsetTop, offsetLeft = el.offsetLeft;
        var _el_querySelector = el.querySelector(".".concat(classPrefix2, "-inner")), offsetWidth = _el_querySelector.offsetWidth, offsetHeight = _el_querySelector.offsetHeight;
        var _document_documentElement = document.documentElement, clientWidth = _document_documentElement.clientWidth, clientHeight = _document_documentElement.clientHeight;
        var top = boundary.top, left = boundary.left, bottom = boundary.bottom, right = boundary.right;
        setBoundaryState({
          top: -offsetTop + top,
          left: -offsetLeft + left,
          bottom: clientHeight - offsetHeight - offsetTop - bottom,
          right: clientWidth - offsetWidth - offsetLeft - right
        });
        middleLine.current = clientWidth - offsetWidth - offsetLeft - (clientWidth - offsetWidth) / 2;
      }
    };
    var bind = useDrag(function(state) {
      var down = state.down, last = state.last, _state_offset = _sliced_to_array(state.offset, 2), x = _state_offset[0], y = _state_offset[1], first = state.first;
      first && (onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart());
      onDrag === null || onDrag === void 0 ? void 0 : onDrag({
        offset: [
          x,
          y
        ]
      });
      last && (onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
        offset: [
          x,
          y
        ]
      }));
      api.start({
        x,
        y,
        immediate: down
      });
      if (last) {
        if (direction !== "y" && attract) {
          if (x < middleLine.current) {
            api.start({
              x: boundaryState.left,
              y,
              immediate: down
            });
          } else {
            api.start({
              x: boundaryState.right,
              y,
              immediate: down
            });
          }
        }
      }
    }, {
      from: function() {
        return [
          currstyle.x.get(),
          currstyle.y.get()
        ];
      },
      axis: direction,
      bounds: boundaryState
    });
    React.useEffect(function() {
      getInfo();
    }, [
      myDrag
    ]);
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      style,
      className: "".concat(classPrefix2, " ").concat(className)
    }, reset), {
      ref: myDrag
    }), /* @__PURE__ */ React.createElement(animated.div, _object_spread_props(_object_spread({
      style: currstyle
    }, bind()), {
      className: "".concat(classPrefix2, "-inner")
    }), children));
  };
  Drag.displayName = "NutDrag";
  var defaultStatus = {
    empty: "https://storage.360buyimg.com/imgtools/30186cfda0-0d3eee40-c0ac-11ee-9382-9125782aa3b8.png",
    error: "https://storage.360buyimg.com/imgtools/f3278d0ebb-0ce360c0-c0ac-11ee-8375-193101bb1a46.png",
    network: "https://storage.360buyimg.com/imgtools/43c30f7e29-0d483d10-c0ac-11ee-bec4-eb4d2a09a51d.png"
  };
  var defaultProps$F = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: "",
    description: "",
    imageSize: "",
    size: "base",
    status: "empty",
    actions: []
  });
  var classPrefix$e = "nut-empty";
  var Empty = function(props) {
    var _ref = _object_spread({}, defaultProps$F, props), image = _ref.image, imageSize = _ref.imageSize, title = _ref.title, description = _ref.description, children = _ref.children, className = _ref.className, size = _ref.size, status = _ref.status, actions = _ref.actions;
    _ref.style;
    var rest = _object_without_properties(_ref, [
      "image",
      "imageSize",
      "title",
      "description",
      "children",
      "className",
      "size",
      "status",
      "actions",
      "style"
    ]);
    var _useState = _sliced_to_array(React.useState({}), 2), imgStyle = _useState[0], setImgStyle = _useState[1];
    var imageUrl = image || defaultStatus[status];
    var imageNode = typeof imageUrl === "string" ? /* @__PURE__ */ React.createElement("img", {
      style: {
        width: "100%",
        height: "100%"
      },
      src: imageUrl,
      alt: "empty"
    }) : imageUrl;
    React.useEffect(function() {
      setImgStyle(function() {
        if (!imageSize) {
          return {};
        }
        if (typeof imageSize === "number") {
          return {
            width: "".concat(imageSize, "px"),
            height: "".concat(imageSize, "px")
          };
        }
        return {
          width: imageSize,
          height: imageSize
        };
      });
    }, [
      imageSize
    ]);
    var cls = classNames(classPrefix$e, className);
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: cls
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$e, "-").concat(size),
      style: imgStyle
    }, imageNode), typeof title === "string" && title ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$e, "-title")
    }, title) : title, typeof description === "string" ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$e, "-description")
    }, description) : description, actions.length ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix$e, "-actions-").concat(size)
    }, actions.map(function(action, index2) {
      action.text;
      var rest2 = _object_without_properties(action, [
        "text"
      ]);
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$e, "-action"),
        key: index2
      }, /* @__PURE__ */ React.createElement(Button, rest2, action === null || action === void 0 ? void 0 : action.text));
    })) : null, children);
  };
  Empty.displayName = "NutEmpty";
  var defaultProps$E = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "default",
    hasMore: true,
    threshold: 200,
    target: "",
    capture: false,
    pullRefresh: false
  });
  var classPrefix$d = "nut-infiniteloading";
  var InfiniteLoading = function(props) {
    var getBottomTipsText = function getBottomTipsText2() {
      if (isInfiniting) {
        return loadingText || locale.infiniteloading.loadText;
      }
      if (!hasMore) {
        return loadMoreText || locale.infiniteloading.loadMoreText;
      }
      return null;
    };
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$E, props), children = _ref.children, type2 = _ref.type, hasMore = _ref.hasMore, threshold = _ref.threshold, target = _ref.target, capture = _ref.capture, pullRefresh = _ref.pullRefresh, pullingText = _ref.pullingText, loadingText = _ref.loadingText, loadMoreText = _ref.loadMoreText, className = _ref.className, onRefresh = _ref.onRefresh, onLoadMore = _ref.onLoadMore, onScroll = _ref.onScroll, restProps = _object_without_properties(_ref, [
      "children",
      "type",
      "hasMore",
      "threshold",
      "target",
      "capture",
      "pullRefresh",
      "pullingText",
      "loadingText",
      "loadMoreText",
      "className",
      "onRefresh",
      "onLoadMore",
      "onScroll"
    ]);
    var _useState = _sliced_to_array(React.useState(false), 2), isInfiniting = _useState[0], setIsInfiniting = _useState[1];
    var scroller = React.useRef(null);
    var refreshTop = React.useRef(null);
    var scrollEl = React.useRef(null);
    var isTouching = React.useRef(false);
    var beforeScrollTop = React.useRef(0);
    var refreshMaxH = React.useRef(0);
    var y = React.useRef(0);
    var distance = React.useRef(0);
    var classes = classNames(classPrefix$d, className, "".concat(classPrefix$d, "-").concat(type2));
    React.useEffect(function() {
      var _scrollEl_current;
      if (target && document.getElementById(target)) {
        scrollEl.current = document.getElementById(target);
      } else {
        scrollEl.current = window;
      }
      (_scrollEl_current = scrollEl.current) === null || _scrollEl_current === void 0 ? void 0 : _scrollEl_current.addEventListener("scroll", handleScroll, capture);
      return function() {
        var _scrollEl_current2;
        (_scrollEl_current2 = scrollEl.current) === null || _scrollEl_current2 === void 0 ? void 0 : _scrollEl_current2.removeEventListener("scroll", handleScroll, capture);
      };
    }, [
      hasMore,
      isInfiniting,
      onLoadMore
    ]);
    React.useEffect(function() {
      var element = scroller.current;
      element.addEventListener("touchmove", touchMove, {
        passive: false
      });
      return function() {
        element.removeEventListener("touchmove", touchMove, {
          passive: false
        });
      };
    }, []);
    var getStyle = function() {
      return {
        height: distance.current < 0 ? "0px" : "".concat(distance.current, "px"),
        transition: isTouching.current ? "height 0s cubic-bezier(0.25,0.1,0.25,1)" : "height 0.2s cubic-bezier(0.25,0.1,0.25,1)"
      };
    };
    var handleScroll = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function() {
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (!isScrollAtBottom() || !hasMore || isInfiniting) {
                return [
                  2
                ];
              }
              setIsInfiniting(true);
              return [
                4,
                onLoadMore === null || onLoadMore === void 0 ? void 0 : onLoadMore()
              ];
            case 1:
              _state.sent();
              infiniteDone();
              return [
                2
              ];
          }
        });
      });
      return function handleScroll2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var infiniteDone = function() {
      setIsInfiniting(false);
    };
    var getRefreshTop = function() {
      return refreshTop.current;
    };
    var refreshDone = function() {
      distance.current = 0;
      getRefreshTop().style.height = "".concat(distance.current, "px");
      isTouching.current = false;
    };
    var touchStart = function(event) {
      if (beforeScrollTop.current === 0 && !isTouching.current && pullRefresh) {
        y.current = event.touches[0].pageY;
        isTouching.current = true;
        var childHeight = getRefreshTop().firstElementChild.offsetHeight;
        refreshMaxH.current = Math.floor(childHeight * 1 + 10);
      }
    };
    var touchMove = function(event) {
      distance.current = event.touches[0].pageY - y.current;
      if (distance.current > 0 && isTouching.current) {
        event.preventDefault();
        if (distance.current >= refreshMaxH.current) {
          distance.current = refreshMaxH.current;
          getRefreshTop().style.height = "".concat(distance.current, "px");
        } else {
          getRefreshTop().style.height = "".concat(distance.current, "px");
        }
      } else {
        distance.current = 0;
        getRefreshTop().style.height = "".concat(distance.current, "px");
        isTouching.current = false;
      }
    };
    var touchEnd = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function() {
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              if (!(distance.current < refreshMaxH.current)) return [
                3,
                1
              ];
              distance.current = 0;
              getRefreshTop().style.height = "".concat(distance.current, "px");
              isTouching.current = false;
              return [
                3,
                3
              ];
            case 1:
              return [
                4,
                onRefresh === null || onRefresh === void 0 ? void 0 : onRefresh()
              ];
            case 2:
              _state.sent();
              refreshDone();
              _state.label = 3;
            case 3:
              return [
                2
              ];
          }
        });
      });
      return function touchEnd2() {
        return _ref2.apply(this, arguments);
      };
    }();
    var getWindowScrollTop = function() {
      return window.scrollY !== void 0 ? window.scrollY : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    };
    var calculateTopPosition = function(el) {
      return !el ? 0 : el.offsetTop + calculateTopPosition(el.offsetParent);
    };
    var isScrollAtBottom = function() {
      var offsetDistance = 0;
      var resScrollTop = 0;
      var direction = "down";
      var windowScrollTop = getWindowScrollTop();
      if (!target || !document.getElementById(target)) {
        if (scroller.current) {
          offsetDistance = calculateTopPosition(scroller.current) + scroller.current.offsetHeight - windowScrollTop - window.innerHeight;
        }
        resScrollTop = windowScrollTop;
      } else {
        var _scrollEl_current = scrollEl.current, scrollHeight = _scrollEl_current.scrollHeight, clientHeight = _scrollEl_current.clientHeight, scrollTop = _scrollEl_current.scrollTop;
        offsetDistance = scrollHeight - clientHeight - scrollTop;
        resScrollTop = scrollTop;
      }
      if (beforeScrollTop.current > resScrollTop) {
        direction = "up";
      } else {
        direction = "down";
      }
      beforeScrollTop.current = resScrollTop;
      onScroll && onScroll(resScrollTop);
      return offsetDistance <= threshold && direction === "down";
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      ref: scroller,
      onTouchStart: touchStart,
      onTouchEnd: touchEnd
    }, restProps), /* @__PURE__ */ React.createElement("div", {
      className: "nut-infinite-top",
      ref: refreshTop,
      style: getStyle()
    }, /* @__PURE__ */ React.createElement("div", {
      className: "nut-infinite-top-tips"
    }, pullingText || locale.infiniteloading.pullRefreshText)), /* @__PURE__ */ React.createElement("div", {
      className: "nut-infinite-container"
    }, children), /* @__PURE__ */ React.createElement("div", {
      className: "nut-infinite-bottom"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "nut-infinite-bottom-tips"
    }, getBottomTipsText())));
  };
  InfiniteLoading.displayName = "NutInfiniteLoading";
  var loadingMap = {
    circular: d$3,
    spinner: s
  };
  var defaultProps$D = _object_spread_props(_object_spread({}, ComponentDefaults), {
    // ,Loading1,loading
    type: "circular",
    direction: "horizontal",
    lottieProps: {}
  });
  var Loading = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _ref = _object_spread({}, defaultProps$D, props), className = _ref.className, style = _ref.style, children = _ref.children, direction = _ref.direction, icon = _ref.icon, rest = _object_without_properties(_ref, [
      "className",
      "style",
      "children",
      "direction",
      "icon"
    ]);
    var classPrefix2 = "nut-loading";
    var getLoadingIcon = function() {
      var LoadingIcon = loadingMap[rest.type] || d$3;
      return /* @__PURE__ */ React.createElement(LoadingIcon, {
        className: "".concat(classPrefix2, "-icon")
      });
    };
    var iconboxClassName = function() {
      return !icon ? "".concat(classPrefix2, "-icon-box") : "";
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, direction === "vertical" ? "".concat(classPrefix2, "-vertical") : "", className),
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: iconboxClassName()
    }, icon || getLoadingIcon()), children ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-text")
    }, children) : null);
  });
  Loading.displayName = "NutLoading";
  var defaultProps$C = _object_spread_props(_object_spread({}, ComponentDefaults), {
    align: "left",
    direction: "horizontal",
    list: [],
    duration: 1e3,
    height: 40,
    content: "",
    closeable: false,
    wrap: false,
    leftIcon: /* @__PURE__ */ React.createElement(n$1, {
      width: 16,
      height: 16
    }),
    rightIcon: null,
    right: null,
    delay: 1,
    scrollable: null,
    speed: 50
  });
  var NoticeBar = function(props) {
    var rtl = useRtl();
    var _$_object_spread = _object_spread({}, defaultProps$C, props), children = _$_object_spread.children, className = _$_object_spread.className, style = _$_object_spread.style, align = _$_object_spread.align, direction = _$_object_spread.direction, list = _$_object_spread.list, duration = _$_object_spread.duration, height2 = _$_object_spread.height, content2 = _$_object_spread.content, closeable = _$_object_spread.closeable, wrap = _$_object_spread.wrap, leftIcon = _$_object_spread.leftIcon, rightIcon = _$_object_spread.rightIcon, right = _$_object_spread.right, delay = _$_object_spread.delay, scrollable = _$_object_spread.scrollable, speed = _$_object_spread.speed, close = _$_object_spread.close, click = _$_object_spread.click, onClose = _$_object_spread.onClose, onClick = _$_object_spread.onClick, onItemClick = _$_object_spread.onItemClick;
    var classPrefix2 = "nut-noticebar";
    var wrapRef = React.useRef(null);
    var contentRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(true), 2), showNoticeBar = _useState[0], SetShowNoticeBar = _useState[1];
    var scrollList = React.useRef([]);
    var _useState1 = _sliced_to_array(React.useState(0), 2), wrapWidth = _useState1[0], SetWrapWidth = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(true), 2), firstRound = _useState2[0], SetFirstRound = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(0), 2), animationDuration = _useState3[0], SetAnimationDuration = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState(0), 2), offsetWidth = _useState4[0], SetOffsetW = _useState4[1];
    var _useState5 = _sliced_to_array(React.useState(""), 2), animationClass = _useState5[0], SetAnimationClass = _useState5[1];
    var _useState6 = _sliced_to_array(React.useState(false), 2), animate = _useState6[0], SetAnimate = _useState6[1];
    var _useState7 = _sliced_to_array(React.useState(0), 2), timer = _useState7[0], SetTimer = _useState7[1];
    var _useState8 = _sliced_to_array(React.useState(null), 2), isCanScroll = _useState8[0], SetIsCanScroll = _useState8[1];
    var isVertical = direction === "vertical";
    var _useState9 = _sliced_to_array(React.useState(null), 2), rect = _useState9[0], setRect = _useState9[1];
    var active2 = 0;
    var _useState10 = _sliced_to_array(React.useState(false), 2), ready = _useState10[0], setReady = _useState10[1];
    var container = React.useRef(null);
    var innerRef = React.useRef(null);
    var swiperRef = React.useRef({
      moving: false,
      autoplayTimer: null,
      width: 0,
      height: 0,
      offset: 0,
      size: 0
    });
    var _useState11 = _sliced_to_array(React.useState([]), 2), childOffset = _useState11[0], setChildOffset = _useState11[1];
    var _useState12 = _sliced_to_array(React.useState(0), 2), offset = _useState12[0], setOffset = _useState12[1];
    var _useMemo = React.useMemo(function() {
      var childCount2 = 0;
      var childs2 = React.Children.map(children, function(child) {
        if (!/* @__PURE__ */ React.isValidElement(child)) return null;
        childCount2++;
        return child;
      });
      return {
        childs: childs2,
        childCount: childCount2
      };
    }, [
      children
    ]), childs = _useMemo.childs, childCount = _useMemo.childCount;
    var trackSize = childCount * Number(height2);
    var minOffset = function() {
      if (rect) {
        var base = isVertical ? rect.height : rect.width;
        return base - Number(height2) * childCount;
      }
      return 0;
    }();
    React.useEffect(function() {
      if (isVertical) {
        if (children) {
          scrollList.current = [].concat(childs);
        } else {
          scrollList.current = [].concat(list);
          startRollEasy();
        }
      } else {
        initScrollWrap();
      }
      return function() {
        clearInterval(timer);
      };
    }, []);
    React.useEffect(function() {
      initScrollWrap();
    }, [
      content2
    ]);
    React.useEffect(function() {
      if (list && list.length) {
        scrollList.current = [].concat(list);
      }
    }, [
      list
    ]);
    var initScrollWrap = function(value2) {
      if (showNoticeBar === false) {
        return;
      }
      setTimeout(function() {
        if (!wrapRef.current || !contentRef.current) {
          return;
        }
        var wrapW = getRect(wrapRef.current).width;
        var offsetW = getRect(contentRef.current).width;
        var canScroll = align === "left" && scrollable == null ? offsetW > wrapW : scrollable;
        SetIsCanScroll(canScroll);
        if (canScroll) {
          SetWrapWidth(wrapW);
          SetOffsetW(offsetW);
          SetAnimationDuration(offsetW / speed);
          SetAnimationClass("play");
        } else {
          SetAnimationClass("");
        }
      }, 0);
    };
    var handleClick = function(event) {
      click && click(event);
      onClick && onClick(event);
    };
    var onClickIcon = function(event) {
      event.stopPropagation();
      SetShowNoticeBar(!closeable);
      close && close(event);
      onClose && onClose(event);
    };
    var onAnimationEnd = function() {
      SetFirstRound(false);
      setTimeout(function() {
        SetAnimationDuration((offsetWidth + wrapWidth) / speed);
        SetAnimationClass("play-infinite");
      }, 0);
    };
    var time2 = height2 / speed / 4 < 1 ? Number((height2 / speed / 4).toFixed(1)) * 1e3 : ~~(height2 / speed / 4) * 1e3;
    var startRollEasy = function() {
      showhorseLamp();
      var timerCurr = window.setInterval(showhorseLamp, time2 + Number(duration));
      SetTimer(timerCurr);
    };
    var showhorseLamp = function() {
      SetAnimate(true);
      setTimeout(function() {
        scrollList.current.push(scrollList.current[0]);
        scrollList.current.shift();
        SetAnimate(false);
      }, time2);
    };
    var handleClickIcon = function(event) {
      event.stopPropagation();
      SetShowNoticeBar(!closeable);
      close && close(event);
      onClose && onClose(event);
    };
    var isEllipsis = function() {
      if (isCanScroll == null && align === "left") {
        return wrap;
      }
      return !isCanScroll && !wrap;
    };
    var contentStyle = {
      animationDelay: "".concat(firstRound ? delay : 0, "s"),
      animationDuration: "".concat(animationDuration, "s"),
      transform: "translateX(".concat(firstRound ? 0 : "".concat(rtl ? -wrapWidth : wrapWidth, "px"), ")")
    };
    var barStyle = {
      height: isVertical ? "".concat(height2, "px") : ""
    };
    var duringTime = height2 / speed / 4 < 1 ? Number((height2 / speed / 4).toFixed(1)) : ~~(height2 / speed / 4);
    var noDuring = height2 / speed < 1 ? (height2 / speed).toFixed(1) : ~~(height2 / speed);
    var horseLampStyle = {
      transition: animate ? "all ".concat(duringTime === 0 ? noDuring : duringTime, "s") : "",
      marginTop: animate ? "-".concat(height2, "px") : ""
    };
    var init = function() {
      var active3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var rects = getRect(container === null || container === void 0 ? void 0 : container.current);
      var _active = Math.max(Math.min(childCount - 1, active3), 0);
      var _height = rects.height;
      trackSize = childCount * Number(_height);
      var targetOffset = getOffset(_active);
      swiperRef.current.moving = true;
      if (ready) {
        swiperRef.current.moving = false;
      }
      active3 = _active;
      setRect(rects);
      setOffset(targetOffset);
      setReady(true);
    };
    React.useEffect(function() {
      if (ready) {
        stopAutoPlay();
        autoplay();
      }
      return function() {
        setReady(false);
      };
    }, [
      ready
    ]);
    React.useEffect(function() {
      if (isVertical && children) {
        init();
        stopAutoPlay();
        autoplay();
      }
    }, [
      children,
      container === null || container === void 0 ? void 0 : container.current
    ]);
    var stopAutoPlay = function() {
      clearTimeout(swiperRef.current.autoplayTimer);
      swiperRef.current.autoplayTimer = null;
    };
    var autoplay = function() {
      if (childCount <= 1) return;
      stopAutoPlay();
      swiperRef.current.autoplayTimer = setTimeout(function() {
        next();
        autoplay();
      }, Number(duration) + 100 * speed);
    };
    var move = function(param) {
      var _param_pace = param.pace, pace = _param_pace === void 0 ? 0 : _param_pace, _param_offset = param.offset, offset2 = _param_offset === void 0 ? 0 : _param_offset;
      if (childCount <= 1) return;
      var targetActive = getActive(pace);
      var targetOffset = getOffset(targetActive, offset2);
      if (Array.isArray(children) && children[0] && targetOffset !== minOffset) {
        var rightBound = targetOffset < minOffset;
        childOffset[0] = rightBound ? trackSize : 0;
      }
      if (Array.isArray(children) && children[childCount - 1] && targetOffset !== 0) {
        var leftBound = targetOffset > 0;
        childOffset[childCount - 1] = leftBound ? -trackSize : 0;
      }
      setChildOffset(childOffset);
      active2 = targetActive;
      setOffset(targetOffset);
      getStyle(targetOffset);
    };
    var next = function() {
      resettPosition();
      requestFrame(function() {
        requestFrame(function() {
          swiperRef.current.moving = false;
          move({
            pace: 1
          });
        });
      });
    };
    var handleItemClick = function(event, value2) {
      onItemClick && onItemClick(event, value2);
    };
    var getStyle = function() {
      var moveOffset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : offset;
      var target = innerRef.current;
      if (!target) {
        return;
      }
      var _offset = 0;
      var val2 = rect.height - height2;
      _offset = moveOffset + Number(active2 === childCount - 1 && val2 / 2);
      target.style.transitionDuration = "".concat(swiperRef.current.moving ? 0 : duration, "ms");
      target.style.height = "".concat(Number(height2) * childCount, "px");
      target.style.transform = "translate3D(0,".concat(_offset, "px,0)");
    };
    var itemStyle = function(index2) {
      var style2 = {};
      if (height2) {
        style2.height = "".concat(height2, "px");
        style2.lineHeight = "".concat(height2, "px");
      }
      var offset2 = childOffset[index2];
      if (offset2) {
        style2.transform = "translate3D(0,".concat(offset2, "px,0)");
      }
      return style2;
    };
    var getActive = function(pace) {
      if (pace) {
        var _active = active2 + pace;
        return range2(_active, -1, childCount);
      }
      return active2;
    };
    var getOffset = function(active3) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var currentPosition = active3 * Number(height2);
      var targetOffset = offset2 - currentPosition;
      return targetOffset;
    };
    var requestFrame = function(fn) {
      window.requestAnimationFrame.call(window, fn);
    };
    var range2 = function(num, min, max) {
      return Math.min(Math.max(num, min), max);
    };
    var resettPosition = function() {
      swiperRef.current.moving = true;
      if (active2 <= -1) {
        move({
          pace: childCount
        });
      }
      if (active2 >= childCount) {
        move({
          pace: -childCount
        });
      }
    };
    var _obj;
    var noticebarClass = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-box"), true), _define_property(_obj, "".concat(classPrefix2, "-box-wrapable"), wrap), _define_property(_obj, "".concat(classPrefix2, "-box-").concat(align), true), _obj));
    var cls = classNames(classPrefix2, className);
    React.useEffect(function() {
      return function() {
        stopAutoPlay();
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, showNoticeBar && direction === "horizontal" ? /* @__PURE__ */ React.createElement("div", {
      className: noticebarClass,
      style: barStyle,
      onClick: handleClick
    }, leftIcon ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-left-icon"
    }, leftIcon) : null, /* @__PURE__ */ React.createElement("div", {
      ref: wrapRef,
      className: "nut-noticebar-box-wrap"
    }, /* @__PURE__ */ React.createElement("div", {
      ref: contentRef,
      className: "nut-noticebar-box-wrap-content ".concat(animationClass, " ").concat(isEllipsis() ? "nut-ellipsis" : ""),
      style: contentStyle,
      onAnimationEnd
    }, children, content2)), right ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-right"
    }, right) : null, closeable || rightIcon ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-right-icon",
      onClick: onClickIcon
    }, rightIcon || /* @__PURE__ */ React.createElement(n$6, {
      width: 12,
      height: 12
    })) : null) : null, showNoticeBar && scrollList.current.length > 0 && isVertical ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-vertical",
      style: barStyle,
      ref: container,
      onClick: handleClick
    }, leftIcon ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-left-icon"
    }, leftIcon) : null, children ? /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-wrap",
      ref: innerRef
    }, scrollList.current.map(function(item, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        style: itemStyle(index2),
        key: index2,
        onClick: function(e2) {
          handleItemClick(e2, item);
        }
      }, item);
    })) : /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-horseLamp-list",
      style: horseLampStyle
    }, scrollList.current.map(function(item, index2) {
      return (
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
        /* @__PURE__ */ React.createElement("div", {
          className: "nut-noticebar-box-horseLamp-list-item",
          style: {
            height: height2
          },
          key: index2,
          onClick: function(e2) {
            handleItemClick(e2, item);
          }
        }, item)
      );
    })), /* @__PURE__ */ React.createElement("div", {
      className: "nut-noticebar-box-right-icon",
      onClick: function(e2) {
        handleClickIcon(e2);
      }
    }, rightIcon || (closeable ? /* @__PURE__ */ React.createElement(n$6, {
      width: 12,
      height: 12
    }) : null))) : null);
  };
  NoticeBar.displayName = "NutNoticeBar";
  var classPrefix$c = "nut-notify";
  var Notification$1 = /* @__PURE__ */ function(_superClass) {
    _inherits(Notification2, _superClass);
    function Notification2(props) {
      _class_call_check(this, Notification2);
      var _this;
      _this = _call_super(this, Notification2, [
        props
      ]), _define_property(_this, "closeTimer", void 0);
      _this.close = _this.close.bind(_this);
      _this.startCloseTimer = _this.startCloseTimer.bind(_this);
      _this.clearCloseTimer = _this.clearCloseTimer.bind(_this);
      _this.clickCover = _this.clickCover.bind(_this);
      _this.state = {
        show: true
      };
      return _this;
    }
    _create_class(Notification2, [
      {
        key: "close",
        value: function close() {
          var _this_props;
          this.setState({
            show: false
          });
          this.clearCloseTimer();
          if (this.props.id) {
            var element = document.getElementById(this.props.id);
            element && element.parentNode && element.parentNode.removeChild(element);
          }
          (_this_props = this.props) === null || _this_props === void 0 ? void 0 : _this_props.onClose();
        }
      },
      {
        key: "startCloseTimer",
        value: function startCloseTimer() {
          var _this = this;
          var duration = this.props.duration;
          if (duration) {
            this.closeTimer = window.setTimeout(function() {
              _this.close();
            }, duration);
          }
        }
      },
      {
        key: "clearCloseTimer",
        value: function clearCloseTimer() {
          if (this.closeTimer) {
            clearTimeout(this.closeTimer);
            this.closeTimer = -1;
          }
        }
      },
      {
        key: "clickCover",
        value: function clickCover() {
          this.props.onClick();
        }
      },
      {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.startCloseTimer();
        }
      },
      {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.clearCloseTimer();
        }
      },
      {
        key: "render",
        value: function render2() {
          var _this_props = this.props, id = _this_props.id, style = _this_props.style, message = _this_props.message, leftIcon = _this_props.leftIcon, rightIcon = _this_props.rightIcon, closeable = _this_props.closeable, className = _this_props.className, position2 = _this_props.position, distance = _this_props.distance, navHeight = _this_props.navHeight;
          var show2 = this.state.show;
          var classes = classNames(classPrefix$c, className);
          var getDistance = function() {
            if (position2 === "top") {
              return {
                top: "".concat(distance + navHeight, "px")
              };
            }
            return {
              bottom: "".concat(distance, "px")
            };
          };
          var _obj;
          return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(CSSTransition, {
            in: show2,
            timeout: 300,
            classNames: "fade",
            unmountOnExit: true,
            appear: true,
            position: position2,
            id
          }, /* @__PURE__ */ React__namespace.createElement("div", {
            className: classes,
            style: _object_spread({}, style, getDistance()),
            onClick: this.clickCover
          }, leftIcon ? /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(classPrefix$c, "-left-icon")
          }, leftIcon) : null, /* @__PURE__ */ React__namespace.createElement("div", {
            className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix$c, "-content"), true), _define_property(_obj, "".concat(classPrefix$c, "-ellipsis"), closeable || rightIcon), _define_property(_obj, "".concat(classPrefix$c, "-layout-left"), leftIcon || rightIcon), _obj))
          }, message), rightIcon || closeable ? /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(classPrefix$c, "-right-icon"),
            onClick: this.close
          }, rightIcon || (closeable ? /* @__PURE__ */ React__namespace.createElement(n$6, null) : null)) : null)));
        }
      }
    ]);
    return Notification2;
  }(React__namespace.PureComponent);
  _define_property(Notification$1, "newInstance", void 0);
  Notification$1.newInstance = function(properties, callback) {
    var ref = function ref2(instance) {
      if (called) {
        return;
      }
      called = true;
      callback({
        component: instance,
        destroy: function destroy() {
          setTimeout(function() {
            unmount(element);
            element && element.parentNode && element.parentNode.removeChild(element);
          }, 300);
        }
      });
    };
    var element = document.createElement("div");
    var id = properties.id ? properties.id : "".concat(Date.now());
    element.id = id;
    properties.id = id;
    document.body.appendChild(element);
    var called = false;
    render(/* @__PURE__ */ React__namespace.createElement(Notification$1, _object_spread_props(_object_spread({}, properties), {
      ref
    })), element);
  };
  var messageInstance$1 = null;
  var options = _object_spread_props(_object_spread({}, ComponentDefaults), {
    id: "",
    position: "top",
    distance: 8,
    navHeight: 57,
    closeable: false,
    leftIcon: null,
    rightIcon: null,
    duration: 3e3,
    onClose: function() {
    },
    onClick: function() {
    }
  });
  function getInstance$1(props, callback) {
    if (messageInstance$1) {
      messageInstance$1.destroy();
      messageInstance$1 = null;
    }
    Notification$1.newInstance(props, function(notification) {
      return callback(notification);
    });
  }
  function notice$1(opts2) {
    opts2 = _object_spread({}, options, opts2);
    getInstance$1(opts2, function(notification) {
      messageInstance$1 = notification;
    });
  }
  var errorMsg$1 = function(message) {
    if (!message) {
      console.warn("[NutUI Notify]: message");
    }
  };
  const Notify = {
    text: function text2(message) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      errorMsg$1(message);
      return notice$1(_object_spread({
        message,
        type: "base"
      }, option));
    },
    hide: function hide() {
      if (messageInstance$1) {
        messageInstance$1.destroy();
        messageInstance$1 = null;
      }
    }
  };
  var defaultProps$B = _object_spread_props(_object_spread({}, ComponentDefaults), {
    list: [],
    theme: "light",
    location: "bottom",
    visible: false,
    offset: [
      0,
      8
    ],
    arrowOffset: 0,
    targetId: "",
    showArrow: true,
    closeOnOutsideClick: true,
    closeOnActionClick: true,
    overlay: false,
    onClick: function() {
    },
    onOpen: function() {
    },
    onClose: function() {
    }
  });
  var classPrefix$b = "nut-popover";
  var Popover = function(props) {
    var rtl = useRtl();
    var _ref = _object_spread({}, defaultProps$B, props), children = _ref.children, list = _ref.list, theme = _ref.theme, location = _ref.location, visible = _ref.visible, offset = _ref.offset, arrowOffset = _ref.arrowOffset, targetId = _ref.targetId, overlay = _ref.overlay, closeOnOutsideClick = _ref.closeOnOutsideClick, closeOnActionClick = _ref.closeOnActionClick, className = _ref.className, showArrow = _ref.showArrow, style = _ref.style, onClick = _ref.onClick, onOpen = _ref.onOpen, onClose = _ref.onClose, onSelect = _ref.onSelect, rest = _object_without_properties(_ref, [
      "children",
      "list",
      "theme",
      "location",
      "visible",
      "offset",
      "arrowOffset",
      "targetId",
      "overlay",
      "closeOnOutsideClick",
      "closeOnActionClick",
      "className",
      "showArrow",
      "style",
      "onClick",
      "onOpen",
      "onClose",
      "onSelect"
    ]);
    var popoverRef = React.useRef(null);
    var popoverContentRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(false), 2), showPopup = _useState[0], setShowPopup = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(), 2), wrapperPosition = _useState1[0], setWrapperPosition = _useState1[1];
    React.useEffect(function() {
      setShowPopup(visible);
      if (visible) {
        setTimeout(function() {
          getWrapperPosition();
        }, 0);
      }
    }, [
      visible,
      location
    ]);
    var update2 = React.useRef(function(e2) {
      getWrapperPosition();
    });
    var targetSet = [];
    var element = null;
    if (canUseDom && targetId) {
      element = document.querySelector("#".concat(targetId));
      targetSet = [
        element,
        popoverContentRef.current
      ];
    } else {
      targetSet = [
        popoverRef.current,
        popoverContentRef.current
      ];
    }
    var scrollableParents = React.useMemo(function() {
      return getAllScrollableParents(element || popoverRef.current);
    }, [
      element,
      popoverRef.current
    ]);
    React.useEffect(function() {
      if (visible) {
        scrollableParents.forEach(function(parent2) {
          parent2.addEventListener("scroll", update2.current, {
            passive: true
          });
        });
      } else {
        scrollableParents.forEach(function(parent2) {
          return parent2.removeEventListener("scroll", update2.current);
        });
      }
    }, [
      visible
    ]);
    useClickAway(function() {
      onClick === null || onClick === void 0 ? void 0 : onClick();
      onClose === null || onClose === void 0 ? void 0 : onClose();
    }, targetSet, "touchstart", true, visible, closeOnOutsideClick);
    var getWrapperPosition = function() {
      var rect = getRect(targetId ? document.querySelector("#".concat(targetId)) : popoverRef.current);
      var distance = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
      var width2 = rect.width, height2 = rect.height, right = rect.right, left = rect.left, top = rect.top;
      setWrapperPosition({
        width: width2,
        height: height2,
        left: rtl ? right : left,
        top: top + distance,
        right: rtl ? left : right
      });
    };
    var classes = classNames(classPrefix$b, _define_property({}, "".concat(classPrefix$b, "-").concat(theme), theme === "dark"), className);
    var popoverArrow = function() {
      var prefixCls2 = "nut-popover-arrow";
      var direction = location.split("-")[0];
      return "".concat(prefixCls2, " ").concat(prefixCls2, "-").concat(direction, " ").concat(prefixCls2, "-").concat(location);
    };
    var getPopoverPosition = function() {
      var _popoverContentRef_current, _popoverContentRef_current1;
      var styles = {};
      if (!wrapperPosition) {
        styles.visibility = "hidden";
        return styles;
      }
      var popWidth = (_popoverContentRef_current = popoverContentRef.current) === null || _popoverContentRef_current === void 0 ? void 0 : _popoverContentRef_current.clientWidth;
      var popHeight = (_popoverContentRef_current1 = popoverContentRef.current) === null || _popoverContentRef_current1 === void 0 ? void 0 : _popoverContentRef_current1.clientHeight;
      var width2 = wrapperPosition.width, height2 = wrapperPosition.height, left = wrapperPosition.left, top = wrapperPosition.top, right = wrapperPosition.right;
      var direction = location.split("-")[0];
      var skew = location.split("-")[1];
      var cross = 0;
      var parallel = 0;
      if (Array.isArray(offset) && offset.length === 2) {
        var rtloffset = rtl ? -offset[0] : offset[0];
        cross += +offset[1];
        parallel += +rtloffset;
      }
      if (width2) {
        var dir = rtl ? "right" : "left";
        if ([
          "bottom",
          "top"
        ].includes(direction)) {
          var h = direction === "bottom" ? height2 + cross : -(popHeight + cross);
          styles.top = "".concat(top + h, "px");
          if (!skew) {
            styles[dir] = "".concat(-(popWidth - width2) / 2 + wrapperPosition[dir] + parallel, "px");
          }
          if (skew === "left") {
            styles.left = "".concat(left + parallel, "px");
          }
          if (skew === "right") {
            styles.left = "".concat(right + parallel, "px");
          }
        }
        if ([
          "left",
          "right"
        ].includes(direction)) {
          var contentW = direction === "left" ? -(popWidth + cross) : width2 + cross;
          styles.left = "".concat(left + contentW, "px");
          if (!skew) {
            styles.top = "".concat(top - popHeight / 2 + height2 / 2 - 4 + parallel, "px");
          }
          if (skew === "top") {
            styles.top = "".concat(top + parallel, "px");
          }
          if (skew === "bottom") {
            styles.top = "".concat(top + height2 + parallel, "px");
          }
        }
      }
      styles.visibility = popWidth === 0 ? "hidden" : "initial";
      return styles;
    };
    var popoverArrowStyle = function() {
      var styles = {};
      var direction = location.split("-")[0];
      var skew = location.split("-")[1];
      var base = 16;
      if (arrowOffset !== 0) {
        var dir = rtl ? "right" : "left";
        var dir2 = rtl ? "left" : "right";
        if ([
          "bottom",
          "top"
        ].includes(direction)) {
          if (!skew) {
            styles[dir] = "calc(50% + ".concat(arrowOffset, "px)");
          }
          if (skew === "left") {
            styles[dir] = "".concat(base + arrowOffset, "px");
          }
          if (skew === "right") {
            styles[dir2] = "".concat(base - arrowOffset, "px");
          }
        }
        if ([
          "left",
          "right"
        ].includes(direction)) {
          if (!skew) {
            styles.top = "calc(50% - ".concat(arrowOffset, "px)");
          }
          if (skew === "top") {
            styles.top = "".concat(base - arrowOffset, "px");
          }
          if (skew === "bottom") {
            styles.bottom = "".concat(base + arrowOffset, "px");
          }
        }
      }
      return styles;
    };
    var handleSelect = function(item, index2) {
      if (!item.disabled) {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(item, index2);
      }
      if (closeOnActionClick) {
        onClick === null || onClick === void 0 ? void 0 : onClick();
        onClose === null || onClose === void 0 ? void 0 : onClose();
      }
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, !targetId && /* @__PURE__ */ React.createElement("div", {
      className: "nut-popover-wrapper",
      ref: popoverRef,
      onClick: function() {
        onClick === null || onClick === void 0 ? void 0 : onClick();
        if (!visible) {
          onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        } else {
          onClose === null || onClose === void 0 ? void 0 : onClose();
        }
      },
      style
    }, Array.isArray(children) ? children[0] : children), /* @__PURE__ */ ReactDOM.createPortal(/* @__PURE__ */ React.createElement("div", {
      className: classes,
      style: _object_spread({}, getPopoverPosition(), style)
    }, /* @__PURE__ */ React.createElement(Popup, _object_spread({
      className: "nut-popover-content nut-popover-content-".concat(location),
      visible: showPopup,
      overlay,
      position: "none",
      lockScroll: false
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "nut-popover-content-group",
      ref: popoverContentRef
    }, showArrow && /* @__PURE__ */ React.createElement("div", {
      className: popoverArrow(),
      style: popoverArrowStyle()
    }, /* @__PURE__ */ React.createElement(i$1, {
      width: 8,
      height: 4
    })), Array.isArray(children) ? children[1] : null, list.map(function(item, index2) {
      var _item_action;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames({
          "nut-popover-item": true,
          "nut-popover-item-disabled": item.disabled
        }, item.className),
        key: item.key || index2,
        onClick: function() {
          return handleSelect(item, index2);
        }
      }, item.icon && /* @__PURE__ */ React.createElement("div", {
        className: "nut-popover-item-icon"
      }, item.icon), /* @__PURE__ */ React.createElement("div", {
        className: "nut-popover-item-name"
      }, item.name), ((_item_action = item.action) === null || _item_action === void 0 ? void 0 : _item_action.icon) && /* @__PURE__ */ React.createElement("div", {
        className: "nut-popover-item-action-icon",
        onClick: function(e2) {
          var _item_action_onClick, _item_action2;
          return (_item_action2 = item.action) === null || _item_action2 === void 0 ? void 0 : (_item_action_onClick = _item_action2.onClick) === null || _item_action_onClick === void 0 ? void 0 : _item_action_onClick.call(_item_action2, e2);
        }
      }, item.action.icon));
    })))), document.body));
  };
  Popover.displayName = "NutPopover";
  var defaultProps$A = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "default",
    pullingText: "",
    canReleaseText: "",
    refreshingText: "",
    completeText: "",
    completeDelay: 500,
    disabled: false,
    headHeight: 80,
    threshold: 60,
    onRefresh: function() {
    }
  });
  var PullToRefresh = function(p2) {
    var doRefresh = function doRefresh2() {
      return _doRefresh.apply(this, arguments);
    };
    var classPrefix2 = "nut-pulltorefresh";
    var locale = useConfig().locale;
    var props = _object_spread({}, defaultProps$A, p2, {
      pullingText: p2.pullingText || locale.pullToRefresh.pullingText,
      canReleaseText: p2.canReleaseText || locale.pullToRefresh.canReleaseText,
      refreshingText: p2.refreshingText || locale.pullToRefresh.refreshingText,
      completeText: p2.completeText || locale.pullToRefresh.completeText
    });
    var classes = classNames(classPrefix2, props.className, "".concat(classPrefix2, "-").concat(props.type));
    var headHeight = props.headHeight;
    var threshold = props.threshold;
    var _useState = _sliced_to_array(React.useState("pulling"), 2), status = _useState[0], setStatus = _useState[1];
    var _useSpring = _sliced_to_array(useSpring(function() {
      return {
        from: {
          height: 0
        },
        config: {
          tension: 300,
          friction: 30,
          clamp: true
        }
      };
    }), 2), springStyles = _useSpring[0], api = _useSpring[1];
    var elementRef = React.useRef(null);
    var pullingRef = React.useRef(false);
    React.useEffect(function() {
      var _elementRef_current;
      (_elementRef_current = elementRef.current) === null || _elementRef_current === void 0 ? void 0 : _elementRef_current.addEventListener("touchmove", function() {
      });
    }, []);
    function _doRefresh() {
      _doRefresh = _async_to_generator(function() {
        var e2;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              api.start({
                height: headHeight
              });
              setStatus("refreshing");
              _state.label = 1;
            case 1:
              _state.trys.push([
                1,
                3,
                ,
                4
              ]);
              return [
                4,
                props.onRefresh()
              ];
            case 2:
              _state.sent();
              setStatus("complete");
              return [
                3,
                4
              ];
            case 3:
              e2 = _state.sent();
              api.start({
                to: /* @__PURE__ */ function() {
                  var _ref = _async_to_generator(function(next) {
                    return __generator(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          return [
                            4,
                            next({
                              height: 0
                            })
                          ];
                        case 1:
                          _state2.sent();
                          setStatus("pulling");
                          return [
                            2
                          ];
                      }
                    });
                  });
                  return function(next) {
                    return _ref.apply(this, arguments);
                  };
                }()
              });
              throw e2;
            case 4:
              if (!(props.completeDelay > 0)) return [
                3,
                6
              ];
              return [
                4,
                sleep(props.completeDelay)
              ];
            case 5:
              _state.sent();
              _state.label = 6;
            case 6:
              api.start({
                to: /* @__PURE__ */ function() {
                  var _ref = _async_to_generator(function(next) {
                    return __generator(this, function(_state2) {
                      switch (_state2.label) {
                        case 0:
                          return [
                            4,
                            next({
                              height: 0
                            })
                          ];
                        case 1:
                          _state2.sent();
                          setStatus("pulling");
                          return [
                            2
                          ];
                      }
                    });
                  });
                  return function(next) {
                    return _ref.apply(this, arguments);
                  };
                }()
              });
              return [
                2
              ];
          }
        });
      });
      return _doRefresh.apply(this, arguments);
    }
    useDrag(function(state) {
      var getScrollTop = function getScrollTop2(element) {
        return "scrollTop" in element ? element.scrollTop : element.scrollY;
      };
      if (status === "refreshing" || status === "complete") return;
      var event = state.event;
      if (state.last) {
        pullingRef.current = false;
        if (status === "canRelease") {
          doRefresh();
        } else {
          api.start({
            height: 0
          });
        }
        return;
      }
      var _state_movement = _sliced_to_array(state.movement, 2), y = _state_movement[1];
      if (state.first && y > 0) {
        var target = state.event.target;
        if (!target || !_instanceof(target, Element)) return;
        var scrollParent = getScrollParent(target);
        while (true) {
          if (!scrollParent) return;
          var scrollTop = getScrollTop(scrollParent);
          if (scrollTop > 0) {
            return;
          }
          if (_instanceof(scrollParent, Window)) {
            break;
          }
          scrollParent = getScrollParent(scrollParent.parentNode);
        }
        pullingRef.current = true;
      }
      if (!pullingRef.current) return;
      if (event.cancelable) {
        event.preventDefault();
      }
      event.stopPropagation();
      var height2 = Math.max(rubberbandIfOutOfBounds$1(y, 0, 0, headHeight * 5, 0.5), 0);
      api.start({
        height: height2
      });
      setStatus(height2 > threshold ? "canRelease" : "pulling");
    }, {
      pointer: {
        touch: true
      },
      axis: "y",
      target: elementRef,
      enabled: !props.disabled,
      eventOptions: exports.passiveSupported ? {
        passive: false
      } : false
    });
    var renderIcons = function(status2) {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("i", {
        className: "".concat(classPrefix2, "-head-content-icons")
      }, (status2 === "pulling" || status2 === "complete") && /* @__PURE__ */ React.createElement(s, null), (status2 === "canRelease" || status2 === "refreshing") && /* @__PURE__ */ React.createElement(l, null)));
    };
    var renderStatusIcon = function() {
      if (props.renderIcon) {
        var _props_renderIcon;
        return (_props_renderIcon = props.renderIcon) === null || _props_renderIcon === void 0 ? void 0 : _props_renderIcon.call(props, status);
      }
      return renderIcons(status);
    };
    var renderStatusText = function() {
      if (props.renderText) {
        var _props_renderText;
        return (_props_renderText = props.renderText) === null || _props_renderText === void 0 ? void 0 : _props_renderText.call(props, status);
      }
      if (status === "pulling") return props.pullingText;
      if (status === "canRelease") return props.canReleaseText;
      if (status === "refreshing") return props.refreshingText;
      if (status === "complete") return props.completeText;
      return "";
    };
    var _obj, _obj1, _obj2, _obj3, _obj4;
    return /* @__PURE__ */ React.createElement(animated.div, {
      ref: elementRef,
      className: classes,
      style: props.style
    }, /* @__PURE__ */ React.createElement(animated.div, {
      style: springStyles,
      className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-head"), true), _define_property(_obj, "".concat(classPrefix2, "-primary-head"), props.type === "primary"), _obj))
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-head-content"), true), _define_property(_obj1, "".concat(classPrefix2, "-primary-head-content"), props.type === "primary"), _obj1)),
      style: {
        height: headHeight
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-status-icon"), true), _define_property(_obj2, "".concat(classPrefix2, "-primary-status-icon"), props.type === "primary"), _obj2))
    }, renderStatusIcon()), /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj3 = {}, _define_property(_obj3, "".concat(classPrefix2, "-status-text"), true), _define_property(_obj3, "".concat(classPrefix2, "-primary-status-text"), props.type === "primary"), _obj3))
    }, renderStatusText()))), /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj4 = {}, _define_property(_obj4, "".concat(classPrefix2, "-content"), true), _define_property(_obj4, "".concat(classPrefix2, "-primary-content}"), props.type === "primary"), _obj4))
    }, props.children));
  };
  PullToRefresh.displayName = "NutPullToRefresh";
  var defaultProps$z = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: null,
    description: null,
    icon: "",
    status: "info",
    actions: []
  });
  var ResultPage = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$z, props), className = _$_object_spread.className, style = _$_object_spread.style, title = _$_object_spread.title, description = _$_object_spread.description, icon = _$_object_spread.icon, status = _$_object_spread.status, actions = _$_object_spread.actions, children = _$_object_spread.children;
    var classPrefix2 = "nut-resultpage";
    var cls = classNames(classPrefix2, className);
    var defaultStatus2 = {
      success: /* @__PURE__ */ React.createElement(m$1, {
        color: "#00D900"
      }),
      error: /* @__PURE__ */ React.createElement(n$4, {
        color: "#FF0F23"
      }),
      warning: /* @__PURE__ */ React.createElement(c, {
        color: "#FFBF00"
      }),
      info: /* @__PURE__ */ React.createElement(p$2, {
        color: "#0073FF"
      }),
      waiting: /* @__PURE__ */ React.createElement(n$a, {
        color: "#0073FF"
      })
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-icon")
    }, icon || defaultStatus2[status]), typeof title === "string" && title ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-title")
    }, title) : title, typeof description === "string" && description ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-description")
    }, description) : description, actions.length ? /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-actions")
    }, actions.map(function(action, index2) {
      action.text;
      var rest = _object_without_properties(action, [
        "text"
      ]);
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-action"),
        key: index2
      }, /* @__PURE__ */ React.createElement(Button, _object_spread_props(_object_spread({}, rest), {
        size: "large"
      }), action === null || action === void 0 ? void 0 : action.text));
    })) : null, children);
  };
  ResultPage.displayName = "NutResultPage";
  var defaultProps$y = _object_spread_props(_object_spread({}, ComponentDefaults), {
    rows: 1,
    animated: true,
    visible: false,
    size: "normal",
    shape: "round",
    duration: 0.6
  });
  var Skeleton = function(props) {
    var shapeStyle = function shapeStyle2() {
      if (shape === "circle") return {
        borderRadius: "50%"
      };
      if (shape === "square") return {
        borderRadius: "0"
      };
      return {};
    };
    var durationStyle = function durationStyle2() {
      if (typeof duration !== "undefined") return {
        animationDuration: "".concat(duration, "s")
      };
      return {};
    };
    var _ref = _object_spread({}, defaultProps$y, props), className = _ref.className, width2 = _ref.width, height2 = _ref.height, shape = _ref.shape, animated2 = _ref.animated, rows = _ref.rows, visible = _ref.visible, size = _ref.size, duration = _ref.duration, children = _ref.children, rest = _object_without_properties(_ref, [
      "className",
      "width",
      "height",
      "shape",
      "animated",
      "rows",
      "visible",
      "size",
      "duration",
      "children"
    ]);
    var classPrefix2 = "nut-skeleton";
    var classes = classNames(classPrefix2, className);
    var repeatCount = function(num) {
      return Array.from({
        length: num
      }, function(v, i2) {
        return i2;
      });
    };
    var _useState = _sliced_to_array(React.useState(false), 2), animate = _useState[0], setAnimate = _useState[1];
    var playAnimation = function() {
      setAnimate(false);
      setTimeout(function() {
        setAnimate(true);
      }, 10);
    };
    React.useEffect(function() {
      if (!animated2) return;
      playAnimation();
      var intervalId = setInterval(playAnimation, 1e3 + duration * 1e3);
      return function() {
        return clearInterval(intervalId);
      };
    }, []);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, visible ? children : /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, rest), repeatCount(rows).map(function(item, index2) {
      var contentClass = "".concat(classPrefix2, "-content ").concat(classPrefix2, "-content-").concat(size, " ").concat(classPrefix2, "-content-").concat(size, "-").concat(index2);
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(contentClass),
        key: index2,
        style: _object_spread({
          width: width2,
          height: height2
        }, shapeStyle())
      }, animated2 && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-animated ").concat(animate ? "".concat(classPrefix2, "-animation") : ""),
        style: durationStyle()
      }));
    })));
  };
  Skeleton.displayName = "NutSkeleton";
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    {
      event.stopPropagation();
    }
  }
  var defaultProps$x = {
    name: ""
  };
  var Swipe = /* @__PURE__ */ React.forwardRef(function(props, instanceRef) {
    var classPrefix2 = "nut-swipe";
    var touch = useTouch();
    var _$_object_spread = _object_spread({}, defaultProps$x, props), children = _$_object_spread.children, className = _$_object_spread.className, style = _$_object_spread.style;
    var root2 = React.useRef();
    var opened = React.useRef(false);
    var lockClick = React.useRef(false);
    var startOffset = React.useRef(0);
    var _useState = _sliced_to_array(React.useState({
      offset: 0,
      dragging: false
    }), 2), state = _useState[0], setState = _useState[1];
    var _useState1 = _sliced_to_array(React.useState({
      left: 0,
      right: 0
    }), 2), actionWidth = _useState1[0], setActionWidth = _useState1[1];
    var wrapperStyle = {
      transform: "translate3d(".concat(state.offset, "px, 0, 0)"),
      transitionDuration: state.dragging ? "0s" : ".6s"
    };
    var leftWidth = actionWidth.left;
    var rightWidth = actionWidth.right;
    var onTouchStart = function(event) {
      if (!props.disabled) {
        var _props_onTouchStart;
        startOffset.current = state.offset;
        touch.start(event);
        (_props_onTouchStart = props.onTouchStart) === null || _props_onTouchStart === void 0 ? void 0 : _props_onTouchStart.call(props, event);
      }
    };
    var onTouchMove = function(event) {
      var _props_onTouchMove;
      if (props.disabled) {
        return;
      }
      touch.move(event);
      (_props_onTouchMove = props.onTouchMove) === null || _props_onTouchMove === void 0 ? void 0 : _props_onTouchMove.call(props, event);
      if (touch.isHorizontal()) {
        lockClick.current = true;
        var newState = _object_spread_props(_object_spread({}, state), {
          dragging: true
        });
        var isEdge = !opened || touch.deltaX.current * startOffset.current < 0;
        if (isEdge) {
          preventDefault(event);
        }
        newState.offset = rangeCalculation(touch.deltaX.current + startOffset.current, -rightWidth, leftWidth);
        setState(newState);
      }
    };
    var onTouchEnd = function(event) {
      if (state.dragging) {
        var _props_onTouchEnd;
        setState(function(v) {
          return _object_spread_props(_object_spread({}, v), {
            dragging: false
          });
        });
        toggle(state.offset > 0 ? "left" : "right");
        setTimeout(function() {
          lockClick.current = false;
        }, 0);
        (_props_onTouchEnd = props.onTouchEnd) === null || _props_onTouchEnd === void 0 ? void 0 : _props_onTouchEnd.call(props, event);
      }
    };
    var toggle = function(side) {
      var offset = Math.abs(state.offset);
      var base = 0.3;
      var baseNum = opened ? 1 - base : base;
      var width2 = side === "left" ? leftWidth : rightWidth;
      if (width2 && offset > Number(width2) * baseNum) {
        open(side);
      } else {
        close(side);
      }
    };
    var open = function(side) {
      var _props_onOpen;
      opened.current = true;
      var offset = side === "left" ? leftWidth : -rightWidth;
      var name2 = props.name;
      (_props_onOpen = props.onOpen) === null || _props_onOpen === void 0 ? void 0 : _props_onOpen.call(props, {
        name: name2,
        position: side
      });
      setState(function(v) {
        return _object_spread_props(_object_spread({}, v), {
          offset: Number(offset) || 0
        });
      });
    };
    var close = function(position2) {
      if (opened.current) {
        var _props_onClose;
        opened.current = false;
        (_props_onClose = props.onClose) === null || _props_onClose === void 0 ? void 0 : _props_onClose.call(props, {
          name: props.name,
          position: position2 || "left"
        });
      }
      setState(function(v) {
        return _object_spread_props(_object_spread({}, v), {
          offset: 0
        });
      });
    };
    var rangeCalculation = function(num, min, max) {
      return Math.min(Math.max(Number(num), Number(min)), Number(max));
    };
    var getNodeWidth = function(node) {
      if (node) {
        var ele = getRect(node);
        return ele.width;
      }
      return 0;
    };
    var leftRef = React.useCallback(function(node) {
      if (node !== null) {
        setActionWidth(function(v) {
          return _object_spread_props(_object_spread({}, v), {
            left: getNodeWidth(node)
          });
        });
      }
    }, [
      props.leftAction
    ]);
    var rightRef = React.useCallback(function(node) {
      if (node !== null) {
        setActionWidth(function(v) {
          return _object_spread_props(_object_spread({}, v), {
            right: getNodeWidth(node)
          });
        });
      }
    }, [
      props.rightAction
    ]);
    var renderActionContent = function(side, measuredRef) {
      if (props["".concat(side, "Action")]) {
        return /* @__PURE__ */ React.createElement("div", {
          ref: measuredRef,
          className: "".concat(classPrefix2, "-").concat(side),
          onClick: function(e2) {
            return handleOperate(e2, side);
          }
        }, props["".concat(side, "Action")]);
      }
      return null;
    };
    var handleOperate = function(event, position2) {
      event.stopPropagation();
      if (props.beforeClose) {
        props.beforeClose(position2);
      } else {
        props.onActionClick && props.onActionClick(event, position2);
      }
    };
    React.useImperativeHandle(instanceRef, function() {
      return {
        open,
        close: function() {
          return close();
        }
      };
    });
    React.useEffect(function() {
      var handler = function(event) {
        var targets = [
          root2
        ];
        if (targets.some(function(targetItem) {
          var targetElement = targetItem.current || targetItem;
          return !targetElement || (targetElement === null || targetElement === void 0 ? void 0 : targetElement.contains(event.target));
        })) {
          return;
        }
        close();
      };
      document.addEventListener("touchstart", handler);
      return function() {
        document.removeEventListener("touchstart", handler);
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      ref: root2,
      className: classNames(classPrefix2, className),
      onTouchStart: function(e2) {
        return onTouchStart(e2);
      },
      onTouchMove: function(e2) {
        return onTouchMove(e2);
      },
      onTouchEnd: function(e2) {
        return onTouchEnd(e2);
      },
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-wrapper"),
      style: wrapperStyle
    }, renderActionContent("left", leftRef), children, renderActionContent("right", rightRef)));
  });
  Swipe.displayName = "NutSwipe";
  var classPrefix$a = "nut-toast";
  var Notification = /* @__PURE__ */ function(_superClass) {
    _inherits(Notification2, _superClass);
    function Notification2(props) {
      _class_call_check(this, Notification2);
      var _this;
      _this = _call_super(this, Notification2, [
        props
      ]), _define_property(_this, "closeTimer", void 0);
      _this.close = _this.close.bind(_this);
      _this.startCloseTimer = _this.startCloseTimer.bind(_this);
      _this.clearCloseTimer = _this.clearCloseTimer.bind(_this);
      _this.clickCover = _this.clickCover.bind(_this);
      _this.state = {
        show: true
      };
      return _this;
    }
    _create_class(Notification2, [
      {
        key: "close",
        value: function close() {
          this.setState({
            show: false
          });
          this.clearCloseTimer();
          if (this.props.id) {
            var element = document.getElementById(this.props.id);
            element && element.parentNode && element.parentNode.removeChild(element);
          }
          this.props.onClose && this.props.onClose();
        }
      },
      {
        key: "startCloseTimer",
        value: function startCloseTimer() {
          var _this = this;
          var duration = this.props.duration;
          if (duration) {
            this.closeTimer = window.setTimeout(function() {
              _this.close();
            }, duration * 1e3);
          }
        }
      },
      {
        key: "clearCloseTimer",
        value: function clearCloseTimer() {
          if (this.closeTimer) {
            clearTimeout(this.closeTimer);
            this.closeTimer = -1;
          }
        }
      },
      {
        key: "clickCover",
        value: function clickCover() {
          var closeOnOverlayClick = this.props.closeOnOverlayClick;
          if (closeOnOverlayClick) {
            this.close();
          }
        }
      },
      {
        key: "renderIcon",
        value: function renderIcon() {
          var icon = this.props.icon;
          if (typeof icon === "string") {
            var iconNode = {
              success: /* @__PURE__ */ React__namespace.createElement(m$1, null),
              fail: /* @__PURE__ */ React__namespace.createElement(n$4, null),
              warn: /* @__PURE__ */ React__namespace.createElement(p$2, null),
              loading: /* @__PURE__ */ React__namespace.createElement(s, {
                className: "nut-icon-loading"
              })
            }[icon];
            return /* @__PURE__ */ React__namespace.createElement("p", {
              className: "".concat(classPrefix$a, "-icon-wrapper")
            }, iconNode);
          }
          return icon;
        }
      },
      {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.startCloseTimer();
        }
      },
      {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.clearCloseTimer();
        }
      },
      {
        key: "render",
        value: function render2() {
          var _this = this;
          var _this_props = this.props, id = _this_props.id, icon = _this_props.icon, title = _this_props.title, content2 = _this_props.content, position2 = _this_props.position, size = _this_props.size, closeOnOverlayClick = _this_props.closeOnOverlayClick, lockScroll = _this_props.lockScroll, style = _this_props.style, className = _this_props.className, contentClassName = _this_props.contentClassName, contentStyle = _this_props.contentStyle, wordBreak = _this_props.wordBreak, zIndex = _this_props.zIndex;
          var show2 = this.state.show;
          var classes = classNames({
            "nut-toast-has-icon": icon
          });
          return /* @__PURE__ */ React__namespace.createElement(Overlay, {
            visible: show2,
            style,
            zIndex,
            className: "".concat(classPrefix$a, "-overlay-default ").concat(className),
            onClick: function() {
              return _this.clickCover();
            },
            closeOnOverlayClick,
            lockScroll
          }, /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(classPrefix$a, " ").concat(classes),
            id: "toast-".concat(id)
          }, /* @__PURE__ */ React__namespace.createElement("div", {
            className: classNames("".concat(classPrefix$a, "-inner"), "".concat(classPrefix$a, "-").concat(position2), contentClassName, "".concat(classPrefix$a, "-inner-").concat(size), "".concat(classPrefix$a, "-inner-").concat(wordBreak), _define_property({}, "".concat(classPrefix$a, "-inner-descrption"), content2)),
            style: _object_spread({}, contentStyle)
          }, this.renderIcon(), title && /* @__PURE__ */ React__namespace.createElement("div", {
            className: "".concat(classPrefix$a, "-title")
          }, title), content2 && /* @__PURE__ */ React__namespace.createElement("span", {
            className: "".concat(classPrefix$a, "-text")
          }, content2))));
        }
      }
    ]);
    return Notification2;
  }(React__namespace.PureComponent);
  _define_property(Notification, "newInstance", void 0);
  Notification.newInstance = function(properties, callback) {
    var ref = function ref2(instance) {
      if (called) {
        return;
      }
      called = true;
      callback({
        component: instance,
        destroy: function destroy() {
          unmount(element);
          element && element.parentNode && element.parentNode.removeChild(element);
        }
      });
    };
    var element = document.createElement("div");
    var id = properties.id ? properties.id : "".concat(Date.now());
    element.id = id;
    properties.id = id;
    document.body.appendChild(element);
    var called = false;
    render(/* @__PURE__ */ React__namespace.createElement(Notification, _object_spread_props(_object_spread({}, properties), {
      ref
    })), element);
  };
  var messageInstance = null;
  var defaultProps$w = _object_spread_props(_object_spread({}, defaultOverlayProps), {
    id: "",
    position: "middle",
    title: "",
    size: "base",
    icon: null,
    content: "",
    contentClassName: "",
    contentStyle: {},
    wordBreak: "break-all",
    duration: 2,
    closeOnOverlayClick: false,
    lockScroll: false,
    zIndex: 1300,
    onClose: function() {
    }
  });
  function getInstance(props, callback) {
    if (messageInstance) {
      messageInstance.destroy();
      messageInstance = null;
    }
    Notification.newInstance(props, function(notification) {
      return callback(notification);
    });
  }
  function notice(opts2) {
    function close() {
      if (messageInstance) {
        messageInstance.destroy();
        messageInstance = null;
        opts2.onClose && opts2.onClose();
      }
    }
    var opts22 = _object_spread_props(_object_spread({}, defaultProps$w, opts2), {
      onClose: close
    });
    getInstance(opts22, function(notification) {
      messageInstance = notification;
    });
  }
  var errorMsg = function(msg) {
    if (!msg) {
      console.warn("[NutUI Toast]: msg cannot be null");
    }
  };
  function show(option) {
    if (typeof option === "string") {
      errorMsg(option);
      return notice({
        content: option
      });
    }
    errorMsg(option.content);
    return notice(_object_spread({}, option));
  }
  function config(config2) {
    defaultProps$w = _object_spread({}, defaultProps$w, config2);
  }
  const Toast = {
    show,
    config,
    clear: function clear() {
      if (messageInstance) {
        messageInstance.destroy();
        messageInstance = null;
      }
    }
  };
  var defaultProps$v = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "shake",
    action: "initial",
    loop: false,
    onClick: function(event) {
    }
  });
  var classPrefix$9 = "nut-animate";
  var Animate = function(props) {
    var _ref = _object_spread({}, defaultProps$v, props), className = _ref.className, type2 = _ref.type, action = _ref.action, loop2 = _ref.loop, onClick = _ref.onClick, children = _ref.children, rest = _object_without_properties(_ref, [
      "className",
      "type",
      "action",
      "loop",
      "onClick",
      "children"
    ]);
    var _useState = _sliced_to_array(React.useState(false), 2), clicked = _useState[0], setClicked = _useState[1];
    var _obj;
    var classes = classNames((_obj = {
      "nut-ani-container": true
    }, _define_property(_obj, "".concat(classPrefix$9, "-").concat(type2), action === "initial" || clicked), _define_property(_obj, "loop", loop2), _obj), className);
    var handleClick = function(event) {
      setClicked(true);
      if (!loop2) {
        setTimeout(function() {
          return setClicked(false);
        }, 1e3);
      }
      onClick(event);
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: "nut-animate"
    }, /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      onClick: handleClick
    }, rest), children));
  };
  Animate.displayName = "NutAnimate";
  var defaultProps$u = _object_spread_props(_object_spread({}, ComponentDefaults), {
    length: 0,
    value: "",
    delay: 300,
    duration: 1,
    thousands: false
  });
  var CountUp = function(props) {
    var _mergeProps = mergeProps(defaultProps$u, props), length2 = _mergeProps.length, value2 = _mergeProps.value, delay = _mergeProps.delay, duration = _mergeProps.duration, className = _mergeProps.className, thousands = _mergeProps.thousands;
    _mergeProps.style;
    _object_without_properties(_mergeProps, [
      "length",
      "value",
      "delay",
      "duration",
      "className",
      "thousands",
      "style"
    ]);
    var classPrefix2 = "nut-countup";
    var countupRef = React.useRef(null);
    var timerRef = React.useRef(0);
    var numbers = Array.from({
      length: 10
    }, function(v, i2) {
      return i2;
    });
    var getShowNumber = function() {
      var splitArr = value2.split(".");
      var intNumber = length2 && splitArr[0].length < length2 ? (Array(length2).join("0") + splitArr[0]).slice(-length2) : splitArr[0];
      var currNumber = "".concat(thousands ? intNumber.replace(/(\d)(?=(?:\d{3})+$)/g, "$1,") : intNumber).concat(splitArr[1] ? "." : "").concat(splitArr[1] || "");
      return currNumber.split("");
    };
    var numberArr = React.useMemo(getShowNumber, [
      value2,
      length2,
      thousands
    ]);
    var setNumberTransform = React.useCallback(function() {
      if (countupRef.current) {
        var numberItems = countupRef.current.querySelectorAll(".nut-countup-number");
        var numberFilterArr = numberArr.filter(function(item) {
          return !Number.isNaN(Number(item));
        });
        Object.keys(numberItems).forEach(function(key2) {
          var elem2 = numberItems[Number(key2)];
          var idx = Number(numberFilterArr[Number(key2)]);
          if ((idx || idx === 0) && elem2) {
            var transform2 = "translate(0, -".concat((idx === 0 ? 10 : idx) * 5, "%)");
            elem2.style.transform = transform2;
            elem2.style.webkitTransform = transform2;
          }
        });
      }
    }, [
      numberArr
    ]);
    var numberEaseStyle = {
      transitionDuration: "".concat(duration, "s")
    };
    React.useEffect(function() {
      timerRef.current = window.setTimeout(function() {
        setNumberTransform();
      }, delay);
      return function() {
        window.clearTimeout(timerRef.current);
      };
    }, [
      numberArr,
      delay,
      setNumberTransform
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, " ").concat(className),
      ref: countupRef
    }, /* @__PURE__ */ React.createElement("ul", {
      className: "".concat(classPrefix2, "-list")
    }, numberArr.map(function(item, idx) {
      return /* @__PURE__ */ React.createElement("li", {
        className: "".concat(classPrefix2, "-listitem ").concat(!Number.isNaN(Number(item)) ? "".concat(classPrefix2, "-listitem-number") : ""),
        key: idx
      }, !Number.isNaN(Number(item)) ? /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-number"),
        style: numberEaseStyle
      }, _to_consumable_array(numbers).concat(_to_consumable_array(numbers)).map(function(number2, subidx) {
        return /* @__PURE__ */ React.createElement("span", {
          className: "".concat(classPrefix2, "-number-text"),
          key: subidx
        }, number2);
      })) : /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-separator")
      }, item));
    })));
  };
  CountUp.displayName = "NutCountUp";
  var defaultProps$t = {};
  var AnimatingNumbers = /* @__PURE__ */ function(Component) {
    _inherits(AnimatingNumbers2, Component);
    function AnimatingNumbers2(props) {
      _class_call_check(this, AnimatingNumbers2);
      var _this;
      _this = _call_super(this, AnimatingNumbers2, [
        props
      ]);
      _this.state = {};
      return _this;
    }
    _create_class(AnimatingNumbers2, [
      {
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ React.createElement("div", {
            className: "nut-animatingnumbers"
          });
        }
      }
    ]);
    return AnimatingNumbers2;
  }(React.Component);
  _define_property(AnimatingNumbers, "defaultProps", defaultProps$t);
  _define_property(AnimatingNumbers, "displayName", "NutAnimatingNumbers");
  _define_property(AnimatingNumbers, "CountUp", CountUp);
  AnimatingNumbers.CountUp = CountUp;
  var defaultProps$s = _object_spread_props(_object_spread({}, ComponentDefaults), {
    src: "",
    muted: false,
    autoPlay: false,
    loop: false,
    preload: "auto",
    type: "progress",
    onBack: function(e2) {
    },
    onForward: function(e2) {
    },
    onPause: function(e2) {
    },
    onEnd: function(e2) {
    },
    onMute: function(e2) {
    },
    onCanPlay: function(e2) {
    }
  });
  var Audio = function(props) {
    var watch = function watch2() {
      if (AudioRef && AudioRef.current) {
        var current = AudioRef.current;
        current.addEventListener("play", function() {
          setPlaying(true);
        });
      }
    };
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$s, props), className = _ref.className, src = _ref.src, style = _ref.style, muted = _ref.muted, autoPlay = _ref.autoPlay, loop2 = _ref.loop, preload = _ref.preload, type2 = _ref.type, onBack = _ref.onBack, onForward = _ref.onForward, onPause = _ref.onPause, onEnd = _ref.onEnd, onMute = _ref.onMute, onCanPlay = _ref.onCanPlay, children = _ref.children, rest = _object_without_properties(_ref, [
      "className",
      "src",
      "style",
      "muted",
      "autoPlay",
      "loop",
      "preload",
      "type",
      "onBack",
      "onForward",
      "onPause",
      "onEnd",
      "onMute",
      "onCanPlay",
      "children"
    ]);
    var _useState = _sliced_to_array(React.useState(false), 2), playing = _useState[0], setPlaying = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(0), 2), percent = _useState1[0], setPercent = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(false), 2), isCanPlay = _useState2[0], setIsCanPlay = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState("00:00:00"), 2), currentDuration = _useState3[0], setCurrentDuration = _useState3[1];
    var AudioRef = React.useRef(null);
    var statusRef = React.useRef({
      currentTime: 0,
      currentDuration: "00:00:00",
      percent: 0,
      duration: "00:00:00",
      second: 0,
      hanMuted: muted,
      playing: autoPlay,
      handPlaying: false
    });
    var classPrefix2 = "nut-audio";
    var handleEnded = function(e2) {
      if (loop2) {
        console.warn(locale.audio.tips || "onPlayEndloop=false");
      } else {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd(e2);
      }
    };
    React.useEffect(function() {
      watch();
    }, []);
    React.useEffect(function() {
    }, [
      currentDuration
    ]);
    var handleStatusChange = function() {
      setPlaying(!playing);
      if (playing) {
        AudioRef && AudioRef.current && AudioRef.current.pause();
      } else {
        AudioRef && AudioRef.current && AudioRef.current.play();
      }
    };
    var renderIcon = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-icon")
      }, /* @__PURE__ */ React.createElement("div", {
        className: classNames("".concat(classPrefix2, "-icon-box"), playing ? "".concat(classPrefix2, "-icon-play") : "".concat(classPrefix2, "-icon-stop")),
        onClick: handleStatusChange
      }, /* @__PURE__ */ React.createElement(m$2, {
        className: playing ? "nut-icon-loading" : ""
      })));
    };
    var handleBack = function() {
      if (statusRef.current.currentTime > 0 && AudioRef.current) {
        statusRef.current.currentTime--;
        AudioRef.current.currentTime = statusRef.current.currentTime;
        onBack === null || onBack === void 0 ? void 0 : onBack(AudioRef.current);
      }
    };
    var handleForward = function() {
      if (AudioRef.current) {
        statusRef.current.currentTime++;
        AudioRef.current.currentTime = statusRef.current.currentTime;
        onForward === null || onForward === void 0 ? void 0 : onForward(AudioRef.current);
      }
    };
    var handleMute = function() {
      if (AudioRef.current) {
        AudioRef.current.muted = !AudioRef.current.muted;
        onMute === null || onMute === void 0 ? void 0 : onMute(AudioRef.current);
      }
    };
    var handlePause = function(e2) {
      setPlaying(false);
      onPause === null || onPause === void 0 ? void 0 : onPause(e2);
    };
    var formatSeconds = function(value2) {
      if (!value2) {
        return "00:00:00";
      }
      var time2 = parseInt(value2);
      var hours = Math.floor(time2 / 3600);
      var minutes = Math.floor((time2 - hours * 3600) / 60);
      var seconds = time2 - hours * 3600 - minutes * 60;
      var result = "";
      result += "".concat("0".concat(hours.toString()).slice(-2), ":");
      result += "".concat("0".concat(minutes.toString()).slice(-2), ":");
      result += "0".concat(seconds.toString()).slice(-2);
      return result;
    };
    var renderProgerss = function() {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-progress")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "time"
      }, currentDuration), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-progress-bar-wrapper")
      }, /* @__PURE__ */ React.createElement(Range, {
        value: percent,
        onChange: function(val2) {
          return setPercent(val2);
        },
        currentDescription: null,
        maxDescription: null,
        minDescription: null,
        "inactive-color": "#cccccc",
        "active-color": "#FF0F23"
      })), /* @__PURE__ */ React.createElement("div", {
        className: "time"
      }, AudioRef.current ? formatSeconds("".concat(statusRef.current.second)) : "00:00:00")), /* @__PURE__ */ React.createElement("div", {
        className: isCanPlay ? "custom-button-group" : "custom-button-group-disable"
      }, /* @__PURE__ */ React.createElement(Button, {
        type: "primary",
        size: "small",
        className: "back",
        onClick: handleBack
      }, locale.audio.back || ""), /* @__PURE__ */ React.createElement(Button, {
        type: "primary",
        size: "small",
        className: "start",
        onClick: handleStatusChange
      }, playing ? "".concat(locale.audio.pause || "") : "".concat(locale.audio.start || "")), /* @__PURE__ */ React.createElement(Button, {
        type: "primary",
        size: "small",
        onClick: handleForward
      }, locale.audio.forward || ""), /* @__PURE__ */ React.createElement(Button, {
        type: AudioRef.current && AudioRef.current.muted ? "default" : "primary",
        size: "small",
        onClick: handleMute
      }, locale.audio.mute || "")));
    };
    var renderNone = function() {
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-none-container"),
        onClick: handleStatusChange
      }, children);
    };
    var renderAudio = function() {
      switch (type2) {
        case "icon":
          return renderIcon();
        case "progress":
          return renderProgerss();
        case "none":
          return renderNone();
        default:
          return null;
      }
    };
    var handleCanplay = function(e2) {
      setIsCanPlay(true);
      if (autoPlay && !playing) {
        AudioRef && AudioRef.current && AudioRef.current.play();
      }
      if (AudioRef.current) {
        statusRef.current.second = AudioRef.current.duration || 0;
        onCanPlay === null || onCanPlay === void 0 ? void 0 : onCanPlay(e2);
      }
    };
    var onTimeupdate = function(e2) {
      var time2 = parseInt(String(e2.target.currentTime));
      var formated = formatSeconds("".concat(time2));
      statusRef.current.currentDuration = formated;
      setPercent(time2 / statusRef.current.second * 100);
      setCurrentDuration(formated);
      statusRef.current.currentTime = time2;
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix2, className),
      style
    }, rest), renderAudio(), /* @__PURE__ */ React.createElement("audio", {
      className: "audioMain",
      controls: type2 === "controls",
      ref: AudioRef,
      src,
      muted,
      preload,
      loop: loop2,
      onPause: function(e2) {
        return handlePause(e2);
      },
      onEnded: function(e2) {
        return handleEnded(e2);
      },
      onCanPlay: function(e2) {
        return handleCanplay(e2);
      },
      onTimeUpdate: function(e2) {
        return onTimeupdate(e2);
      }
    }, /* @__PURE__ */ React.createElement("track", {
      kind: "captions"
    })));
  };
  Audio.displayName = "NutAudio";
  var AvatarContext = React.createContext({});
  var defaultProps$r = _object_spread_props(_object_spread({}, ComponentDefaults), {
    maxContent: "",
    max: "",
    maxBackground: "#eee",
    maxColor: "#666",
    gap: "-8",
    level: "left"
  });
  var classPrefix$8 = "nut-avatar-group";
  var AvatarGroup = function(props) {
    var propAvatarGroup = _object_spread({}, defaultProps$r, props);
    var className = propAvatarGroup.className, style = propAvatarGroup.style, children = propAvatarGroup.children;
    var avatarGroupRef = React.useRef(null);
    var cls = classNames(classPrefix$8, className);
    var parentAvatar = {
      propAvatarGroup,
      avatarGroupRef
    };
    return /* @__PURE__ */ React.createElement(AvatarContext.Provider, {
      value: parentAvatar
    }, /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style,
      ref: avatarGroupRef
    }, children));
  };
  AvatarGroup.displayName = "NutAvatarGroup";
  var defaultProps$q = _object_spread_props(_object_spread({}, ComponentDefaults), {
    size: "",
    shape: "round",
    icon: "",
    background: "#eee",
    color: "#666",
    fit: "cover",
    src: "",
    alt: ""
  });
  var classPrefix$7 = "nut-avatar";
  var Avatar = function(props) {
    var _ref = _object_spread({}, defaultProps$q, props), children = _ref.children, size = _ref.size, shape = _ref.shape, background = _ref.background, color = _ref.color, src = _ref.src, alt = _ref.alt, icon = _ref.icon, fit = _ref.fit, className = _ref.className, style = _ref.style, onClick = _ref.onClick, onError = _ref.onError, rest = _object_without_properties(_ref, [
      "children",
      "size",
      "shape",
      "background",
      "color",
      "src",
      "alt",
      "icon",
      "fit",
      "className",
      "style",
      "onClick",
      "onError"
    ]);
    var _useState = _sliced_to_array(React.useState(0), 2), maxSum = _useState[0], setMaxSum = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(false), 2), showMax = _useState1[0], setShowMax = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(1), 2), avatarIndex = _useState2[0], setAvatarIndex = _useState2[1];
    var avatarRef = React.useRef(null);
    var parent2 = React.useContext(AvatarContext);
    var sizeValue = [
      "large",
      "normal",
      "small"
    ];
    var propAvatarGroup = parent2.propAvatarGroup, avatarGroupRef = parent2.avatarGroupRef;
    var _obj;
    var classes = classNames((_obj = {}, _define_property(_obj, "nut-avatar-".concat((propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.size) || size || "normal"), true), _define_property(_obj, "nut-avatar-".concat((propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.shape) || shape), true), _define_property(_obj, "nut-avatar-".concat((propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.size) || size || "normal", "-round"), shape === "round" && true), _obj));
    var cls = classNames(classPrefix$7, classes, className);
    var styles = _object_spread({
      width: sizeValue.indexOf(size) > -1 ? "" : "".concat(size, "px"),
      height: sizeValue.indexOf(size) > -1 ? "" : "".concat(size, "px"),
      backgroundColor: "".concat(background),
      color,
      marginLeft: avatarIndex !== 1 && (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.gap) ? "".concat(propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.gap, "px") : "",
      zIndex: (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.level) === "right" ? "".concat(Math.abs(maxSum - avatarIndex)) : ""
    }, style);
    var maxStyles = {
      backgroundColor: "".concat(propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.maxBackground),
      color: "".concat(propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.maxColor)
    };
    var avatarLength = React.useCallback(function(children2) {
      var _avatarRef_current_dataset, _avatarRef_current;
      for (var i2 = 0; i2 < children2.length; i2++) {
        if (children2[i2] && children2[i2].classList && children2[i2].classList[0] === "nut-avatar") {
          children2[i2].setAttribute("data-index", i2 + 1);
        }
      }
      var index2 = Number(avatarRef === null || avatarRef === void 0 ? void 0 : (_avatarRef_current = avatarRef.current) === null || _avatarRef_current === void 0 ? void 0 : (_avatarRef_current_dataset = _avatarRef_current.dataset) === null || _avatarRef_current_dataset === void 0 ? void 0 : _avatarRef_current_dataset.index);
      var maxCount = (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max) || children2.length;
      setMaxSum(children2.length);
      setAvatarIndex(index2);
      if (index2 === children2.length && index2 !== maxCount && children2.length > maxCount) {
        setShowMax(true);
      }
    }, [
      propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max
    ]);
    React.useEffect(function() {
      var avatarChildren = avatarGroupRef === null || avatarGroupRef === void 0 ? void 0 : avatarGroupRef.current.children;
      if (avatarChildren) {
        avatarLength(avatarChildren);
      }
    }, [
      avatarLength,
      avatarGroupRef
    ]);
    var errorEvent = function() {
      onError && onError();
    };
    var clickAvatar = function(e2) {
      onClick && onClick(e2);
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, (showMax || !(propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max) || avatarIndex <= (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max)) && /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: cls
    }, rest), {
      style: !showMax ? styles : maxStyles,
      onClick: clickAvatar,
      ref: avatarRef
    }), (!(propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max) || avatarIndex <= (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max)) && /* @__PURE__ */ React.createElement(React.Fragment, null, src && /* @__PURE__ */ React.createElement(Image$1, {
      className: "nut-avatar-img",
      src,
      alt,
      style: {
        objectFit: fit
      },
      onError: errorEvent
    }), /* @__PURE__ */ React.isValidElement(icon) ? /* @__PURE__ */ React.cloneElement(icon, _object_spread_props(_object_spread({}, icon.props), {
      className: "".concat(icon.props.className || "", " nut-avatar-icon")
    })) : null, children && /* @__PURE__ */ React.createElement("span", {
      className: "nut-avatar-text"
    }, children), !src && !icon && !children && /* @__PURE__ */ React.createElement(m, {
      className: "nut-avatar-icon"
    })), showMax && /* @__PURE__ */ React.createElement("div", {
      className: "nut-avatar-text"
    }, (propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.maxContent) ? propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.maxContent : "+ ".concat(avatarIndex - Number((propAvatarGroup === null || propAvatarGroup === void 0 ? void 0 : propAvatarGroup.max) || 0)))));
  };
  Avatar.displayName = "NutAvatar";
  Avatar.Group = AvatarGroup;
  var defaultProps$p = _object_spread_props(_object_spread({}, ComponentDefaults), {
    strokeWidth: 5,
    radius: 50,
    strokeLinecap: "round",
    color: "#FF0F23",
    background: "#e5e9f2",
    clockwise: true
  });
  var classPrefix$6 = "nut-circleprogress";
  var CircleProgress = function(props) {
    var _stop;
    var _ref = _object_spread({}, defaultProps$p, props), children = _ref.children, percent = _ref.percent, className = _ref.className, radius = _ref.radius, clockwise = _ref.clockwise, strokeWidth = _ref.strokeWidth, color = _ref.color, background = _ref.background, style = _ref.style, strokeLinecap = _ref.strokeLinecap, restProps = _object_without_properties(_ref, [
      "children",
      "percent",
      "className",
      "radius",
      "clockwise",
      "strokeWidth",
      "color",
      "background",
      "style",
      "strokeLinecap"
    ]);
    var classes = classNames(classPrefix$6, className);
    var refRandomId = Math.random().toString(36).slice(-8);
    var styles = _object_spread({
      height: "".concat(Number(radius) * 2, "px"),
      width: "".concat(Number(radius) * 2, "px")
    }, style);
    var pathStyle = {
      stroke: background
    };
    var hoverStyle = function() {
      var perimeter = 283;
      var offset = perimeter * Number(percent) / 100;
      return {
        stroke: isObject(color) ? "url(#".concat(refRandomId, ")") : color,
        strokeDasharray: "".concat(offset, "px ").concat(perimeter, "px")
      };
    };
    var path = function() {
      var isWise = clockwise ? 1 : 0;
      return "M 50 50 m -45 0 a 45 45 0 1 ".concat(isWise, " 90 0  a 45 45 0 1 ").concat(isWise, " -90 0");
    };
    var stop2 = function() {
      if (!isObject(color)) {
        return;
      }
      var colorArr = Object.keys(color).sort(function(a, b) {
        return parseFloat(a) - parseFloat(b);
      });
      var stopArr = [];
      colorArr.forEach(function(item) {
        var obj = {
          key: "",
          value: ""
        };
        obj.key = item;
        obj.value = color[item];
        stopArr.push(obj);
      });
      return stopArr;
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      style: styles
    }, restProps), /* @__PURE__ */ React.createElement("svg", {
      viewBox: "0 0 100 100"
    }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("linearGradient", {
      id: refRandomId,
      x1: "100%",
      y1: "0%",
      x2: "0%",
      y2: "0%"
    }, (_stop = stop2()) === null || _stop === void 0 ? void 0 : _stop.map(function(item, index2) {
      return /* @__PURE__ */ React.createElement("stop", {
        key: index2,
        offset: item.key,
        stopColor: item.value
      });
    }))), /* @__PURE__ */ React.createElement("path", {
      className: "nut-circleprogress-path",
      d: path(),
      style: pathStyle,
      fill: "none",
      strokeWidth
    }), /* @__PURE__ */ React.createElement("path", {
      className: "nut-circleprogress-hover",
      style: hoverStyle(),
      d: path(),
      fill: "none",
      strokeLinecap,
      transform: "rotate(90,50,50)",
      strokeWidth
    })), /* @__PURE__ */ React.createElement("div", {
      className: "nut-circleprogress-text"
    }, children));
  };
  CircleProgress.displayName = "NutCircleProgress";
  var collapseContext = {
    isOpen: function(name2) {
      return true;
    },
    updateValue: function(name2) {
    },
    expandIcon: null,
    rotate: 180
  };
  const CollapseContext = React.createContext(collapseContext);
  var defaultProps$o = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: null,
    name: "",
    expandIcon: null,
    disabled: false,
    extra: null
  });
  var CollapseItem = function(props) {
    var _ref = _object_spread({}, defaultProps$o, props), children = _ref.children, title = _ref.title, name2 = _ref.name, disabled = _ref.disabled, expandIcon = _ref.expandIcon, rotate = _ref.rotate, extra = _ref.extra, style = _ref.style, className = _ref.className, rest = _object_without_properties(_ref, [
      "children",
      "title",
      "name",
      "disabled",
      "expandIcon",
      "rotate",
      "extra",
      "style",
      "className"
    ]);
    var classPrefix2 = "nut-collapse-item";
    var context2 = React.useContext(CollapseContext);
    var wrapperRef = React.useRef(null);
    var contentRef = React.useRef(null);
    var expanded = React.useMemo(function() {
      if (context2) {
        return context2.isOpen(name2);
      }
      return false;
    }, [
      name2,
      context2.isOpen
    ]);
    var iconStyle = React.useMemo(function() {
      return expanded ? {
        transform: "translateY(-50%) rotate(".concat(rotate || context2.rotate, "deg)")
      } : {
        transform: "translateY(-50%)"
      };
    }, [
      expanded,
      rotate
    ]);
    var _useState = _sliced_to_array(React.useState(0), 2), tran = _useState[0], setTran = _useState[1];
    var _useRefState = _sliced_to_array(useRefState(0), 2), currentHeight = _useRefState[0], setCurrentHeight = _useRefState[1];
    var _useState1 = _sliced_to_array(React.useState(0), 2), wrapperHeight = _useState1[0], setWrapperHeight = _useState1[1];
    var updateRectHeight = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function() {
        var height2;
        return __generator(this, function(_state) {
          height2 = contentRef.current.offsetHeight;
          setCurrentHeight(height2);
          setWrapperHeight(expanded ? height2 : 0);
          setTimeout(function() {
            setTran(1);
          });
          return [
            2
          ];
        });
      });
      return function updateRectHeight2() {
        return _ref2.apply(this, arguments);
      };
    }();
    React.useEffect(function() {
      updateRectHeight();
    }, [
      children,
      expanded
    ]);
    var toggle = function() {
      var end = !expanded ? currentHeight.current : 0;
      setWrapperHeight(end);
    };
    var handleClick = function() {
      if (!disabled) {
        context2.updateValue(name2);
        toggle();
      }
    };
    var _obj;
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix2, className),
      style
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-header"), _define_property({}, "".concat(classPrefix2, "-header-disabled"), disabled)),
      onClick: handleClick
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-title")
    }, title), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-extra")
    }, extra), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-icon-box")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-icon"),
      style: iconStyle
    }, expandIcon || context2.expandIcon))), /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-content-wrapper"), true), _define_property(_obj, "".concat(classPrefix2, "-content-wrapper-tran"), true), _obj)),
      style: tran ? {
        height: wrapperHeight
      } : {},
      ref: wrapperRef
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-content")
    }, /* @__PURE__ */ React.createElement("div", {
      ref: contentRef,
      className: "".concat(classPrefix2, "-content-text")
    }, children))));
  };
  CollapseItem.displayName = "NutCollapseItem";
  var defaultProps$n = _object_spread_props(_object_spread({}, ComponentDefaults), {
    defaultActiveName: [],
    accordion: false,
    expandIcon: null,
    rotate: 180
  });
  var Collapse = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$n, props), className = _$_object_spread.className, style = _$_object_spread.style, children = _$_object_spread.children, activeName = _$_object_spread.activeName, defaultActiveName = _$_object_spread.defaultActiveName, accordion = _$_object_spread.accordion, expandIcon = _$_object_spread.expandIcon, rotate = _$_object_spread.rotate, onChange = _$_object_spread.onChange;
    var classPrefix2 = "nut-collapse";
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: activeName,
      defaultValue: defaultActiveName,
      finalValue: []
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var changeVal = function(newValue, name2, isOpen2) {
      setValue(newValue);
      onChange && onChange(newValue, name2, isOpen2);
    };
    var updateValue = function(name2) {
      if (accordion) {
        if (value2 === name2) {
          changeVal("", name2, false);
        } else {
          changeVal(name2, name2, true);
        }
      } else if (Array.isArray(value2)) {
        if (value2.includes(name2)) {
          var newValue = value2.filter(function(v) {
            return v !== name2;
          });
          changeVal(newValue, name2, false);
        } else {
          var newValue1 = value2.concat([
            name2
          ]);
          changeVal(newValue1, name2, true);
        }
      } else {
        console.warn("[NutUI] <Collapse>  activeName ");
      }
    };
    var isOpen = React.useCallback(function(name2) {
      if (accordion) {
        return value2 === name2;
      }
      if (Array.isArray(value2)) {
        return value2.includes(name2);
      }
      return false;
    }, [
      accordion,
      value2
    ]);
    return /* @__PURE__ */ React.createElement(CollapseContext.Provider, {
      value: {
        isOpen,
        updateValue,
        expandIcon,
        rotate
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className),
      style
    }, children));
  };
  Collapse.displayName = "NutCollapse";
  Collapse.Item = CollapseItem;
  var defaultProps$m = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "default",
    paused: false,
    startTime: Date.now(),
    endTime: Date.now(),
    remainingTime: 0,
    millisecond: false,
    format: "HH:mm:ss",
    autoStart: true,
    time: 0,
    destroy: false
  });
  var InternalCountDown = function(props, ref) {
    var _ref = _object_spread({}, defaultProps$m, props), type2 = _ref.type, paused = _ref.paused, startTime = _ref.startTime, endTime = _ref.endTime, remainingTime = _ref.remainingTime;
    _ref.millisecond;
    var format2 = _ref.format, autoStart = _ref.autoStart, time2 = _ref.time, destroy = _ref.destroy, className = _ref.className, style = _ref.style, onEnd = _ref.onEnd, onPaused = _ref.onPaused, onRestart = _ref.onRestart, onUpdate = _ref.onUpdate, children = _ref.children, rest = _object_without_properties(_ref, [
      "type",
      "paused",
      "startTime",
      "endTime",
      "remainingTime",
      "millisecond",
      "format",
      "autoStart",
      "time",
      "destroy",
      "className",
      "style",
      "onEnd",
      "onPaused",
      "onRestart",
      "onUpdate",
      "children"
    ]);
    var classPrefix2 = "nut-countdown";
    var _useState = _sliced_to_array(React.useState(0), 2), restTimeStamp = _useState[0], setRestTime = _useState[1];
    var stateRef = React.useRef({
      pauseTime: 0,
      curr: 0,
      isPaused: paused,
      isIninted: false,
      timer: 0,
      restTime: 0,
      counting: !paused && autoStart,
      handleEndTime: Date.now(),
      diffTime: 0
    });
    var getTimeStamp = function(timeStr) {
      if (!timeStr) return Date.now();
      var t = timeStr;
      t = Number(t) > 0 ? +t : t.toString().replace(/-/g, "/");
      return new Date(t).getTime();
    };
    var initTime = function() {
      if (remainingTime) {
        stateRef.current.handleEndTime = Date.now() + Number(remainingTime);
      } else {
        stateRef.current.handleEndTime = endTime;
        stateRef.current.diffTime = Date.now() - getTimeStamp(startTime);
      }
      if (!stateRef.current.counting) stateRef.current.counting = true;
      tick();
    };
    var tick = function() {
      stateRef.current.timer = requestAnimationFrame(function() {
        if (stateRef.current.counting) {
          var currentTime = Date.now() - stateRef.current.diffTime;
          var remainTime = Math.max(stateRef.current.handleEndTime - currentTime, 0);
          stateRef.current.restTime = remainTime;
          setRestTime(remainTime);
          if (!remainTime) {
            stateRef.current.counting = false;
            pause();
            onEnd && onEnd();
          }
          if (remainTime > 0) {
            tick();
          }
        }
      });
    };
    var formatRemainTime = function(t, type3) {
      var ts2 = t;
      var rest2 = {
        d: 0,
        h: 0,
        m: 0,
        s: 0,
        ms: 0
      };
      var SECOND = 1e3;
      var MINUTE = 60 * SECOND;
      var HOUR = 60 * MINUTE;
      var DAY = 24 * HOUR;
      if (ts2 > 0) {
        rest2.d = ts2 >= SECOND ? Math.floor(ts2 / DAY) : 0;
        rest2.h = Math.floor(ts2 % DAY / HOUR);
        rest2.m = Math.floor(ts2 % HOUR / MINUTE);
        rest2.s = Math.floor(ts2 % MINUTE / SECOND);
        rest2.ms = Math.floor(ts2 % SECOND);
      }
      return type3 === "custom" ? rest2 : parseFormat(_object_spread({}, rest2));
    };
    var parseFormat = function(time3) {
      var d2 = time3.d;
      var h = time3.h, m2 = time3.m, s2 = time3.s, ms = time3.ms;
      var formatCache = format2;
      if (formatCache.includes("DD")) {
        formatCache = formatCache.replace("DD", padZero(d2));
      } else {
        h += Number(d2) * 24;
      }
      if (formatCache.includes("HH")) {
        formatCache = formatCache.replace("HH", padZero(h));
      } else {
        m2 += Number(h) * 60;
      }
      if (formatCache.includes("mm")) {
        formatCache = formatCache.replace("mm", padZero(m2));
      } else {
        s2 += Number(m2) * 60;
      }
      if (formatCache.includes("ss")) {
        formatCache = formatCache.replace("ss", padZero(s2));
      } else {
        ms += Number(s2) * 1e3;
      }
      if (formatCache.includes("S")) {
        var msC = padZero(ms, 3).toString();
        if (formatCache.includes("SSS")) {
          formatCache = formatCache.replace("SSS", msC);
        } else if (formatCache.includes("SS")) {
          formatCache = formatCache.replace("SS", msC.slice(0, 2));
        } else if (formatCache.includes("S")) {
          formatCache = formatCache.replace("S", msC.slice(0, 1));
        }
      }
      var isTextDom = type2 === "text" ? '<span class="nut-countdown-number-text">$1</span>' : '<span class="nut-countdown-number">$1</span>';
      formatCache = formatCache.replace(/(\d+)/g, type2 === "primary" ? '<span class="nut-countdown-number-primary">$1</span>' : isTextDom);
      return formatCache;
    };
    var pause = function() {
      cancelAnimationFrame(stateRef.current.timer);
      stateRef.current.counting = false;
      onPaused && onPaused(stateRef.current.restTime);
    };
    React.useImperativeHandle(ref, function() {
      return {
        start: function() {
          if (!stateRef.current.counting && !autoStart) {
            stateRef.current.counting = true;
            stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
            tick();
            onRestart && onRestart(stateRef.current.restTime);
          }
        },
        pause: function() {
          cancelAnimationFrame(stateRef.current.timer);
          stateRef.current.counting = false;
          onPaused && onPaused(stateRef.current.restTime);
        },
        reset: function() {
          if (!autoStart) {
            pause();
            stateRef.current.restTime = time2;
            setRestTime(time2);
          }
        }
      };
    });
    React.useEffect(function() {
      var tranTime = formatRemainTime(stateRef.current.restTime, "custom");
      onUpdate && onUpdate(tranTime);
    }, [
      restTimeStamp
    ]);
    React.useEffect(function() {
      if (stateRef.current.isIninted) {
        if (paused) {
          if (stateRef.current.counting) {
            pause();
          }
        } else {
          if (!stateRef.current.counting) {
            stateRef.current.counting = true;
            stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
            tick();
          }
          onRestart && onRestart(stateRef.current.restTime);
        }
      }
    }, [
      paused
    ]);
    React.useEffect(function() {
      if (stateRef.current.isIninted) {
        initTime();
      }
    }, [
      endTime,
      startTime,
      remainingTime
    ]);
    React.useEffect(function() {
      if (autoStart) {
        initTime();
      } else {
        stateRef.current.restTime = time2;
        setRestTime(time2);
      }
      if (!stateRef.current.isIninted) {
        stateRef.current.isIninted = true;
      }
      return componentWillUnmount;
    }, []);
    var componentWillUnmount = function() {
      destroy && cancelAnimationFrame(stateRef.current.timer);
    };
    var renderTime = function() {
      return formatRemainTime(stateRef.current.restTime);
    }();
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children || /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: "".concat(classPrefix2, " ").concat(className),
      style: _object_spread({}, style)
    }, rest), {
      dangerouslySetInnerHTML: {
        __html: "".concat(renderTime)
      }
    })));
  };
  var CountDown = /* @__PURE__ */ React.forwardRef(InternalCountDown);
  CountDown.displayName = "NutCountDown";
  var useIsomorphicLayoutEffect = canUseDom ? React.useLayoutEffect : React.useEffect;
  var defaultProps$l = _object_spread_props(_object_spread({}, ComponentDefaults), {
    content: "",
    direction: "end",
    rows: 1,
    expandText: "",
    collapseText: "",
    symbol: "...",
    lineHeight: "20"
  });
  var classPrefix$5 = "nut-ellipsis";
  var Ellipsis = function(props) {
    var _ellipsis_current, _ellipsis_current1;
    var _ref = _object_spread({}, defaultProps$l, props);
    _ref.children;
    var content2 = _ref.content, className = _ref.className, direction = _ref.direction, rows = _ref.rows, expandText = _ref.expandText, collapseText = _ref.collapseText, symbol = _ref.symbol, lineHeight = _ref.lineHeight, onClick = _ref.onClick, onChange = _ref.onChange, rest = _object_without_properties(_ref, [
      "children",
      "content",
      "className",
      "direction",
      "rows",
      "expandText",
      "collapseText",
      "symbol",
      "lineHeight",
      "onClick",
      "onChange"
    ]);
    var rtl = useRtl();
    var container = null;
    var maxHeight = 0;
    var _useState = _sliced_to_array(React.useState(false), 2), exceeded = _useState[0], setExceeded = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(false), 2), expanded = _useState1[0], setExpanded = _useState1[1];
    var ellipsis = React.useRef();
    var root2 = React.useRef(null);
    var rtlClasses = classNames(_define_property({}, "".concat(classPrefix$5, "-rtl"), rtl));
    var classes = classNames(classPrefix$5, rtlClasses, className);
    useIsomorphicLayoutEffect(function() {
      if (content2) {
        createContainer();
      }
    }, [
      content2
    ]);
    var createContainer = function() {
      if (!root2.current) return;
      var originStyle = window.getComputedStyle(root2.current);
      container = document.createElement("div");
      var styleNames = Array.prototype.slice.apply(originStyle);
      styleNames.forEach(function(name2) {
        container.style.setProperty(name2, originStyle.getPropertyValue(name2));
      });
      container.style.position = "fixed";
      container.style.left = "999999px";
      container.style.top = "999999px";
      container.style.zIndex = "-1000";
      container.style.height = "auto";
      container.style.minHeight = "auto";
      container.style.maxHeight = "auto";
      container.style.textOverflow = "clip";
      container.style.whiteSpace = "normal";
      container.style.webkitLineClamp = "unset";
      container.style.display = "block";
      var lineH = pxToNumber(originStyle.lineHeight === "normal" ? lineHeight : originStyle.lineHeight);
      maxHeight = Math.floor(lineH * (Number(rows) + 0.5) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
      container.innerText = content2;
      document.body.appendChild(container);
      calcEllipse();
      document.body.removeChild(container);
    };
    var calcEllipse = function() {
      if (container.offsetHeight <= maxHeight) {
        setExceeded(false);
      } else {
        setExceeded(true);
        var end = content2.length;
        var middle = Math.floor((0 + end) / 2);
        var ellipsised = direction === "middle" ? tailorMiddle([
          0,
          middle
        ], [
          middle,
          end
        ]) : tailor(0, end);
        ellipsis.current = ellipsised;
      }
    };
    var tailor = function(left, right) {
      var actionText = expanded ? collapseText : expandText;
      var end = content2.length;
      if (right - left <= 1) {
        if (direction === "end") {
          return {
            leading: content2.slice(0, left) + symbol
          };
        }
        return {
          tailing: symbol + content2.slice(right, end)
        };
      }
      var middle = Math.round((left + right) / 2);
      if (direction === "end") {
        container.innerText = content2.slice(0, middle) + symbol + actionText;
      } else {
        container.innerText = actionText + symbol + content2.slice(middle, end);
      }
      if (container.offsetHeight <= maxHeight) {
        if (direction === "end") {
          return tailor(middle, right);
        }
        return tailor(left, middle);
      }
      if (direction === "end") {
        return tailor(left, middle);
      }
      return tailor(middle, right);
    };
    var tailorMiddle = function(leftPart, rightPart) {
      var actionText = expanded ? collapseText : expandText;
      var end = content2.length;
      if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
        return {
          leading: content2.slice(0, leftPart[0]) + symbol,
          tailing: symbol + content2.slice(rightPart[1], end)
        };
      }
      var leftPartMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
      var rightPartMiddle = Math.ceil((rightPart[0] + rightPart[1]) / 2);
      container.innerText = content2.slice(0, leftPartMiddle) + symbol + actionText + symbol + content2.slice(rightPartMiddle, end);
      if (container.offsetHeight <= maxHeight) {
        return tailorMiddle([
          leftPartMiddle,
          leftPart[1]
        ], [
          rightPart[0],
          rightPartMiddle
        ]);
      }
      return tailorMiddle([
        leftPart[0],
        leftPartMiddle
      ], [
        rightPartMiddle,
        rightPart[1]
      ]);
    };
    var pxToNumber = function(value2) {
      if (!value2) return 0;
      var match = value2.match(/^\d*(\.\d*)?/);
      return match ? Number(match[0]) : 0;
    };
    var clickHandle = function(type2) {
      if (type2 === 1) {
        setExpanded(true);
        onChange && onChange("expand");
      } else {
        setExpanded(false);
        onChange && onChange("collapse");
      }
    };
    var handleClick = function() {
      onClick && onClick();
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      onClick: handleClick,
      ref: root2
    }, rest), !exceeded ? content2 : null, exceeded && !expanded ? /* @__PURE__ */ React.createElement("span", null, (_ellipsis_current = ellipsis.current) === null || _ellipsis_current === void 0 ? void 0 : _ellipsis_current.leading, expandText ? /* @__PURE__ */ React.createElement("span", {
      className: "nut-ellipsis-text",
      onClick: function(e2) {
        e2.stopPropagation();
        clickHandle(1);
      }
    }, expandText) : null, (_ellipsis_current1 = ellipsis.current) === null || _ellipsis_current1 === void 0 ? void 0 : _ellipsis_current1.tailing) : null, exceeded && expanded ? /* @__PURE__ */ React.createElement("span", null, content2, expandText ? /* @__PURE__ */ React.createElement("span", {
      className: "nut-ellipsis-text",
      onClick: function(e2) {
        e2.stopPropagation();
        clickHandle(2);
      }
    }, collapseText) : null) : null);
  };
  Ellipsis.displayName = "NutEllipsis";
  var defaultProps$k = _object_spread_props(_object_spread({}, ComponentDefaults), {
    source: {
      type: {},
      src: ""
    },
    options: {
      controls: true,
      muted: false,
      autoplay: false,
      poster: "",
      playsinline: false,
      loop: false
    }
  });
  var classPrefix$4 = "nut-video";
  var Video = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _ref = _object_spread({}, defaultProps$k, props);
    _ref.children;
    var source = _ref.source, options2 = _ref.options, className = _ref.className, onPlay = _ref.onPlay, onPause = _ref.onPause, onPlayEnd = _ref.onPlayEnd, restProps = _object_without_properties(_ref, [
      "children",
      "source",
      "options",
      "className",
      "onPlay",
      "onPause",
      "onPlayEnd"
    ]);
    var rootRef = React.useRef(null);
    var classes = classNames(classPrefix$4, className);
    React.useEffect(function() {
      init();
    }, []);
    var init = function() {
      if (rootRef.current) {
        var videoRef = rootRef.current;
        if (options2.autoplay) {
          setTimeout(function() {
            videoRef.play();
          }, 200);
        }
        if (options2.playsinline) {
          videoRef.setAttribute("playsinline", String(options2.playsinline));
          videoRef.setAttribute("webkit-playsinline", String(options2.playsinline));
          videoRef.setAttribute("x5-video-player-type", "h5-page");
          videoRef.setAttribute("x5-video-player-fullscreen", "false");
        }
        videoRef.addEventListener("play", function() {
          onPlay && onPlay(videoRef);
        });
        videoRef.addEventListener("pause", function() {
          onPause && onPause(videoRef);
        });
        videoRef.addEventListener("ended", function() {
          videoRef.currentTime = 0;
          onPlayEnd && onPlayEnd(videoRef);
        });
      }
    };
    var pause = function() {
      var _rootRef_current;
      rootRef === null || rootRef === void 0 ? void 0 : (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.pause();
    };
    var play = function() {
      var _rootRef_current;
      rootRef === null || rootRef === void 0 ? void 0 : (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.play();
    };
    React.useImperativeHandle(ref, function() {
      return {
        pause,
        play
      };
    });
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, restProps), /* @__PURE__ */ React.createElement("video", {
      className: "nut-video-player",
      muted: options2.muted,
      autoPlay: options2.autoplay,
      loop: options2.loop,
      poster: options2.poster,
      controls: options2.controls,
      ref: rootRef,
      src: source.src
    }, /* @__PURE__ */ React.createElement("source", {
      src: source.src,
      type: source.type
    }), /* @__PURE__ */ React.createElement("track", {
      kind: "captions"
    })));
  });
  Video.displayName = "NutVideo";
  var defaultProps$j = {
    total: 2,
    current: 0,
    direction: "horizontal",
    color: "primary",
    type: "anchor"
  };
  var classPrefix$3 = "nut-indicator";
  var Indicator = function(props) {
    var maybeFixedWidth = function maybeFixedWidth2() {
      if (type2 === "dualScreen" || type2 === "slide") {
        return "".concat(classPrefix$3, "-fixed-width");
      }
      return "";
    };
    var _ref = _object_spread({}, defaultProps$j, props), color = _ref.color, type2 = _ref.type, total = _ref.total, current = _ref.current, children = _ref.children, className = _ref.className, direction = _ref.direction, rest = _object_without_properties(_ref, [
      "color",
      "type",
      "total",
      "current",
      "children",
      "className",
      "direction"
    ]);
    var _obj;
    var classes = classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix$3, "-vertical"), direction === "vertical"), _define_property(_obj, "".concat(classPrefix$3, "-white"), color === "default"), _define_property(_obj, "".concat(classPrefix$3, "-track"), type2 === "slide"), _obj));
    var renderDotElement = function() {
      var childs = [];
      for (var item = 0; item < total; item++) {
        childs.push(item === current ? children || /* @__PURE__ */ React.createElement("div", {
          key: item,
          className: "".concat(classPrefix$3, "-dot ").concat(classPrefix$3, "-dot-active")
        }) : /* @__PURE__ */ React.createElement("div", {
          key: item,
          className: "".concat(classPrefix$3, "-dot")
        }));
      }
      return childs;
    };
    var renderLineElement = function() {
      var trackWidth = 21;
      var sliderWidth = 6;
      var stride = (trackWidth - sliderWidth) / (total - 1);
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          transform: "".concat(direction === "vertical" ? "translateY" : "translateX", "(").concat(current * stride, "px)")
        },
        className: "".concat(classPrefix$3, "-line ").concat(classPrefix$3, "-line-active")
      });
    };
    var renderByType = function(type3) {
      switch (type3) {
        case "slide":
          return renderLineElement();
        default:
          return renderDotElement();
      }
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix$3, classes, maybeFixedWidth(), className)
    }, rest), renderByType(type2));
  };
  Indicator.displayName = "NutIndicator";
  var getPerSlidePosition$1 = function(index2, position2, loop2, count) {
    var currentPosition = index2 * 100 + position2;
    if (loop2) {
      var cycle = count * 100;
      var shift = cycle / 2;
      var nextPosition = (currentPosition + shift) % cycle;
      var shiftedPosition = (nextPosition < 0 ? nextPosition + cycle : nextPosition) - shift;
      return "".concat(shiftedPosition, "%");
    }
    return "".concat(currentPosition, "%");
  };
  var defaultEffect = function(args) {
    return React.Children.map(args.children, function(child, index2) {
      var isVertical = args.isVertical, getSpringsAxis = args.getSpringsAxis, loop2 = args.loop, count = args.count;
      var rtl = useRtl();
      var position2 = rtl ? "right" : "left";
      var _obj;
      return /* @__PURE__ */ React.createElement(animated.div, {
        className: "nut-swiper-slide",
        style: (_obj = {}, _define_property(_obj, isVertical ? "y" : "x", getSpringsAxis().to(function(position3) {
          return getPerSlidePosition$1(index2, position3, loop2, count);
        })), _define_property(_obj, isVertical ? "top" : position2, "-".concat(index2 * 100, "%")), _obj)
      }, child);
    });
  };
  var getPerSlidePosition = function(index2, position2, loop2, count) {
    var currentPosition = index2 * 100 + position2;
    if (loop2) {
      var cycle = count * 100;
      var shift = cycle / 2;
      var nextPosition = (currentPosition + shift) % cycle;
      var shiftedPosition = (nextPosition < 0 ? nextPosition + cycle : nextPosition) - shift;
      return "".concat(shiftedPosition, "%");
    }
    return "".concat(currentPosition, "%");
  };
  var focusEffect = function(args) {
    return React.Children.map(args.children, function(child, index2) {
      var rtl = useRtl();
      var position2 = rtl ? "right" : "left";
      var isVertical = args.isVertical, springs = args.springs, transforms = args.transforms, loop2 = args.loop, count = args.count, swiperDirection = args.swiperDirection, dragging = args.dragging, current = args.current, effect2 = args.effect;
      var _obj;
      return /* @__PURE__ */ React.createElement(animated.div, {
        className: "nut-swiper-slide",
        style: (_obj = {}, _define_property(_obj, isVertical ? "y" : "x", springs[isVertical ? "y" : "x"].to(function(position3) {
          return getPerSlidePosition(index2, position3, loop2, count);
        })), _define_property(_obj, isVertical ? "top" : position2, "-".concat(index2 * 100, "%")), _define_property(_obj, "scale", springs.s.to(function(ss) {
          var scales = getRefValue(transforms);
          if (!scales) return 1;
          var scale2 = scales[index2];
          var currentRefValue = getRefValue(current);
          if (dragging === false) ss = 0;
          var ps = ss * scale2;
          if (index2 === currentRefValue) {
            return Math.max(scale2 - ps, effect2.scale);
          }
          if (index2 === currentRefValue + swiperDirection.current) {
            return Math.min(scale2 + ps, 1);
          }
          return scale2;
        })), _obj)
      }, child);
    });
  };
  var useList = function(effect2, count, current) {
    var _useRefState = _sliced_to_array(useRefState([]), 2), transforms = _useRefState[0], setTransforms = _useRefState[1];
    React.useEffect(function() {
      setTransforms(Array.from({
        length: count
      }).fill(1).map(function(scale2, index2) {
        return index2 !== getRefValue(current) ? scale2 * (effect2 ? effect2.scale : 1) : scale2;
      }));
    }, [
      count
    ]);
    return [
      transforms,
      setTransforms
    ];
  };
  var updateTransform = function(transforms, setTransforms, effect2, page) {
    setTransforms(getRefValue(transforms).map(function(s2, index2) {
      return (
        // eslint-disable-next-line no-nested-ternary
        page === index2 ? 1 : effect2 ? effect2.scale : 1
      );
    }));
  };
  var defaultProps$i = {
    direction: "horizontal",
    indicator: false,
    loop: false,
    duration: 3e3,
    autoPlay: false,
    defaultValue: 0,
    touchable: true,
    effect: void 0
  };
  var Swiper = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var boundIndex = function boundIndex2(current2) {
      var min = 0;
      var max = count - 1;
      if (current2 === max && !loop2 && props.slideSize) {
        var slideSize = props.slideSize;
        var swiperSize = getSwiperSize();
        var ratio = (swiperSize - slideSize) / slideSize;
        return bound2(current2, min, max - ratio);
      }
      return current2;
    };
    var classPrefix2 = "nut-swiper";
    var _$_object_spread = _object_spread({}, defaultProps$i, props), children = _$_object_spread.children, direction = _$_object_spread.direction, indicator = _$_object_spread.indicator, loop2 = _$_object_spread.loop, effect2 = _$_object_spread.effect, autoPlay = _$_object_spread.autoPlay, touchable = _$_object_spread.touchable, defaultValue = _$_object_spread.defaultValue, duration = _$_object_spread.duration, style = _$_object_spread.style, className = _$_object_spread.className;
    var isVertical = direction === "vertical";
    var count = React.useMemo(function() {
      var c6 = 0;
      React.Children.map(children, function(child, index2) {
        c6 += 1;
      });
      return c6;
    }, [
      children
    ]);
    var getSlideSize = function() {
      if (props.slideSize) return props.slideSize;
      if (stageRef.current) {
        if (isVertical) return stageRef.current.offsetHeight;
        return stageRef.current.offsetWidth;
      }
      return 0;
    };
    var getSwiperSize = function() {
      if (swiperRef.current) {
        if (isVertical) return swiperRef.current.offsetHeight;
        return swiperRef.current.offsetWidth;
      }
      return 0;
    };
    var bound2 = function(v, min, max) {
      if (min !== void 0) {
        v = Math.max(v, min);
      }
      if (max !== void 0) {
        v = Math.min(v, max);
      }
      return v;
    };
    var timeoutRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(false), 2), dragging = _useState[0], setDragging = _useState[1];
    var _useRefState = _sliced_to_array(useRefState(defaultValue), 2), current = _useRefState[0], setCurrent = _useRefState[1];
    var stageRef = React.useRef(null);
    var swiperRef = React.useRef(null);
    var _useSpring = _sliced_to_array(useSpring(function() {
      return {
        x: !isVertical ? current.current * 100 * -1 : 0,
        y: isVertical ? current.current * 100 * -1 : 0,
        s: 0,
        reset: function() {
        },
        config: {
          tension: 200,
          friction: 30
        }
      };
    }), 2), springs = _useSpring[0], api = _useSpring[1];
    React.useEffect(function() {
      var _obj;
      api.start((_obj = {}, _define_property(_obj, isVertical ? "y" : "x", boundIndex(current.current) * -1 * 100), _define_property(_obj, "immediate", true), _obj));
    }, [
      swiperRef.current
    ]);
    var swiperDirection = React.useRef(1);
    var _useList = _sliced_to_array(useList(effect2, count, current), 2), transforms = _useList[0], setTransforms = _useList[1];
    var runTimeSwiper = function() {
      var durationNumber = typeof duration === "string" ? parseInt(duration) : duration;
      var d2 = typeof autoPlay === "number" ? autoPlay : durationNumber;
      timeoutRef.current = window.setTimeout(function() {
        next();
        runTimeSwiper();
      }, d2);
    };
    React.useEffect(function() {
      if (!autoPlay || dragging) return;
      runTimeSwiper();
      return function() {
        if (timeoutRef.current) window.clearTimeout(timeoutRef.current);
      };
    }, [
      autoPlay,
      duration,
      dragging,
      count
    ]);
    var to2 = function(index2) {
      var immediate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _props_onChange;
      var targetIndex = bound2(index2, 0, count - 1);
      if (loop2) {
        var cycleIndex = index2 % count;
        targetIndex = cycleIndex < 0 ? cycleIndex + count : cycleIndex;
      }
      setCurrent(targetIndex);
      (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, targetIndex);
      if (effect2) {
        updateTransform(transforms, setTransforms, effect2, targetIndex);
      }
      var _obj;
      api.start((_obj = {}, // 
      _define_property(_obj, isVertical ? "y" : "x", (loop2 ? -index2 : boundIndex(targetIndex) * -1) * 100), _define_property(_obj, "s", 0), _define_property(_obj, "immediate", immediate), _obj));
    };
    var getSpringsAxis = function() {
      return springs[isVertical ? "y" : "x"];
    };
    var next = function() {
      to2(Math.round(-getSpringsAxis().get() / 100) + 1);
    };
    var prev = function() {
      to2(Math.round(-getSpringsAxis().get() / 100) - 1);
    };
    React.useImperativeHandle(ref, function() {
      return {
        to: to2,
        next,
        prev
      };
    });
    var bind = useDrag(function(state) {
      var axis = Number(isVertical);
      var slideSize = getSlideSize();
      var offset = state.offset[axis];
      setDragging(!!state.dragging);
      var distance = state.distance[axis];
      swiperDirection.current = state.direction[axis];
      if (state.last) {
        var swipeDirection = state.direction[axis];
        var velocity2 = state.velocity[axis];
        var minIndex = Math.floor(offset / slideSize);
        var maxIndex = minIndex + 1;
        var index2 = Math.round((offset + velocity2 * 2e3 * swipeDirection) / slideSize);
        to2(bound2(index2, minIndex, maxIndex));
      } else {
        var _obj;
        api.start((_obj = {}, _define_property(_obj, isVertical ? "y" : "x", -(offset / slideSize * 100)), _define_property(_obj, "s", distance / slideSize), _define_property(_obj, "immediate", true), _obj));
      }
    }, {
      enabled: touchable,
      transform: function(param) {
        var _param = _sliced_to_array(param, 2), x = _param[0], y = _param[1];
        return [
          -x,
          -y
        ];
      },
      from: function() {
        var slideSize = getSlideSize();
        var x = springs.x.get() / 100 * slideSize;
        var y = springs.y.get() / 100 * slideSize;
        return [
          -x,
          -y
        ];
      },
      bounds: function() {
        if (loop2) return {};
        var slideSize = getSlideSize();
        if (isVertical) {
          return {
            top: 0,
            bottom: (count - 1) * slideSize
          };
        }
        return {
          left: 0,
          right: (count - 1) * slideSize
        };
      },
      rubberband: true,
      triggerAllEvents: true,
      preventScroll: isVertical,
      axis: isVertical ? "y" : "x",
      pointer: {
        touch: true
      }
    });
    var renderIndicator = function() {
      if (/* @__PURE__ */ React.isValidElement(indicator)) return indicator;
      if (!indicator) return null;
      var _obj;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-indicator"), true), _define_property(_obj, "".concat(classPrefix2, "-indicator-vertical"), isVertical), _define_property(_obj, "".concat(classPrefix2, "-indicator-horizontal"), !isVertical), _obj))
      }, /* @__PURE__ */ React.createElement(Indicator, {
        current: getRefValue(current),
        total: count,
        direction
      }));
    };
    var renderEffect = function() {
      if (!effect2) return defaultEffect({
        children,
        getSpringsAxis,
        loop: loop2,
        count,
        isVertical
      });
      if (effect2 && effect2.name === "focus") {
        return focusEffect({
          children,
          springs,
          loop: loop2,
          count,
          isVertical,
          effect: effect2,
          current,
          swiperDirection,
          dragging,
          transforms
        });
      }
    };
    var renderSlides = function() {
      var _obj;
      return /* @__PURE__ */ React.createElement("div", {
        ref: stageRef,
        className: classNames("".concat(classPrefix2, "-inner"), (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-inner-vertical"), isVertical), _define_property(_obj, "".concat(classPrefix2, "-inner-horizontal"), !isVertical), _obj)),
        style: _object_spread({}, props.slideSize ? _define_property({}, isVertical ? "height" : "width", "".concat(props.slideSize, "px")) : {})
      }, renderEffect());
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix2, "".concat(classPrefix2, "-canmove-").concat(direction), className),
      style,
      ref: swiperRef
    }, bind()), renderSlides(), renderIndicator());
  });
  Swiper.displayName = "NutSwiper";
  var defaultProps$h = {
    onClick: function(e2) {
      return void 0;
    }
  };
  var SwiperItem = function(props) {
    var classPrefix2 = "nut-swiper-item";
    var _$_object_spread = _object_spread({}, defaultProps$h, props), className = _$_object_spread.className, style = _$_object_spread.style, children = _$_object_spread.children;
    var classes = classNames(classPrefix2, className);
    return /* @__PURE__ */ React.createElement("div", {
      className: classes,
      onClick: props.onClick,
      style
    }, children);
  };
  SwiperItem.displayName = "NutSwiperItem";
  var InnerSwiper = Swiper;
  InnerSwiper.Item = SwiperItem;
  var defaultProps$g = _object_spread_props(_object_spread({}, ComponentDefaults), {
    images: [],
    videos: [],
    visible: false,
    autoPlay: 3e3,
    defaultValue: 0,
    closeOnContentClick: false,
    pagination: true,
    indicator: false,
    indicatorColor: "#fff",
    closeIcon: false,
    closeIconPosition: "top-right",
    onChange: function() {
    },
    onClose: function() {
    }
  });
  var ImagePreview = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$g, props), value2 = _$_object_spread.value, className = _$_object_spread.className, style = _$_object_spread.style, images = _$_object_spread.images, videos = _$_object_spread.videos, visible = _$_object_spread.visible, defaultValue = _$_object_spread.defaultValue, indicatorColor = _$_object_spread.indicatorColor, pagination = _$_object_spread.pagination, indicator = _$_object_spread.indicator, autoPlay = _$_object_spread.autoPlay, closeOnContentClick = _$_object_spread.closeOnContentClick, closeIcon = _$_object_spread.closeIcon, closeIconPosition = _$_object_spread.closeIconPosition, onClose = _$_object_spread.onClose, onChange = _$_object_spread.onChange;
    var classPrefix2 = "nut-imagepreview";
    var ref = React.useRef(null);
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: defaultValue,
      onChange
    }), 2), innerNo = _usePropsValue[0], setInnerNo = _usePropsValue[1];
    var _useState = _sliced_to_array(React.useState(visible), 2), showPop = _useState[0], setShowPop = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(0), 2), active2 = _useState1[0], setActive = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(images.length + videos.length), 2), maxNo = _useState2[0], setMaxNo = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState({
      scale: 1,
      moveable: false,
      oriDistance: 0,
      originScale: 1
    }), 2), store = _useState3[0], setStore = _useState3[1];
    var lastTouchEndTime = React.useRef(0);
    var onTouchStart = function(event) {
      var touches = event.touches;
      var events = touches[0];
      var events2 = touches[1];
      var curTouchTime = Date.now();
      if (curTouchTime - lastTouchEndTime.current < 100) {
        var store1 = store;
        store1.scale = store1.scale === 1 ? 2 : 1;
        scaleNow();
      }
      var store11 = store;
      store11.moveable = true;
      if (events2) {
        store11.oriDistance = getDistance(events, events2);
      }
      store11.originScale = store11.scale;
    };
    var onTouchMove = function(event) {
      if (!store.moveable) return;
      var touches = event.touches;
      var events = touches[0];
      var events2 = touches[1];
      var store1 = store;
      if (events2) {
        var curDistance = getDistance(events, events2);
        var curScale = curDistance / store1.oriDistance;
        store1.scale = Math.min(store1.originScale * curScale, 3);
        scaleNow();
      }
    };
    var onTouchEnd = function() {
      lastTouchEndTime.current = Date.now();
      var store1 = store;
      store1.moveable = false;
      if (store1.scale < 1.1 && store1.scale > 1 || store1.scale < 1) {
        store1.scale = 1;
        scaleNow();
      }
    };
    React.useEffect(function() {
      init();
    }, []);
    var init = function() {
      document.addEventListener("touchmove", onTouchMove);
      document.addEventListener("touchend", onTouchEnd);
      document.addEventListener("touchcancel", onTouchEnd);
      return function() {
        document.removeEventListener("touchcancel", onTouchEnd);
        document.removeEventListener("touchmove", onTouchMove);
        document.removeEventListener("touchend", onTouchEnd);
      };
    };
    React.useEffect(function() {
      setShowPop(visible);
    }, [
      visible
    ]);
    React.useEffect(function() {
      setInnerNo(defaultValue || 1);
    }, [
      defaultValue
    ]);
    React.useEffect(function() {
      setActive(innerNo);
    }, [
      innerNo
    ]);
    React.useEffect(function() {
      setMaxNo(images.length + videos.length);
    }, [
      images,
      videos
    ]);
    var scaleNow = function() {
      if (ref.current) {
        ref.current.style.transform = "scale(".concat(store.scale, ")");
      }
    };
    var getDistance = function(first, second) {
      return Math.hypot(Math.abs(second.pageX - first.pageX), Math.abs(second.pageY - first.pageY));
    };
    var slideChangeEnd = function(page) {
      setActive(page + 1);
      onChange === null || onChange === void 0 ? void 0 : onChange(page + 1);
    };
    var onCloseInner = function(e2) {
      e2.stopPropagation();
      setShowPop(false);
      setActive(innerNo);
      scaleNow();
      onClose === null || onClose === void 0 ? void 0 : onClose();
      setStore(_object_spread_props(_object_spread({}, store), {
        scale: 1
      }));
    };
    var closeOnImg = function(e2) {
      e2.stopPropagation();
      if (closeOnContentClick) onCloseInner(e2);
    };
    var duration = typeof autoPlay === "string" ? parseInt(autoPlay) : autoPlay;
    return /* @__PURE__ */ React.createElement(Popup, {
      visible: showPop,
      className: "".concat(classPrefix2, "-pop"),
      onClick: onCloseInner
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className),
      style,
      ref,
      onTouchStart
    }, showPop && /* @__PURE__ */ React.createElement(InnerSwiper, {
      autoPlay: !!duration,
      duration,
      className: "".concat(classPrefix2, "-swiper"),
      loop: true,
      style: {
        "--nutui-indicator-color": indicatorColor
      },
      direction: "horizontal",
      onChange: function(page) {
        return slideChangeEnd(page);
      },
      defaultValue: innerNo > maxNo ? maxNo - 1 : innerNo - 1,
      indicator
    }, _to_consumable_array(videos.map(function(item) {
      return {
        type: "video",
        data: item
      };
    })).concat(_to_consumable_array(images.map(function(item) {
      return {
        type: "image",
        data: item
      };
    }))).sort(function(a, b) {
      var _a_data_index, _b_data_index;
      return ((_a_data_index = a.data.index) !== null && _a_data_index !== void 0 ? _a_data_index : 0) - ((_b_data_index = b.data.index) !== null && _b_data_index !== void 0 ? _b_data_index : 0);
    }).map(function(item, index2) {
      return /* @__PURE__ */ React.createElement(SwiperItem, {
        key: index2
      }, item.type === "video" ? /* @__PURE__ */ React.createElement(Video, {
        source: item.data.source,
        options: item.data.options,
        onClick: closeOnImg
      }) : /* @__PURE__ */ React.createElement(Image$1, {
        src: item.data.src,
        draggable: false,
        onClick: closeOnImg
      }));
    }))), pagination && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-index")
    }, active2, "/", maxNo), closeIcon !== false && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-close ").concat(closeIconPosition),
      onClick: onCloseInner
    }, closeIcon === true ? /* @__PURE__ */ React.createElement(n$6, null) : closeIcon));
  };
  ImagePreview.displayName = "NutImagePreview";
  var lottie$1 = { exports: {} };
  (function(module, exports) {
    typeof navigator !== "undefined" && function(global2, factory) {
      module.exports = factory();
    }(commonjsGlobal, function() {
      var svgNS = "http://www.w3.org/2000/svg";
      var locationHref = "";
      var _useWebWorker = false;
      var initialDefaultFrame = -999999;
      var setWebWorker = function setWebWorker2(flag) {
        _useWebWorker = !!flag;
      };
      var getWebWorker = function getWebWorker2() {
        return _useWebWorker;
      };
      var setLocationHref = function setLocationHref2(value2) {
        locationHref = value2;
      };
      var getLocationHref = function getLocationHref2() {
        return locationHref;
      };
      function createTag(type2) {
        return document.createElement(type2);
      }
      function extendPrototype(sources, destination) {
        var i2;
        var len = sources.length;
        var sourcePrototype;
        for (i2 = 0; i2 < len; i2 += 1) {
          sourcePrototype = sources[i2].prototype;
          for (var attr in sourcePrototype) {
            if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
          }
        }
      }
      function getDescriptor(object2, prop) {
        return Object.getOwnPropertyDescriptor(object2, prop);
      }
      function createProxyFunction(prototype) {
        function ProxyFunction() {
        }
        ProxyFunction.prototype = prototype;
        return ProxyFunction;
      }
      var audioControllerFactory = function() {
        function AudioController(audioFactory) {
          this.audios = [];
          this.audioFactory = audioFactory;
          this._volume = 1;
          this._isMuted = false;
        }
        AudioController.prototype = {
          addAudio: function addAudio(audio) {
            this.audios.push(audio);
          },
          pause: function pause() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].pause();
            }
          },
          resume: function resume() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].resume();
            }
          },
          setRate: function setRate(rateValue) {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].setRate(rateValue);
            }
          },
          createAudio: function createAudio(assetPath) {
            if (this.audioFactory) {
              return this.audioFactory(assetPath);
            }
            if (window.Howl) {
              return new window.Howl({
                src: [assetPath]
              });
            }
            return {
              isPlaying: false,
              play: function play() {
                this.isPlaying = true;
              },
              seek: function seek() {
                this.isPlaying = false;
              },
              playing: function playing() {
              },
              rate: function rate() {
              },
              setVolume: function setVolume() {
              }
            };
          },
          setAudioFactory: function setAudioFactory(audioFactory) {
            this.audioFactory = audioFactory;
          },
          setVolume: function setVolume(value2) {
            this._volume = value2;
            this._updateVolume();
          },
          mute: function mute() {
            this._isMuted = true;
            this._updateVolume();
          },
          unmute: function unmute() {
            this._isMuted = false;
            this._updateVolume();
          },
          getVolume: function getVolume() {
            return this._volume;
          },
          _updateVolume: function _updateVolume() {
            var i2;
            var len = this.audios.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.audios[i2].volume(this._volume * (this._isMuted ? 0 : 1));
            }
          }
        };
        return function() {
          return new AudioController();
        };
      }();
      var createTypedArray = function() {
        function createRegularArray(type2, len) {
          var i2 = 0;
          var arr = [];
          var value2;
          switch (type2) {
            case "int16":
            case "uint8c":
              value2 = 1;
              break;
            default:
              value2 = 1.1;
              break;
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            arr.push(value2);
          }
          return arr;
        }
        function createTypedArrayFactory(type2, len) {
          if (type2 === "float32") {
            return new Float32Array(len);
          }
          if (type2 === "int16") {
            return new Int16Array(len);
          }
          if (type2 === "uint8c") {
            return new Uint8ClampedArray(len);
          }
          return createRegularArray(type2, len);
        }
        if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
          return createTypedArrayFactory;
        }
        return createRegularArray;
      }();
      function createSizedArray(len) {
        return Array.apply(null, {
          length: len
        });
      }
      function _typeof$6(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$6 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$6 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$6(obj);
      }
      var subframeEnabled = true;
      var expressionsPlugin = null;
      var expressionsInterfaces = null;
      var idPrefix$1 = "";
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      var bmPow = Math.pow;
      var bmSqrt = Math.sqrt;
      var bmFloor = Math.floor;
      var bmMax = Math.max;
      var bmMin = Math.min;
      var BMMath = {};
      (function() {
        var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
        var i2;
        var len = propertyNames.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          BMMath[propertyNames[i2]] = Math[propertyNames[i2]];
        }
      })();
      BMMath.random = Math.random;
      BMMath.abs = function(val2) {
        var tOfVal = _typeof$6(val2);
        if (tOfVal === "object" && val2.length) {
          var absArr = createSizedArray(val2.length);
          var i2;
          var len = val2.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            absArr[i2] = Math.abs(val2[i2]);
          }
          return absArr;
        }
        return Math.abs(val2);
      };
      var defaultCurveSegments = 150;
      var degToRads = Math.PI / 180;
      var roundCorner = 0.5519;
      function styleDiv(element) {
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = "block";
        element.style.transformOrigin = "0 0";
        element.style.webkitTransformOrigin = "0 0";
        element.style.backfaceVisibility = "visible";
        element.style.webkitBackfaceVisibility = "visible";
        element.style.transformStyle = "preserve-3d";
        element.style.webkitTransformStyle = "preserve-3d";
        element.style.mozTransformStyle = "preserve-3d";
      }
      function BMEnterFrameEvent(type2, currentTime, totalTime, frameMultiplier) {
        this.type = type2;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteEvent(type2, frameMultiplier) {
        this.type = type2;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteLoopEvent(type2, totalLoops, currentLoop, frameMultiplier) {
        this.type = type2;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMSegmentStartEvent(type2, firstFrame, totalFrames) {
        this.type = type2;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
      }
      function BMDestroyEvent(type2, target) {
        this.type = type2;
        this.target = target;
      }
      function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = "renderFrameError";
        this.nativeError = nativeError;
        this.currentTime = currentTime;
      }
      function BMConfigErrorEvent(nativeError) {
        this.type = "configError";
        this.nativeError = nativeError;
      }
      var createElementID = /* @__PURE__ */ function() {
        var _count = 0;
        return function createID() {
          _count += 1;
          return idPrefix$1 + "__lottie_element_" + _count;
        };
      }();
      function HSVtoRGB(h, s2, v) {
        var r;
        var g;
        var b;
        var i2;
        var f;
        var p2;
        var q;
        var t;
        i2 = Math.floor(h * 6);
        f = h * 6 - i2;
        p2 = v * (1 - s2);
        q = v * (1 - f * s2);
        t = v * (1 - (1 - f) * s2);
        switch (i2 % 6) {
          case 0:
            r = v;
            g = t;
            b = p2;
            break;
          case 1:
            r = q;
            g = v;
            b = p2;
            break;
          case 2:
            r = p2;
            g = v;
            b = t;
            break;
          case 3:
            r = p2;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p2;
            b = v;
            break;
          case 5:
            r = v;
            g = p2;
            b = q;
            break;
        }
        return [r, g, b];
      }
      function RGBtoHSV(r, g, b) {
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var d2 = max - min;
        var h;
        var s2 = max === 0 ? 0 : d2 / max;
        var v = max / 255;
        switch (max) {
          case min:
            h = 0;
            break;
          case r:
            h = g - b + d2 * (g < b ? 6 : 0);
            h /= 6 * d2;
            break;
          case g:
            h = b - r + d2 * 2;
            h /= 6 * d2;
            break;
          case b:
            h = r - g + d2 * 4;
            h /= 6 * d2;
            break;
        }
        return [h, s2, v];
      }
      function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;
        if (hsv[1] > 1) {
          hsv[1] = 1;
        } else if (hsv[1] <= 0) {
          hsv[1] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;
        if (hsv[2] > 1) {
          hsv[2] = 1;
        } else if (hsv[2] < 0) {
          hsv[2] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;
        if (hsv[0] > 1) {
          hsv[0] -= 1;
        } else if (hsv[0] < 0) {
          hsv[0] += 1;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      var rgbToHex = function() {
        var colorMap = [];
        var i2;
        var hex;
        for (i2 = 0; i2 < 256; i2 += 1) {
          hex = i2.toString(16);
          colorMap[i2] = hex.length === 1 ? "0" + hex : hex;
        }
        return function(r, g, b) {
          if (r < 0) {
            r = 0;
          }
          if (g < 0) {
            g = 0;
          }
          if (b < 0) {
            b = 0;
          }
          return "#" + colorMap[r] + colorMap[g] + colorMap[b];
        };
      }();
      var setSubframeEnabled = function setSubframeEnabled2(flag) {
        subframeEnabled = !!flag;
      };
      var getSubframeEnabled = function getSubframeEnabled2() {
        return subframeEnabled;
      };
      var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
        expressionsPlugin = value2;
      };
      var getExpressionsPlugin = function getExpressionsPlugin2() {
        return expressionsPlugin;
      };
      var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
        expressionsInterfaces = value2;
      };
      var getExpressionInterfaces = function getExpressionInterfaces2() {
        return expressionsInterfaces;
      };
      var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
        defaultCurveSegments = value2;
      };
      var getDefaultCurveSegments = function getDefaultCurveSegments2() {
        return defaultCurveSegments;
      };
      var setIdPrefix = function setIdPrefix2(value2) {
        idPrefix$1 = value2;
      };
      function createNS(type2) {
        return document.createElementNS(svgNS, type2);
      }
      function _typeof$5(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$5 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$5 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$5(obj);
      }
      var dataManager = /* @__PURE__ */ function() {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
          onmessage: function onmessage() {
          },
          postMessage: function postMessage(path) {
            workerFn({
              data: path
            });
          }
        };
        var _workerSelf = {
          postMessage: function postMessage(data2) {
            workerProxy.onmessage({
              data: data2
            });
          }
        };
        function createWorker(fn) {
          if (window.Worker && window.Blob && getWebWorker()) {
            var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
              type: "text/javascript"
            });
            var url = URL.createObjectURL(blob);
            return new Worker(url);
          }
          workerFn = fn;
          return workerProxy;
        }
        function setupWorker() {
          if (!workerInstance) {
            workerInstance = createWorker(function workerStart(e2) {
              function dataFunctionManager() {
                function completeLayers(layers, comps) {
                  var layerData;
                  var i2;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    layerData = layers[i2];
                    if ("ks" in layerData && !layerData.completed) {
                      layerData.completed = true;
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            convertPathsToAbsoluteValues(maskProps[j].pt.k);
                          } else {
                            kLen = maskProps[j].pt.k.length;
                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                              }
                              if (maskProps[j].pt.k[k].e) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 0) {
                        layerData.layers = findCompLayers(layerData.refId, comps);
                        completeLayers(layerData.layers, comps);
                      } else if (layerData.ty === 4) {
                        completeShapes(layerData.shapes);
                      } else if (layerData.ty === 5) {
                        completeText(layerData);
                      }
                    }
                  }
                }
                function completeChars(chars, assets) {
                  if (chars) {
                    var i2 = 0;
                    var len = chars.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (chars[i2].t === 1) {
                        chars[i2].data.layers = findCompLayers(chars[i2].data.refId, assets);
                        completeLayers(chars[i2].data.layers, assets);
                      }
                    }
                  }
                }
                function findComp(id, comps) {
                  var i2 = 0;
                  var len = comps.length;
                  while (i2 < len) {
                    if (comps[i2].id === id) {
                      return comps[i2];
                    }
                    i2 += 1;
                  }
                  return null;
                }
                function findCompLayers(id, comps) {
                  var comp2 = findComp(id, comps);
                  if (comp2) {
                    if (!comp2.layers.__used) {
                      comp2.layers.__used = true;
                      return comp2.layers;
                    }
                    return JSON.parse(JSON.stringify(comp2.layers));
                  }
                  return null;
                }
                function completeShapes(arr) {
                  var i2;
                  var len = arr.length;
                  var j;
                  var jLen;
                  for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                    if (arr[i2].ty === "sh") {
                      if (arr[i2].ks.k.i) {
                        convertPathsToAbsoluteValues(arr[i2].ks.k);
                      } else {
                        jLen = arr[i2].ks.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i2].ks.k[j].s) {
                            convertPathsToAbsoluteValues(arr[i2].ks.k[j].s[0]);
                          }
                          if (arr[i2].ks.k[j].e) {
                            convertPathsToAbsoluteValues(arr[i2].ks.k[j].e[0]);
                          }
                        }
                      }
                    } else if (arr[i2].ty === "gr") {
                      completeShapes(arr[i2].it);
                    }
                  }
                }
                function convertPathsToAbsoluteValues(path) {
                  var i2;
                  var len = path.i.length;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    path.i[i2][0] += path.v[i2][0];
                    path.i[i2][1] += path.v[i2][1];
                    path.o[i2][0] += path.v[i2][0];
                    path.o[i2][1] += path.v[i2][1];
                  }
                }
                function checkVersion(minimum, animVersionString) {
                  var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                  if (minimum[0] > animVersion[0]) {
                    return true;
                  }
                  if (animVersion[0] > minimum[0]) {
                    return false;
                  }
                  if (minimum[1] > animVersion[1]) {
                    return true;
                  }
                  if (animVersion[1] > minimum[1]) {
                    return false;
                  }
                  if (minimum[2] > animVersion[2]) {
                    return true;
                  }
                  if (animVersion[2] > minimum[2]) {
                    return false;
                  }
                  return null;
                }
                var checkText = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 14];
                  function updateTextLayer(textLayer) {
                    var documentData = textLayer.t.d;
                    textLayer.t.d = {
                      k: [{
                        s: documentData,
                        t: 0
                      }]
                    };
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 5) {
                        updateTextLayer(layers[i2]);
                      }
                    }
                  }
                  return function(animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);
                      if (animationData.assets) {
                        var i2;
                        var len = animationData.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData.assets[i2].layers) {
                            iterateLayers(animationData.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkChars = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 7, 99];
                  return function(animationData) {
                    if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                      var i2;
                      var len = animationData.chars.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        var charData = animationData.chars[i2];
                        if (charData.data && charData.data.shapes) {
                          completeShapes(charData.data.shapes);
                          charData.data.ip = 0;
                          charData.data.op = 99999;
                          charData.data.st = 0;
                          charData.data.sr = 1;
                          charData.data.ks = {
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            }
                          };
                          if (!animationData.chars[i2].t) {
                            charData.data.shapes.push({
                              ty: "no"
                            });
                            charData.data.shapes[0].it.push({
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              },
                              sk: {
                                k: 0,
                                a: 0
                              },
                              sa: {
                                k: 0,
                                a: 0
                              },
                              ty: "tr"
                            });
                          }
                        }
                      }
                    }
                  };
                }();
                var checkPathProperties = /* @__PURE__ */ function() {
                  var minimumVersion = [5, 7, 15];
                  function updateTextLayer(textLayer) {
                    var pathData = textLayer.t.p;
                    if (typeof pathData.a === "number") {
                      pathData.a = {
                        a: 0,
                        k: pathData.a
                      };
                    }
                    if (typeof pathData.p === "number") {
                      pathData.p = {
                        a: 0,
                        k: pathData.p
                      };
                    }
                    if (typeof pathData.r === "number") {
                      pathData.r = {
                        a: 0,
                        k: pathData.r
                      };
                    }
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 5) {
                        updateTextLayer(layers[i2]);
                      }
                    }
                  }
                  return function(animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);
                      if (animationData.assets) {
                        var i2;
                        var len = animationData.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData.assets[i2].layers) {
                            iterateLayers(animationData.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkColors = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 1, 9];
                  function iterateShapes(shapes) {
                    var i2;
                    var len = shapes.length;
                    var j;
                    var jLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (shapes[i2].ty === "gr") {
                        iterateShapes(shapes[i2].it);
                      } else if (shapes[i2].ty === "fl" || shapes[i2].ty === "st") {
                        if (shapes[i2].c.k && shapes[i2].c.k[0].i) {
                          jLen = shapes[i2].c.k.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (shapes[i2].c.k[j].s) {
                              shapes[i2].c.k[j].s[0] /= 255;
                              shapes[i2].c.k[j].s[1] /= 255;
                              shapes[i2].c.k[j].s[2] /= 255;
                              shapes[i2].c.k[j].s[3] /= 255;
                            }
                            if (shapes[i2].c.k[j].e) {
                              shapes[i2].c.k[j].e[0] /= 255;
                              shapes[i2].c.k[j].e[1] /= 255;
                              shapes[i2].c.k[j].e[2] /= 255;
                              shapes[i2].c.k[j].e[3] /= 255;
                            }
                          }
                        } else {
                          shapes[i2].c.k[0] /= 255;
                          shapes[i2].c.k[1] /= 255;
                          shapes[i2].c.k[2] /= 255;
                          shapes[i2].c.k[3] /= 255;
                        }
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var i2;
                    var len = layers.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      if (layers[i2].ty === 4) {
                        iterateShapes(layers[i2].shapes);
                      }
                    }
                  }
                  return function(animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);
                      if (animationData.assets) {
                        var i2;
                        var len = animationData.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData.assets[i2].layers) {
                            iterateLayers(animationData.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkShapes = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 18];
                  function completeClosingShapes(arr) {
                    var i2;
                    var len = arr.length;
                    var j;
                    var jLen;
                    for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                      if (arr[i2].ty === "sh") {
                        if (arr[i2].ks.k.i) {
                          arr[i2].ks.k.c = arr[i2].closed;
                        } else {
                          jLen = arr[i2].ks.k.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (arr[i2].ks.k[j].s) {
                              arr[i2].ks.k[j].s[0].c = arr[i2].closed;
                            }
                            if (arr[i2].ks.k[j].e) {
                              arr[i2].ks.k[j].e[0].c = arr[i2].closed;
                            }
                          }
                        }
                      } else if (arr[i2].ty === "gr") {
                        completeClosingShapes(arr[i2].it);
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var layerData;
                    var i2;
                    var len = layers.length;
                    var j;
                    var jLen;
                    var k;
                    var kLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      layerData = layers[i2];
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            maskProps[j].pt.k.c = maskProps[j].cl;
                          } else {
                            kLen = maskProps[j].pt.k.length;
                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                              }
                              if (maskProps[j].pt.k[k].e) {
                                maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 4) {
                        completeClosingShapes(layerData.shapes);
                      }
                    }
                  }
                  return function(animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);
                      if (animationData.assets) {
                        var i2;
                        var len = animationData.assets.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData.assets[i2].layers) {
                            iterateLayers(animationData.assets[i2].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                function completeData(animationData) {
                  if (animationData.__complete) {
                    return;
                  }
                  checkColors(animationData);
                  checkText(animationData);
                  checkChars(animationData);
                  checkPathProperties(animationData);
                  checkShapes(animationData);
                  completeLayers(animationData.layers, animationData.assets);
                  completeChars(animationData.chars, animationData.assets);
                  animationData.__complete = true;
                }
                function completeText(data2) {
                  if (data2.t.a.length === 0 && !("m" in data2.t.p)) ;
                }
                var moduleOb = {};
                moduleOb.completeData = completeData;
                moduleOb.checkColors = checkColors;
                moduleOb.checkChars = checkChars;
                moduleOb.checkPathProperties = checkPathProperties;
                moduleOb.checkShapes = checkShapes;
                moduleOb.completeLayers = completeLayers;
                return moduleOb;
              }
              if (!_workerSelf.dataManager) {
                _workerSelf.dataManager = dataFunctionManager();
              }
              if (!_workerSelf.assetLoader) {
                _workerSelf.assetLoader = /* @__PURE__ */ function() {
                  function formatResponse(xhr) {
                    var contentTypeHeader = xhr.getResponseHeader("content-type");
                    if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                      return xhr.response;
                    }
                    if (xhr.response && _typeof$5(xhr.response) === "object") {
                      return xhr.response;
                    }
                    if (xhr.response && typeof xhr.response === "string") {
                      return JSON.parse(xhr.response);
                    }
                    if (xhr.responseText) {
                      return JSON.parse(xhr.responseText);
                    }
                    return null;
                  }
                  function loadAsset(path, fullPath, callback, errorCallback) {
                    var response;
                    var xhr = new XMLHttpRequest();
                    try {
                      xhr.responseType = "json";
                    } catch (err) {
                    }
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                          response = formatResponse(xhr);
                          callback(response);
                        } else {
                          try {
                            response = formatResponse(xhr);
                            callback(response);
                          } catch (err) {
                            if (errorCallback) {
                              errorCallback(err);
                            }
                          }
                        }
                      }
                    };
                    try {
                      xhr.open(["G", "E", "T"].join(""), path, true);
                    } catch (error) {
                      xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                    }
                    xhr.send();
                  }
                  return {
                    load: loadAsset
                  };
                }();
              }
              if (e2.data.type === "loadAnimation") {
                _workerSelf.assetLoader.load(e2.data.path, e2.data.fullPath, function(data2) {
                  _workerSelf.dataManager.completeData(data2);
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    status: "error"
                  });
                });
              } else if (e2.data.type === "complete") {
                var animation = e2.data.animation;
                _workerSelf.dataManager.completeData(animation);
                _workerSelf.postMessage({
                  id: e2.data.id,
                  payload: animation,
                  status: "success"
                });
              } else if (e2.data.type === "loadData") {
                _workerSelf.assetLoader.load(e2.data.path, e2.data.fullPath, function(data2) {
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    status: "error"
                  });
                });
              }
            });
            workerInstance.onmessage = function(event) {
              var data2 = event.data;
              var id = data2.id;
              var process2 = processes[id];
              processes[id] = null;
              if (data2.status === "success") {
                process2.onComplete(data2.payload);
              } else if (process2.onError) {
                process2.onError();
              }
            };
          }
        }
        function createProcess(onComplete, onError) {
          _counterId += 1;
          var id = "processId_" + _counterId;
          processes[id] = {
            onComplete,
            onError
          };
          return id;
        }
        function loadAnimation2(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadAnimation",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function loadData(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadData",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function completeAnimation(anim, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "complete",
            animation: anim,
            id: processId
          });
        }
        return {
          loadAnimation: loadAnimation2,
          loadData,
          completeAnimation
        };
      }();
      var ImagePreloader = function() {
        var proxyImage = function() {
          var canvas = createTag("canvas");
          canvas.width = 1;
          canvas.height = 1;
          var ctx2 = canvas.getContext("2d");
          ctx2.fillStyle = "rgba(0,0,0,0)";
          ctx2.fillRect(0, 0, 1, 1);
          return canvas;
        }();
        function imageLoaded() {
          this.loadedAssets += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function footageLoaded() {
          this.loadedFootagesCount += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function getAssetsPath(assetData, assetsPath, originalPath) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = assetsPath + imagePath;
          } else {
            path = originalPath;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        }
        function testImageLoaded(img) {
          var _count = 0;
          var intervalId = setInterval((function() {
            var box = img.getBBox();
            if (box.width || _count > 500) {
              this._imageLoaded();
              clearInterval(intervalId);
            }
            _count += 1;
          }).bind(this), 50);
        }
        function createImageData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createNS("image");
          if (isSafari) {
            this.testImageLoaded(img);
          } else {
            img.addEventListener("load", this._imageLoaded, false);
          }
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
          if (this._elementHelper.append) {
            this._elementHelper.append(img);
          } else {
            this._elementHelper.appendChild(img);
          }
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createImgData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createTag("img");
          img.crossOrigin = "anonymous";
          img.addEventListener("load", this._imageLoaded, false);
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.src = path;
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createFootageData(data2) {
          var ob2 = {
            assetData: data2
          };
          var path = getAssetsPath(data2, this.assetsPath, this.path);
          dataManager.loadData(path, (function(footageData) {
            ob2.img = footageData;
            this._footageLoaded();
          }).bind(this), (function() {
            ob2.img = {};
            this._footageLoaded();
          }).bind(this));
          return ob2;
        }
        function loadAssets(assets, cb) {
          this.imagesLoadedCb = cb;
          var i2;
          var len = assets.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!assets[i2].layers) {
              if (!assets[i2].t || assets[i2].t === "seq") {
                this.totalImages += 1;
                this.images.push(this._createImageData(assets[i2]));
              } else if (assets[i2].t === 3) {
                this.totalFootages += 1;
                this.images.push(this.createFootageData(assets[i2]));
              }
            }
          }
        }
        function setPath(path) {
          this.path = path || "";
        }
        function setAssetsPath(path) {
          this.assetsPath = path || "";
        }
        function getAsset(assetData) {
          var i2 = 0;
          var len = this.images.length;
          while (i2 < len) {
            if (this.images[i2].assetData === assetData) {
              return this.images[i2].img;
            }
            i2 += 1;
          }
          return null;
        }
        function destroy() {
          this.imagesLoadedCb = null;
          this.images.length = 0;
        }
        function loadedImages() {
          return this.totalImages === this.loadedAssets;
        }
        function loadedFootages() {
          return this.totalFootages === this.loadedFootagesCount;
        }
        function setCacheType(type2, elementHelper) {
          if (type2 === "svg") {
            this._elementHelper = elementHelper;
            this._createImageData = this.createImageData.bind(this);
          } else {
            this._createImageData = this.createImgData.bind(this);
          }
        }
        function ImagePreloaderFactory() {
          this._imageLoaded = imageLoaded.bind(this);
          this._footageLoaded = footageLoaded.bind(this);
          this.testImageLoaded = testImageLoaded.bind(this);
          this.createFootageData = createFootageData.bind(this);
          this.assetsPath = "";
          this.path = "";
          this.totalImages = 0;
          this.totalFootages = 0;
          this.loadedAssets = 0;
          this.loadedFootagesCount = 0;
          this.imagesLoadedCb = null;
          this.images = [];
        }
        ImagePreloaderFactory.prototype = {
          loadAssets,
          setAssetsPath,
          setPath,
          loadedImages,
          loadedFootages,
          destroy,
          getAsset,
          createImgData,
          createImageData,
          imageLoaded,
          footageLoaded,
          setCacheType
        };
        return ImagePreloaderFactory;
      }();
      function BaseEvent() {
      }
      BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
          if (this._cbs[eventName]) {
            var callbacks = this._cbs[eventName];
            for (var i2 = 0; i2 < callbacks.length; i2 += 1) {
              callbacks[i2](args);
            }
          }
        },
        addEventListener: function addEventListener(eventName, callback) {
          if (!this._cbs[eventName]) {
            this._cbs[eventName] = [];
          }
          this._cbs[eventName].push(callback);
          return (function() {
            this.removeEventListener(eventName, callback);
          }).bind(this);
        },
        removeEventListener: function removeEventListener(eventName, callback) {
          if (!callback) {
            this._cbs[eventName] = null;
          } else if (this._cbs[eventName]) {
            var i2 = 0;
            var len = this._cbs[eventName].length;
            while (i2 < len) {
              if (this._cbs[eventName][i2] === callback) {
                this._cbs[eventName].splice(i2, 1);
                i2 -= 1;
                len -= 1;
              }
              i2 += 1;
            }
            if (!this._cbs[eventName].length) {
              this._cbs[eventName] = null;
            }
          }
        }
      };
      var markerParser = /* @__PURE__ */ function() {
        function parsePayloadLines(payload) {
          var lines = payload.split("\r\n");
          var keys = {};
          var line;
          var keysCount = 0;
          for (var i2 = 0; i2 < lines.length; i2 += 1) {
            line = lines[i2].split(":");
            if (line.length === 2) {
              keys[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }
          if (keysCount === 0) {
            throw new Error();
          }
          return keys;
        }
        return function(_markers) {
          var markers = [];
          for (var i2 = 0; i2 < _markers.length; i2 += 1) {
            var _marker = _markers[i2];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr
            };
            try {
              markerData.payload = JSON.parse(_markers[i2].cm);
            } catch (_) {
              try {
                markerData.payload = parsePayloadLines(_markers[i2].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i2].cm
                };
              }
            }
            markers.push(markerData);
          }
          return markers;
        };
      }();
      var ProjectInterface = /* @__PURE__ */ function() {
        function registerComposition(comp2) {
          this.compositions.push(comp2);
        }
        return function() {
          function _thisProjectFunction(name2) {
            var i2 = 0;
            var len = this.compositions.length;
            while (i2 < len) {
              if (this.compositions[i2].data && this.compositions[i2].data.nm === name2) {
                if (this.compositions[i2].prepareFrame && this.compositions[i2].data.xt) {
                  this.compositions[i2].prepareFrame(this.currentFrame);
                }
                return this.compositions[i2].compInterface;
              }
              i2 += 1;
            }
            return null;
          }
          _thisProjectFunction.compositions = [];
          _thisProjectFunction.currentFrame = 0;
          _thisProjectFunction.registerComposition = registerComposition;
          return _thisProjectFunction;
        };
      }();
      var renderers = {};
      var registerRenderer = function registerRenderer2(key2, value2) {
        renderers[key2] = value2;
      };
      function getRenderer(key2) {
        return renderers[key2];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) {
          return "canvas";
        }
        for (var key2 in renderers) {
          if (renderers[key2]) {
            return key2;
          }
        }
        return "";
      }
      function _typeof$4(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$4 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$4 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$4(obj);
      }
      var AnimationItem = function AnimationItem2() {
        this._cbs = [];
        this.name = "";
        this.path = "";
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = "";
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
        this.expressionsPlugin = getExpressionsPlugin();
      };
      extendPrototype([BaseEvent], AnimationItem);
      AnimationItem.prototype.setParams = function(params) {
        if (params.wrapper || params.container) {
          this.wrapper = params.wrapper || params.container;
        }
        var animType = "svg";
        if (params.animType) {
          animType = params.animType;
        } else if (params.renderer) {
          animType = params.renderer;
        }
        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
          this.loop = true;
        } else if (params.loop === false) {
          this.loop = false;
        } else {
          this.loop = parseInt(params.loop, 10);
        }
        this.autoplay = "autoplay" in params ? params.autoplay : true;
        this.name = params.name ? params.name : "";
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.audioFactory) {
          this.audioController.setAudioFactory(params.audioFactory);
        }
        if (params.animationData) {
          this.setupAnimation(params.animationData);
        } else if (params.path) {
          if (params.path.lastIndexOf("\\") !== -1) {
            this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
          } else {
            this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
          }
          this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
          dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
      };
      AnimationItem.prototype.onSetupError = function() {
        this.trigger("data_failed");
      };
      AnimationItem.prototype.setupAnimation = function(data2) {
        dataManager.completeAnimation(data2, this.configAnimation);
      };
      AnimationItem.prototype.setData = function(wrapper, animationData) {
        if (animationData) {
          if (_typeof$4(animationData) !== "object") {
            animationData = JSON.parse(animationData);
          }
        }
        var params = {
          wrapper,
          animationData
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
        params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
        var loop2 = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
        if (loop2 === "false") {
          params.loop = false;
        } else if (loop2 === "true") {
          params.loop = true;
        } else if (loop2 !== "") {
          params.loop = parseInt(loop2, 10);
        }
        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
        params.autoplay = autoplay !== "false";
        params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
        var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
        if (prerender === "false") {
          params.prerender = false;
        }
        if (!params.path) {
          this.trigger("destroy");
        } else {
          this.setParams(params);
        }
      };
      AnimationItem.prototype.includeLayers = function(data2) {
        if (data2.op > this.animationData.op) {
          this.animationData.op = data2.op;
          this.totalFrames = Math.floor(data2.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i2;
        var len = layers.length;
        var newLayers = data2.layers;
        var j;
        var jLen = newLayers.length;
        for (j = 0; j < jLen; j += 1) {
          i2 = 0;
          while (i2 < len) {
            if (layers[i2].id === newLayers[j].id) {
              layers[i2] = newLayers[j];
              break;
            }
            i2 += 1;
          }
        }
        if (data2.chars || data2.fonts) {
          this.renderer.globalData.fontManager.addChars(data2.chars);
          this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
        }
        if (data2.assets) {
          len = data2.assets.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.animationData.assets.push(data2.assets[i2]);
          }
        }
        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
      };
      AnimationItem.prototype.onSegmentComplete = function(data2) {
        this.animationData = data2;
        var expressionsPlugin2 = getExpressionsPlugin();
        if (expressionsPlugin2) {
          expressionsPlugin2.initExpressions(this);
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if (!segments || segments.length === 0 || !this.autoloadSegments) {
          this.trigger("data_ready");
          this.timeCompleted = this.totalFrames;
          return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {
          this.trigger("data_failed");
        }).bind(this));
      };
      AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if (!segments) {
          this.timeCompleted = this.totalFrames;
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.imagesLoaded = function() {
        this.trigger("loaded_images");
        this.checkLoaded();
      };
      AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
      };
      AnimationItem.prototype.configAnimation = function(animData) {
        if (!this.renderer) {
          return;
        }
        try {
          this.animationData = animData;
          if (this.initialSegment) {
            this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
            this.firstFrame = Math.round(this.initialSegment[0]);
          } else {
            this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
            this.firstFrame = Math.round(this.animationData.ip);
          }
          this.renderer.configAnimation(animData);
          if (!animData.assets) {
            animData.assets = [];
          }
          this.assets = this.animationData.assets;
          this.frameRate = this.animationData.fr;
          this.frameMult = this.animationData.fr / 1e3;
          this.renderer.searchExtraCompositions(animData.assets);
          this.markers = markerParser(animData.markers || []);
          this.trigger("config_ready");
          this.preloadImages();
          this.loadSegments();
          this.updaFrameModifier();
          this.waitForFontsLoaded();
          if (this.isPaused) {
            this.audioController.pause();
          }
        } catch (error) {
          this.triggerConfigError(error);
        }
      };
      AnimationItem.prototype.waitForFontsLoaded = function() {
        if (!this.renderer) {
          return;
        }
        if (this.renderer.globalData.fontManager.isLoaded) {
          this.checkLoaded();
        } else {
          setTimeout(this.waitForFontsLoaded.bind(this), 20);
        }
      };
      AnimationItem.prototype.checkLoaded = function() {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
          this.isLoaded = true;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.renderer.initItems();
          setTimeout((function() {
            this.trigger("DOMLoaded");
          }).bind(this), 0);
          this.gotoFrame();
          if (this.autoplay) {
            this.play();
          }
        }
      };
      AnimationItem.prototype.resize = function(width2, height2) {
        var _width = typeof width2 === "number" ? width2 : void 0;
        var _height = typeof height2 === "number" ? height2 : void 0;
        this.renderer.updateContainerSize(_width, _height);
      };
      AnimationItem.prototype.setSubframe = function(flag) {
        this.isSubframeEnabled = !!flag;
      };
      AnimationItem.prototype.gotoFrame = function() {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
          this.currentFrame = this.timeCompleted;
        }
        this.trigger("enterFrame");
        this.renderFrame();
        this.trigger("drawnFrame");
      };
      AnimationItem.prototype.renderFrame = function() {
        if (this.isLoaded === false || !this.renderer) {
          return;
        }
        try {
          if (this.expressionsPlugin) {
            this.expressionsPlugin.resetFrame();
          }
          this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
          this.triggerRenderFrameError(error);
        }
      };
      AnimationItem.prototype.play = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.isPaused = false;
          this.trigger("_play");
          this.audioController.resume();
          if (this._idle) {
            this._idle = false;
            this.trigger("_active");
          }
        }
      };
      AnimationItem.prototype.pause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === false) {
          this.isPaused = true;
          this.trigger("_pause");
          this._idle = true;
          this.trigger("_idle");
          this.audioController.pause();
        }
      };
      AnimationItem.prototype.togglePause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.play();
        } else {
          this.pause();
        }
      };
      AnimationItem.prototype.stop = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
      };
      AnimationItem.prototype.getMarkerData = function(markerName) {
        var marker;
        for (var i2 = 0; i2 < this.markers.length; i2 += 1) {
          marker = this.markers[i2];
          if (marker.payload && marker.payload.name === markerName) {
            return marker;
          }
        }
        return null;
      };
      AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            this.goToAndStop(marker.time, true);
          }
        } else if (isFrame) {
          this.setCurrentRawFrameValue(value2);
        } else {
          this.setCurrentRawFrameValue(value2 * this.frameModifier);
        }
        this.pause();
      };
      AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value2);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value2);
          if (marker) {
            if (!marker.duration) {
              this.goToAndStop(marker.time, true);
            } else {
              this.playSegments([marker.time, marker.time + marker.duration], true);
            }
          }
        } else {
          this.goToAndStop(numValue, isFrame, name2);
        }
        this.play();
      };
      AnimationItem.prototype.advanceTime = function(value2) {
        if (this.isPaused === true || this.isLoaded === false) {
          return;
        }
        var nextValue = this.currentRawFrame + value2 * this.frameModifier;
        var _isComplete = false;
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
          if (!this.loop || this.playCount === this.loop) {
            if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
              _isComplete = true;
              nextValue = this.totalFrames - 1;
            }
          } else if (nextValue >= this.totalFrames) {
            this.playCount += 1;
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              this.setCurrentRawFrameValue(nextValue % this.totalFrames);
              this._completedLoop = true;
              this.trigger("loopComplete");
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
        } else if (nextValue < 0) {
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
              this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
              if (!this._completedLoop) {
                this._completedLoop = true;
              } else {
                this.trigger("loopComplete");
              }
            } else {
              _isComplete = true;
              nextValue = 0;
            }
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
        if (_isComplete) {
          this.setCurrentRawFrameValue(nextValue);
          this.pause();
          this.trigger("complete");
        }
      };
      AnimationItem.prototype.adjustSegment = function(arr, offset) {
        this.playCount = 0;
        if (arr[1] < arr[0]) {
          if (this.frameModifier > 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(-1);
            }
          }
          this.totalFrames = arr[0] - arr[1];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[1];
          this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
        } else if (arr[1] > arr[0]) {
          if (this.frameModifier < 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(1);
            }
          }
          this.totalFrames = arr[1] - arr[0];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[0];
          this.setCurrentRawFrameValue(1e-3 + offset);
        }
        this.trigger("segmentStart");
      };
      AnimationItem.prototype.setSegment = function(init, end) {
        var pendingFrame = -1;
        if (this.isPaused) {
          if (this.currentRawFrame + this.firstFrame < init) {
            pendingFrame = init;
          } else if (this.currentRawFrame + this.firstFrame > end) {
            pendingFrame = end - init;
          }
        }
        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;
        if (pendingFrame !== -1) {
          this.goToAndStop(pendingFrame, true);
        }
      };
      AnimationItem.prototype.playSegments = function(arr, forceFlag) {
        if (forceFlag) {
          this.segments.length = 0;
        }
        if (_typeof$4(arr[0]) === "object") {
          var i2;
          var len = arr.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.segments.push(arr[i2]);
          }
        } else {
          this.segments.push(arr);
        }
        if (this.segments.length && forceFlag) {
          this.adjustSegment(this.segments.shift(), 0);
        }
        if (this.isPaused) {
          this.play();
        }
      };
      AnimationItem.prototype.resetSegments = function(forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip, this.animationData.op]);
        if (forceFlag) {
          this.checkSegments(0);
        }
      };
      AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
          this.adjustSegment(this.segments.shift(), offset);
          return true;
        }
        return false;
      };
      AnimationItem.prototype.destroy = function(name2) {
        if (name2 && this.name !== name2 || !this.renderer) {
          return;
        }
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger("destroy");
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.expressionsPlugin = null;
        this.imagePreloader = null;
        this.projectInterface = null;
      };
      AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
        this.currentRawFrame = value2;
        this.gotoFrame();
      };
      AnimationItem.prototype.setSpeed = function(val2) {
        this.playSpeed = val2;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setDirection = function(val2) {
        this.playDirection = val2 < 0 ? -1 : 1;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setLoop = function(isLooping) {
        this.loop = isLooping;
      };
      AnimationItem.prototype.setVolume = function(val2, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.setVolume(val2);
      };
      AnimationItem.prototype.getVolume = function() {
        return this.audioController.getVolume();
      };
      AnimationItem.prototype.mute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.mute();
      };
      AnimationItem.prototype.unmute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.unmute();
      };
      AnimationItem.prototype.updaFrameModifier = function() {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
      };
      AnimationItem.prototype.getPath = function() {
        return this.path;
      };
      AnimationItem.prototype.getAssetsPath = function(assetData) {
        var path = "";
        if (assetData.e) {
          path = assetData.p;
        } else if (this.assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf("images/") !== -1) {
            imagePath = imagePath.split("/")[1];
          }
          path = this.assetsPath + imagePath;
        } else {
          path = this.path;
          path += assetData.u ? assetData.u : "";
          path += assetData.p;
        }
        return path;
      };
      AnimationItem.prototype.getAssetData = function(id) {
        var i2 = 0;
        var len = this.assets.length;
        while (i2 < len) {
          if (id === this.assets[i2].id) {
            return this.assets[i2];
          }
          i2 += 1;
        }
        return null;
      };
      AnimationItem.prototype.hide = function() {
        this.renderer.hide();
      };
      AnimationItem.prototype.show = function() {
        this.renderer.show();
      };
      AnimationItem.prototype.getDuration = function(isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
      };
      AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
        try {
          var element = this.renderer.getElementByPath(path);
          element.updateDocumentData(documentData, index2);
        } catch (error) {
        }
      };
      AnimationItem.prototype.trigger = function(name2) {
        if (this._cbs && this._cbs[name2]) {
          switch (name2) {
            case "enterFrame":
              this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
              break;
            case "drawnFrame":
              this.drawnFrameEvent.currentTime = this.currentFrame;
              this.drawnFrameEvent.totalTime = this.totalFrames;
              this.drawnFrameEvent.direction = this.frameModifier;
              this.triggerEvent(name2, this.drawnFrameEvent);
              break;
            case "loopComplete":
              this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
              break;
            case "complete":
              this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
              break;
            case "segmentStart":
              this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
              break;
            case "destroy":
              this.triggerEvent(name2, new BMDestroyEvent(name2, this));
              break;
            default:
              this.triggerEvent(name2);
          }
        }
        if (name2 === "enterFrame" && this.onEnterFrame) {
          this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
        }
        if (name2 === "loopComplete" && this.onLoopComplete) {
          this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
        }
        if (name2 === "complete" && this.onComplete) {
          this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
        }
        if (name2 === "segmentStart" && this.onSegmentStart) {
          this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
        }
        if (name2 === "destroy" && this.onDestroy) {
          this.onDestroy.call(this, new BMDestroyEvent(name2, this));
        }
      };
      AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      AnimationItem.prototype.triggerConfigError = function(nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      var animationManager = function() {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;
        function removeElement(ev) {
          var i2 = 0;
          var animItem = ev.target;
          while (i2 < len) {
            if (registeredAnimations[i2].animation === animItem) {
              registeredAnimations.splice(i2, 1);
              i2 -= 1;
              len -= 1;
              if (!animItem.isPaused) {
                subtractPlayingCount();
              }
            }
            i2 += 1;
          }
        }
        function registerAnimation(element, animationData) {
          if (!element) {
            return null;
          }
          var i2 = 0;
          while (i2 < len) {
            if (registeredAnimations[i2].elem === element && registeredAnimations[i2].elem !== null) {
              return registeredAnimations[i2].animation;
            }
            i2 += 1;
          }
          var animItem = new AnimationItem();
          setupAnimation(animItem, element);
          animItem.setData(element, animationData);
          return animItem;
        }
        function getRegisteredAnimations() {
          var i2;
          var lenAnims = registeredAnimations.length;
          var animations = [];
          for (i2 = 0; i2 < lenAnims; i2 += 1) {
            animations.push(registeredAnimations[i2].animation);
          }
          return animations;
        }
        function addPlayingCount() {
          playingAnimationsNum += 1;
          activate();
        }
        function subtractPlayingCount() {
          playingAnimationsNum -= 1;
        }
        function setupAnimation(animItem, element) {
          animItem.addEventListener("destroy", removeElement);
          animItem.addEventListener("_active", addPlayingCount);
          animItem.addEventListener("_idle", subtractPlayingCount);
          registeredAnimations.push({
            elem: element,
            animation: animItem
          });
          len += 1;
        }
        function loadAnimation2(params) {
          var animItem = new AnimationItem();
          setupAnimation(animItem, null);
          animItem.setParams(params);
          return animItem;
        }
        function setSpeed(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setSpeed(val2, animation);
          }
        }
        function setDirection(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setDirection(val2, animation);
          }
        }
        function play(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.play(animation);
          }
        }
        function resume(nowTime) {
          var elapsedTime = nowTime - initTime;
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.advanceTime(elapsedTime);
          }
          initTime = nowTime;
          if (playingAnimationsNum && !_isFrozen) {
            window.requestAnimationFrame(resume);
          } else {
            _stopped = true;
          }
        }
        function first(nowTime) {
          initTime = nowTime;
          window.requestAnimationFrame(resume);
        }
        function pause(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.pause(animation);
          }
        }
        function goToAndStop(value2, isFrame, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.goToAndStop(value2, isFrame, animation);
          }
        }
        function stop2(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.stop(animation);
          }
        }
        function togglePause(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.togglePause(animation);
          }
        }
        function destroy(animation) {
          var i2;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            registeredAnimations[i2].animation.destroy(animation);
          }
        }
        function searchAnimations2(animationData, standalone, renderer) {
          var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
          var i2;
          var lenAnims = animElements.length;
          for (i2 = 0; i2 < lenAnims; i2 += 1) {
            if (renderer) {
              animElements[i2].setAttribute("data-bm-type", renderer);
            }
            registerAnimation(animElements[i2], animationData);
          }
          if (standalone && lenAnims === 0) {
            if (!renderer) {
              renderer = "svg";
            }
            var body = document.getElementsByTagName("body")[0];
            body.innerText = "";
            var div2 = createTag("div");
            div2.style.width = "100%";
            div2.style.height = "100%";
            div2.setAttribute("data-bm-type", renderer);
            body.appendChild(div2);
            registerAnimation(div2, animationData);
          }
        }
        function resize() {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.resize();
          }
        }
        function activate() {
          if (!_isFrozen && playingAnimationsNum) {
            if (_stopped) {
              window.requestAnimationFrame(first);
              _stopped = false;
            }
          }
        }
        function freeze() {
          _isFrozen = true;
        }
        function unfreeze() {
          _isFrozen = false;
          activate();
        }
        function setVolume(val2, animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.setVolume(val2, animation);
          }
        }
        function mute(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.mute(animation);
          }
        }
        function unmute(animation) {
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            registeredAnimations[i2].animation.unmute(animation);
          }
        }
        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation2;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop2;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations2;
        moduleOb.resize = resize;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
      }();
      var BezierFactory = function() {
        var ob2 = {};
        ob2.getBezierEasing = getBezierEasing;
        var beziers = {};
        function getBezierEasing(a, b, c6, d2, nm) {
          var str = nm || ("bez_" + a + "_" + b + "_" + c6 + "_" + d2).replace(/\./g, "p");
          if (beziers[str]) {
            return beziers[str];
          }
          var bezEasing = new BezierEasing([a, b, c6, d2]);
          beziers[str] = bezEasing;
          return bezEasing;
        }
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 1e-3;
        var SUBDIVISION_PRECISION = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1 / (kSplineTableSize - 1);
        var float32ArraySupported = typeof Float32Array === "function";
        function A(aA1, aA2) {
          return 1 - 3 * aA2 + 3 * aA1;
        }
        function B(aA1, aA2) {
          return 3 * aA2 - 6 * aA1;
        }
        function C(aA1) {
          return 3 * aA1;
        }
        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }
        function getSlope(aT, aA1, aA2) {
          return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
          var currentX, currentT, i2 = 0;
          do {
            currentT = aA + (aB - aA) / 2;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
          for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0) return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
        }
        function BezierEasing(points) {
          this._p = points;
          this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
          this._precomputed = false;
          this.get = this.get.bind(this);
        }
        BezierEasing.prototype = {
          get: function get(x) {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            if (!this._precomputed) this._precompute();
            if (mX1 === mY1 && mX2 === mY2) return x;
            if (x === 0) return 0;
            if (x === 1) return 1;
            return calcBezier(this._getTForX(x), mY1, mY2);
          },
          // Private part
          _precompute: function _precompute() {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            this._precomputed = true;
            if (mX1 !== mY1 || mX2 !== mY2) {
              this._calcSampleValues();
            }
          },
          _calcSampleValues: function _calcSampleValues() {
            var mX1 = this._p[0], mX2 = this._p[2];
            for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
              this._mSampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
            }
          },
          /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
          _getTForX: function _getTForX(aX) {
            var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;
            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
            }
            --currentSample;
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            }
            if (initialSlope === 0) {
              return guessForT;
            }
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        };
        return ob2;
      }();
      var pooling = /* @__PURE__ */ function() {
        function _double(arr) {
          return arr.concat(createSizedArray(arr.length));
        }
        return {
          "double": _double
        };
      }();
      var poolFactory = /* @__PURE__ */ function() {
        return function(initialLength, _create, _release) {
          var _length = 0;
          var _maxLength = initialLength;
          var pool = createSizedArray(_maxLength);
          var ob2 = {
            newElement,
            release
          };
          function newElement() {
            var element;
            if (_length) {
              _length -= 1;
              element = pool[_length];
            } else {
              element = _create();
            }
            return element;
          }
          function release(element) {
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            if (_release) {
              _release(element);
            }
            pool[_length] = element;
            _length += 1;
          }
          return ob2;
        };
      }();
      var bezierLengthPool = function() {
        function create() {
          return {
            addedLength: 0,
            percents: createTypedArray("float32", getDefaultCurveSegments()),
            lengths: createTypedArray("float32", getDefaultCurveSegments())
          };
        }
        return poolFactory(8, create);
      }();
      var segmentsLengthPool = function() {
        function create() {
          return {
            lengths: [],
            totalLength: 0
          };
        }
        function release(element) {
          var i2;
          var len = element.lengths.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            bezierLengthPool.release(element.lengths[i2]);
          }
          element.lengths.length = 0;
        }
        return poolFactory(8, create, release);
      }();
      function bezFunction() {
        var math = Math;
        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
          var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
          return det1 > -1e-3 && det1 < 1e-3;
        }
        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
          if (z1 === 0 && z2 === 0 && z3 === 0) {
            return pointOnLine2D(x1, y1, x2, y2, x3, y3);
          }
          var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
          var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
          var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
          var diffDist;
          if (dist1 > dist2) {
            if (dist1 > dist3) {
              diffDist = dist1 - dist2 - dist3;
            } else {
              diffDist = dist3 - dist2 - dist1;
            }
          } else if (dist3 > dist2) {
            diffDist = dist3 - dist2 - dist1;
          } else {
            diffDist = dist2 - dist1 - dist3;
          }
          return diffDist > -1e-4 && diffDist < 1e-4;
        }
        var getBezierLength = /* @__PURE__ */ function() {
          return function(pt1, pt2, pt3, pt4) {
            var curveSegments = getDefaultCurveSegments();
            var k;
            var i2;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point = [];
            var lastPoint = [];
            var lengthData = bezierLengthPool.newElement();
            len = pt3.length;
            for (k = 0; k < curveSegments; k += 1) {
              perc = k / (curveSegments - 1);
              ptDistance = 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * pt3[i2] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i2] + bmPow(perc, 3) * pt2[i2];
                point[i2] = ptCoord;
                if (lastPoint[i2] !== null) {
                  ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                }
                lastPoint[i2] = point[i2];
              }
              if (ptDistance) {
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
              }
              lengthData.percents[k] = perc;
              lengthData.lengths[k] = addedLength;
            }
            lengthData.addedLength = addedLength;
            return lengthData;
          };
        }();
        function getSegmentsLength(shapeData) {
          var segmentsLength = segmentsLengthPool.newElement();
          var closed = shapeData.c;
          var pathV = shapeData.v;
          var pathO = shapeData.o;
          var pathI = shapeData.i;
          var i2;
          var len = shapeData._length;
          var lengths = segmentsLength.lengths;
          var totalLength = 0;
          for (i2 = 0; i2 < len - 1; i2 += 1) {
            lengths[i2] = getBezierLength(pathV[i2], pathV[i2 + 1], pathO[i2], pathI[i2 + 1]);
            totalLength += lengths[i2].addedLength;
          }
          if (closed && len) {
            lengths[i2] = getBezierLength(pathV[i2], pathV[0], pathO[i2], pathI[0]);
            totalLength += lengths[i2].addedLength;
          }
          segmentsLength.totalLength = totalLength;
          return segmentsLength;
        }
        function BezierData(length2) {
          this.segmentLength = 0;
          this.points = new Array(length2);
        }
        function PointData(partial, point) {
          this.partialLength = partial;
          this.point = point;
        }
        var buildBezierData = /* @__PURE__ */ function() {
          var storedData = {};
          return function(pt1, pt2, pt3, pt4) {
            var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
            if (!storedData[bezierName]) {
              var curveSegments = getDefaultCurveSegments();
              var k;
              var i2;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point;
              var lastPoint = null;
              if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                curveSegments = 2;
              }
              var bezierData = new BezierData(curveSegments);
              len = pt3.length;
              for (k = 0; k < curveSegments; k += 1) {
                point = createSizedArray(len);
                perc = k / (curveSegments - 1);
                ptDistance = 0;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i2] + pt3[i2]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i2] + pt4[i2]) + bmPow(perc, 3) * pt2[i2];
                  point[i2] = ptCoord;
                  if (lastPoint !== null) {
                    ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                  }
                }
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
                bezierData.points[k] = new PointData(ptDistance, point);
                lastPoint = point;
              }
              bezierData.segmentLength = addedLength;
              storedData[bezierName] = bezierData;
            }
            return storedData[bezierName];
          };
        }();
        function getDistancePerc(perc, bezierData) {
          var percents = bezierData.percents;
          var lengths = bezierData.lengths;
          var len = percents.length;
          var initPos = bmFloor((len - 1) * perc);
          var lengthPos = perc * bezierData.addedLength;
          var lPerc = 0;
          if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
            return percents[initPos];
          }
          var dir = lengths[initPos] > lengthPos ? -1 : 1;
          var flag = true;
          while (flag) {
            if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
              lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
              flag = false;
            } else {
              initPos += dir;
            }
            if (initPos < 0 || initPos >= len - 1) {
              if (initPos === len - 1) {
                return percents[initPos];
              }
              flag = false;
            }
          }
          return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }
        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
          var t1 = getDistancePerc(percent, bezierData);
          var u1 = 1 - t1;
          var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
          var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
          return [ptX, ptY];
        }
        var bezierSegmentPoints = createTypedArray("float32", 8);
        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
          if (startPerc < 0) {
            startPerc = 0;
          } else if (startPerc > 1) {
            startPerc = 1;
          }
          var t0 = getDistancePerc(startPerc, bezierData);
          endPerc = endPerc > 1 ? 1 : endPerc;
          var t1 = getDistancePerc(endPerc, bezierData);
          var i2;
          var len = pt1.length;
          var u0 = 1 - t0;
          var u1 = 1 - t1;
          var u0u0u0 = u0 * u0 * u0;
          var t0u0u0_3 = t0 * u0 * u0 * 3;
          var t0t0u0_3 = t0 * t0 * u0 * 3;
          var t0t0t0 = t0 * t0 * t0;
          var u0u0u1 = u0 * u0 * u1;
          var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
          var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
          var t0t0t1 = t0 * t0 * t1;
          var u0u1u1 = u0 * u1 * u1;
          var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
          var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
          var t0t1t1 = t0 * t1 * t1;
          var u1u1u1 = u1 * u1 * u1;
          var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
          var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
          var t1t1t1 = t1 * t1 * t1;
          for (i2 = 0; i2 < len; i2 += 1) {
            bezierSegmentPoints[i2 * 4] = math.round((u0u0u0 * pt1[i2] + t0u0u0_3 * pt3[i2] + t0t0u0_3 * pt4[i2] + t0t0t0 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 1] = math.round((u0u0u1 * pt1[i2] + t0u0u1_3 * pt3[i2] + t0t0u1_3 * pt4[i2] + t0t0t1 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 2] = math.round((u0u1u1 * pt1[i2] + t0u1u1_3 * pt3[i2] + t0t1u1_3 * pt4[i2] + t0t1t1 * pt2[i2]) * 1e3) / 1e3;
            bezierSegmentPoints[i2 * 4 + 3] = math.round((u1u1u1 * pt1[i2] + t1u1u1_3 * pt3[i2] + t1t1u1_3 * pt4[i2] + t1t1t1 * pt2[i2]) * 1e3) / 1e3;
          }
          return bezierSegmentPoints;
        }
        return {
          getSegmentsLength,
          getNewSegment,
          getPointInSegment,
          buildBezierData,
          pointOnLine2D,
          pointOnLine3D
        };
      }
      var bez = bezFunction();
      var initFrame = initialDefaultFrame;
      var mathAbs = Math.abs;
      function interpolateValue(frameNum, caching) {
        var offsetTime = this.offsetTime;
        var newValue;
        if (this.propType === "multidimensional") {
          newValue = createTypedArray("float32", this.pv.length);
        }
        var iterationIndex = caching.lastIndex;
        var i2 = iterationIndex;
        var len = this.keyframes.length - 1;
        var flag = true;
        var keyData;
        var nextKeyData;
        var keyframeMetadata;
        while (flag) {
          keyData = this.keyframes[i2];
          nextKeyData = this.keyframes[i2 + 1];
          if (i2 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
            if (keyData.h) {
              keyData = nextKeyData;
            }
            iterationIndex = 0;
            break;
          }
          if (nextKeyData.t - offsetTime > frameNum) {
            iterationIndex = i2;
            break;
          }
          if (i2 < len - 1) {
            i2 += 1;
          } else {
            iterationIndex = 0;
            flag = false;
          }
        }
        keyframeMetadata = this.keyframesMetadata[i2] || {};
        var k;
        var kLen;
        var perc;
        var jLen;
        var j;
        var fnc;
        var nextKeyTime = nextKeyData.t - offsetTime;
        var keyTime = keyData.t - offsetTime;
        var endValue;
        if (keyData.to) {
          if (!keyframeMetadata.bezierData) {
            keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
          }
          var bezierData = keyframeMetadata.bezierData;
          if (frameNum >= nextKeyTime || frameNum < keyTime) {
            var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
            kLen = bezierData.points[ind].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[ind].point[k];
            }
          } else {
            if (keyframeMetadata.__fnct) {
              fnc = keyframeMetadata.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
              keyframeMetadata.__fnct = fnc;
            }
            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            var distanceInLine = bezierData.segmentLength * perc;
            var segmentPerc;
            var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastAddedLength : 0;
            j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastPoint : 0;
            flag = true;
            jLen = bezierData.points.length;
            while (flag) {
              addedLength += bezierData.points[j].partialLength;
              if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k];
                }
                break;
              } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                }
                break;
              }
              if (j < jLen - 1) {
                j += 1;
              } else {
                flag = false;
              }
            }
            caching._lastPoint = j;
            caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
            caching._lastKeyframeIndex = i2;
          }
        } else {
          var outX;
          var outY;
          var inX;
          var inY;
          var keyValue;
          len = keyData.s.length;
          endValue = nextKeyData.s || keyData.e;
          if (this.sh && keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              newValue[0] = endValue[0];
              newValue[1] = endValue[1];
              newValue[2] = endValue[2];
            } else if (frameNum <= keyTime) {
              newValue[0] = keyData.s[0];
              newValue[1] = keyData.s[1];
              newValue[2] = keyData.s[2];
            } else {
              var quatStart = createQuaternion(keyData.s);
              var quatEnd = createQuaternion(endValue);
              var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
              quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
            }
          } else {
            for (i2 = 0; i2 < len; i2 += 1) {
              if (keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  perc = 1;
                } else if (frameNum < keyTime) {
                  perc = 0;
                } else {
                  if (keyData.o.x.constructor === Array) {
                    if (!keyframeMetadata.__fnct) {
                      keyframeMetadata.__fnct = [];
                    }
                    if (!keyframeMetadata.__fnct[i2]) {
                      outX = keyData.o.x[i2] === void 0 ? keyData.o.x[0] : keyData.o.x[i2];
                      outY = keyData.o.y[i2] === void 0 ? keyData.o.y[0] : keyData.o.y[i2];
                      inX = keyData.i.x[i2] === void 0 ? keyData.i.x[0] : keyData.i.x[i2];
                      inY = keyData.i.y[i2] === void 0 ? keyData.i.y[0] : keyData.i.y[i2];
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyframeMetadata.__fnct[i2] = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct[i2];
                    }
                  } else if (!keyframeMetadata.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.keyframeMetadata = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                }
              }
              endValue = nextKeyData.s || keyData.e;
              keyValue = keyData.h === 1 ? keyData.s[i2] : keyData.s[i2] + (endValue[i2] - keyData.s[i2]) * perc;
              if (this.propType === "multidimensional") {
                newValue[i2] = keyValue;
              } else {
                newValue = keyValue;
              }
            }
          }
        }
        caching.lastIndex = iterationIndex;
        return newValue;
      }
      function slerp(a, b, t) {
        var out = [];
        var ax = a[0];
        var ay = a[1];
        var az = a[2];
        var aw = a[3];
        var bx = b[0];
        var by = b[1];
        var bz = b[2];
        var bw = b[3];
        var omega;
        var cosom;
        var sinom;
        var scale0;
        var scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
      function quaternionToEuler(out, quat) {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];
        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
        out[0] = heading / degToRads;
        out[1] = attitude / degToRads;
        out[2] = bank / degToRads;
      }
      function createQuaternion(values) {
        var heading = values[0] * degToRads;
        var attitude = values[1] * degToRads;
        var bank = values[2] * degToRads;
        var c12 = Math.cos(heading / 2);
        var c22 = Math.cos(attitude / 2);
        var c32 = Math.cos(bank / 2);
        var s1 = Math.sin(heading / 2);
        var s2 = Math.sin(attitude / 2);
        var s3 = Math.sin(bank / 2);
        var w = c12 * c22 * c32 - s1 * s2 * s3;
        var x = s1 * s2 * c32 + c12 * c22 * s3;
        var y = s1 * c22 * c32 + c12 * s2 * s3;
        var z = c12 * s2 * c32 - s1 * c22 * s3;
        return [x, y, z, w];
      }
      function getValueAtCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
          if (this._caching.lastFrame >= frameNum) {
            this._caching._lastKeyframeIndex = -1;
            this._caching.lastIndex = 0;
          }
          var renderResult = this.interpolateValue(frameNum, this._caching);
          this.pv = renderResult;
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function setVValue(val2) {
        var multipliedValue;
        if (this.propType === "unidimensional") {
          multipliedValue = val2 * this.mult;
          if (mathAbs(this.v - multipliedValue) > 1e-5) {
            this.v = multipliedValue;
            this._mdf = true;
          }
        } else {
          var i2 = 0;
          var len = this.v.length;
          while (i2 < len) {
            multipliedValue = val2[i2] * this.mult;
            if (mathAbs(this.v[i2] - multipliedValue) > 1e-5) {
              this.v[i2] = multipliedValue;
              this._mdf = true;
            }
            i2 += 1;
          }
        }
      }
      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = this._isFirstFrame;
        var i2;
        var len = this.effectsSequence.length;
        var finalValue = this.kf ? this.pv : this.data.k;
        for (i2 = 0; i2 < len; i2 += 1) {
          finalValue = this.effectsSequence[i2](finalValue);
        }
        this.setVValue(finalValue);
        this._isFirstFrame = false;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      function ValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this.v = mult ? data2.k * mult : data2.k;
        this.pv = data2.k;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.vel = 0;
        this.effectsSequence = [];
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function MultiDimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.frameId = -1;
        var i2;
        var len = data2.k.length;
        this.v = createTypedArray("float32", len);
        this.pv = createTypedArray("float32", len);
        this.vel = createTypedArray("float32", len);
        for (i2 = 0; i2 < len; i2 += 1) {
          this.v[i2] = data2.k[i2] * this.mult;
          this.pv[i2] = data2.k[i2];
        }
        this._isFirstFrame = true;
        this.effectsSequence = [];
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function KeyframedValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.frameId = -1;
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: 0,
          _lastKeyframeIndex: -1
        };
        this.k = true;
        this.kf = true;
        this.data = data2;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.v = initFrame;
        this.pv = initFrame;
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.addEffect = addEffect;
      }
      function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        var i2;
        var len = data2.k.length;
        var s2;
        var e2;
        var to2;
        var ti;
        for (i2 = 0; i2 < len - 1; i2 += 1) {
          if (data2.k[i2].to && data2.k[i2].s && data2.k[i2 + 1] && data2.k[i2 + 1].s) {
            s2 = data2.k[i2].s;
            e2 = data2.k[i2 + 1].s;
            to2 = data2.k[i2].to;
            ti = data2.k[i2].ti;
            if (s2.length === 2 && !(s2[0] === e2[0] && s2[1] === e2[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], s2[0] + to2[0], s2[1] + to2[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], e2[0] + ti[0], e2[1] + ti[1]) || s2.length === 3 && !(s2[0] === e2[0] && s2[1] === e2[1] && s2[2] === e2[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], s2[0] + to2[0], s2[1] + to2[1], s2[2] + to2[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], e2[0] + ti[0], e2[1] + ti[1], e2[2] + ti[2])) {
              data2.k[i2].to = null;
              data2.k[i2].ti = null;
            }
            if (s2[0] === e2[0] && s2[1] === e2[1] && to2[0] === 0 && to2[1] === 0 && ti[0] === 0 && ti[1] === 0) {
              if (s2.length === 2 || s2[2] === e2[2] && to2[2] === 0 && ti[2] === 0) {
                data2.k[i2].to = null;
                data2.k[i2].ti = null;
              }
            }
          }
        }
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.data = data2;
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.k = true;
        this.kf = true;
        this._isFirstFrame = true;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.frameId = -1;
        var arrLen = data2.k[0].s.length;
        this.v = createTypedArray("float32", arrLen);
        this.pv = createTypedArray("float32", arrLen);
        for (i2 = 0; i2 < arrLen; i2 += 1) {
          this.v[i2] = initFrame;
          this.pv[i2] = initFrame;
        }
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", arrLen)
        };
        this.addEffect = addEffect;
      }
      var PropertyFactory = /* @__PURE__ */ function() {
        function getProp(elem2, data2, type2, mult, container) {
          if (data2.sid) {
            data2 = elem2.globalData.slotManager.getProp(data2);
          }
          var p2;
          if (!data2.k.length) {
            p2 = new ValueProperty(elem2, data2, mult, container);
          } else if (typeof data2.k[0] === "number") {
            p2 = new MultiDimensionalProperty(elem2, data2, mult, container);
          } else {
            switch (type2) {
              case 0:
                p2 = new KeyframedValueProperty(elem2, data2, mult, container);
                break;
              case 1:
                p2 = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
                break;
            }
          }
          if (p2.effectsSequence.length) {
            container.addDynamicProperty(p2);
          }
          return p2;
        }
        var ob2 = {
          getProp
        };
        return ob2;
      }();
      function DynamicPropertyContainer() {
      }
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
            this.container.addDynamicProperty(this);
            this._isAnimated = true;
          }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
          this._mdf = false;
          var i2;
          var len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.dynamicProperties[i2].getValue();
            if (this.dynamicProperties[i2]._mdf) {
              this._mdf = true;
            }
          }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
          this.container = container;
          this.dynamicProperties = [];
          this._mdf = false;
          this._isAnimated = false;
        }
      };
      var pointPool = function() {
        function create() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, create);
      }();
      function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
      }
      ShapePath.prototype.setPathData = function(closed, len) {
        this.c = closed;
        this.setLength(len);
        var i2 = 0;
        while (i2 < len) {
          this.v[i2] = pointPool.newElement();
          this.o[i2] = pointPool.newElement();
          this.i[i2] = pointPool.newElement();
          i2 += 1;
        }
      };
      ShapePath.prototype.setLength = function(len) {
        while (this._maxLength < len) {
          this.doubleArrayLength();
        }
        this._length = len;
      };
      ShapePath.prototype.doubleArrayLength = function() {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      };
      ShapePath.prototype.setXYAt = function(x, y, type2, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);
        if (this._length >= this._maxLength) {
          this.doubleArrayLength();
        }
        switch (type2) {
          case "v":
            arr = this.v;
            break;
          case "i":
            arr = this.i;
            break;
          case "o":
            arr = this.o;
            break;
          default:
            arr = [];
            break;
        }
        if (!arr[pos] || arr[pos] && !replace) {
          arr[pos] = pointPool.newElement();
        }
        arr[pos][0] = x;
        arr[pos][1] = y;
      };
      ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, "v", pos, replace);
        this.setXYAt(oX, oY, "o", pos, replace);
        this.setXYAt(iX, iY, "i", pos, replace);
      };
      ShapePath.prototype.reverse = function() {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;
        if (this.c) {
          newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
          init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;
        var i2;
        for (i2 = init; i2 < len; i2 += 1) {
          newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i2, false);
          cnt -= 1;
        }
        return newPath;
      };
      ShapePath.prototype.length = function() {
        return this._length;
      };
      var shapePool = function() {
        function create() {
          return new ShapePath();
        }
        function release(shapePath) {
          var len = shapePath._length;
          var i2;
          for (i2 = 0; i2 < len; i2 += 1) {
            pointPool.release(shapePath.v[i2]);
            pointPool.release(shapePath.i[i2]);
            pointPool.release(shapePath.o[i2]);
            shapePath.v[i2] = null;
            shapePath.i[i2] = null;
            shapePath.o[i2] = null;
          }
          shapePath._length = 0;
          shapePath.c = false;
        }
        function clone2(shape) {
          var cloned = factory.newElement();
          var i2;
          var len = shape._length === void 0 ? shape.v.length : shape._length;
          cloned.setLength(len);
          cloned.c = shape.c;
          for (i2 = 0; i2 < len; i2 += 1) {
            cloned.setTripleAt(shape.v[i2][0], shape.v[i2][1], shape.o[i2][0], shape.o[i2][1], shape.i[i2][0], shape.i[i2][1], i2);
          }
          return cloned;
        }
        var factory = poolFactory(4, create, release);
        factory.clone = clone2;
        return factory;
      }();
      function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
      }
      ShapeCollection.prototype.addShape = function(shapeData) {
        if (this._length === this._maxLength) {
          this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        }
        this.shapes[this._length] = shapeData;
        this._length += 1;
      };
      ShapeCollection.prototype.releaseShapes = function() {
        var i2;
        for (i2 = 0; i2 < this._length; i2 += 1) {
          shapePool.release(this.shapes[i2]);
        }
        this._length = 0;
      };
      var shapeCollectionPool = function() {
        var ob2 = {
          newShapeCollection,
          release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);
        function newShapeCollection() {
          var shapeCollection;
          if (_length) {
            _length -= 1;
            shapeCollection = pool[_length];
          } else {
            shapeCollection = new ShapeCollection();
          }
          return shapeCollection;
        }
        function release(shapeCollection) {
          var i2;
          var len = shapeCollection._length;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapePool.release(shapeCollection.shapes[i2]);
          }
          shapeCollection._length = 0;
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          pool[_length] = shapeCollection;
          _length += 1;
        }
        return ob2;
      }();
      var ShapePropertyFactory = function() {
        var initFrame2 = -999999;
        function interpolateShape(frameNum, previousValue, caching) {
          var iterationIndex = caching.lastIndex;
          var keyPropS;
          var keyPropE;
          var isHold;
          var j;
          var k;
          var jLen;
          var kLen;
          var perc;
          var vertexValue;
          var kf = this.keyframes;
          if (frameNum < kf[0].t - this.offsetTime) {
            keyPropS = kf[0].s[0];
            isHold = true;
            iterationIndex = 0;
          } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
            isHold = true;
          } else {
            var i2 = iterationIndex;
            var len = kf.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while (flag) {
              keyData = kf[i2];
              nextKeyData = kf[i2 + 1];
              if (nextKeyData.t - this.offsetTime > frameNum) {
                break;
              }
              if (i2 < len - 1) {
                i2 += 1;
              } else {
                flag = false;
              }
            }
            keyframeMetadata = this.keyframesMetadata[i2] || {};
            isHold = keyData.h === 1;
            iterationIndex = i2;
            if (!isHold) {
              if (frameNum >= nextKeyData.t - this.offsetTime) {
                perc = 1;
              } else if (frameNum < keyData.t - this.offsetTime) {
                perc = 0;
              } else {
                var fnc;
                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                  keyframeMetadata.__fnct = fnc;
                }
                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
              }
              keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
            }
            keyPropS = keyData.s[0];
          }
          jLen = previousValue._length;
          kLen = keyPropS.i[0].length;
          caching.lastIndex = iterationIndex;
          for (j = 0; j < jLen; j += 1) {
            for (k = 0; k < kLen; k += 1) {
              vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
              previousValue.i[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
              previousValue.o[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
              previousValue.v[j][k] = vertexValue;
            }
          }
        }
        function interpolateShapeCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          var lastFrame = this._caching.lastFrame;
          if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
            this.interpolateShape(frameNum, this.pv, this._caching);
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function resetShape() {
          this.paths = this.localShapeCollection;
        }
        function shapesEqual(shape1, shape2) {
          if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
            return false;
          }
          var i2;
          var len = shape1._length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (shape1.v[i2][0] !== shape2.v[i2][0] || shape1.v[i2][1] !== shape2.v[i2][1] || shape1.o[i2][0] !== shape2.o[i2][0] || shape1.o[i2][1] !== shape2.o[i2][1] || shape1.i[i2][0] !== shape2.i[i2][0] || shape1.i[i2][1] !== shape2.i[i2][1]) {
              return false;
            }
          }
          return true;
        }
        function setVValue2(newPath) {
          if (!shapesEqual(this.v, newPath)) {
            this.v = shapePool.clone(newPath);
            this.localShapeCollection.releaseShapes();
            this.localShapeCollection.addShape(this.v);
            this._mdf = true;
            this.paths = this.localShapeCollection;
          }
        }
        function processEffectsSequence2() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (!this.effectsSequence.length) {
            this._mdf = false;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var finalValue;
          if (this.kf) {
            finalValue = this.pv;
          } else if (this.data.ks) {
            finalValue = this.data.ks.k;
          } else {
            finalValue = this.data.pt.k;
          }
          var i2;
          var len = this.effectsSequence.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            finalValue = this.effectsSequence[i2](finalValue);
          }
          this.setVValue(finalValue);
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem2, data2, type2) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.container = elem2;
          this.elem = elem2;
          this.data = data2;
          this.k = false;
          this.kf = false;
          this._mdf = false;
          var pathData = type2 === 3 ? data2.pt.k : data2.ks.k;
          this.v = shapePool.clone(pathData);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.reset = resetShape;
          this.effectsSequence = [];
        }
        function addEffect2(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence2;
        ShapeProperty.prototype.setVValue = setVValue2;
        ShapeProperty.prototype.addEffect = addEffect2;
        function KeyframedShapeProperty(elem2, data2, type2) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.elem = elem2;
          this.container = elem2;
          this.offsetTime = elem2.data.st;
          this.keyframes = type2 === 3 ? data2.pt.k : data2.ks.k;
          this.keyframesMetadata = [];
          this.k = true;
          this.kf = true;
          var len = this.keyframes[0].s[0].i.length;
          this.v = shapePool.newElement();
          this.v.setPathData(this.keyframes[0].s[0].c, len);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.lastFrame = initFrame2;
          this.reset = resetShape;
          this._caching = {
            lastFrame: initFrame2,
            lastIndex: 0
          };
          this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue2;
        KeyframedShapeProperty.prototype.addEffect = addEffect2;
        var EllShapeProperty = function() {
          var cPoint = roundCorner;
          function EllShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 4);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.localShapeCollection.addShape(this.v);
            this.d = data2.d;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertEllToPath();
            }
          }
          EllShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue2() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertEllToPath();
              }
            },
            convertEllToPath: function convertEllToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var s0 = this.s.v[0] / 2;
              var s1 = this.s.v[1] / 2;
              var _cw = this.d !== 3;
              var _v = this.v;
              _v.v[0][0] = p0;
              _v.v[0][1] = p1 - s1;
              _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.v[1][1] = p1;
              _v.v[2][0] = p0;
              _v.v[2][1] = p1 + s1;
              _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.v[3][1] = p1;
              _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.i[0][1] = p1 - s1;
              _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.i[1][1] = p1 - s1 * cPoint;
              _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.i[2][1] = p1 + s1;
              _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.i[3][1] = p1 + s1 * cPoint;
              _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.o[0][1] = p1 - s1;
              _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.o[1][1] = p1 + s1 * cPoint;
              _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.o[2][1] = p1 + s1;
              _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.o[3][1] = p1 - s1 * cPoint;
            }
          };
          extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
          return EllShapePropertyFactory;
        }();
        var StarShapeProperty = function() {
          function StarShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 0);
            this.elem = elem2;
            this.comp = elem2.comp;
            this.data = data2;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            if (data2.sy === 1) {
              this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
              this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
              this.convertToPath = this.convertStarToPath;
            } else {
              this.convertToPath = this.convertPolygonToPath;
            }
            this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
            this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
            this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertToPath();
            }
          }
          StarShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue2() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertToPath();
              }
            },
            convertStarToPath: function convertStarToPath() {
              var numPts = Math.floor(this.pt.v) * 2;
              var angle = Math.PI * 2 / numPts;
              var longFlag = true;
              var longRad = this.or.v;
              var shortRad = this.ir.v;
              var longRound = this.os.v;
              var shortRound = this.is.v;
              var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
              var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
              var i2;
              var rad;
              var roundness;
              var perimSegment;
              var currentAng = -Math.PI / 2;
              currentAng += this.r.v;
              var dir = this.data.d === 3 ? -1 : 1;
              this.v._length = 0;
              for (i2 = 0; i2 < numPts; i2 += 1) {
                rad = longFlag ? longRad : shortRad;
                roundness = longFlag ? longRound : shortRound;
                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i2, true);
                longFlag = !longFlag;
                currentAng += angle * dir;
              }
            },
            convertPolygonToPath: function convertPolygonToPath() {
              var numPts = Math.floor(this.pt.v);
              var angle = Math.PI * 2 / numPts;
              var rad = this.or.v;
              var roundness = this.os.v;
              var perimSegment = 2 * Math.PI * rad / (numPts * 4);
              var i2;
              var currentAng = -Math.PI * 0.5;
              var dir = this.data.d === 3 ? -1 : 1;
              currentAng += this.r.v;
              this.v._length = 0;
              for (i2 = 0; i2 < numPts; i2 += 1) {
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i2, true);
                currentAng += angle * dir;
              }
              this.paths.length = 0;
              this.paths[0] = this.v;
            }
          };
          extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
          return StarShapePropertyFactory;
        }();
        var RectShapeProperty = function() {
          function RectShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.c = true;
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertRectToPath();
            }
          }
          RectShapePropertyFactory.prototype = {
            convertRectToPath: function convertRectToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var v0 = this.s.v[0] / 2;
              var v1 = this.s.v[1] / 2;
              var round = bmMin(v0, v1, this.r.v);
              var cPoint = round * (1 - roundCorner);
              this.v._length = 0;
              if (this.d === 2 || this.d === 1) {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                }
              } else {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                }
              }
            },
            getValue: function getValue2() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertRectToPath();
              }
            },
            reset: resetShape
          };
          extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
          return RectShapePropertyFactory;
        }();
        function getShapeProp(elem2, data2, type2) {
          var prop;
          if (type2 === 3 || type2 === 4) {
            var dataProp = type2 === 3 ? data2.pt : data2.ks;
            var keys = dataProp.k;
            if (keys.length) {
              prop = new KeyframedShapeProperty(elem2, data2, type2);
            } else {
              prop = new ShapeProperty(elem2, data2, type2);
            }
          } else if (type2 === 5) {
            prop = new RectShapeProperty(elem2, data2);
          } else if (type2 === 6) {
            prop = new EllShapeProperty(elem2, data2);
          } else if (type2 === 7) {
            prop = new StarShapeProperty(elem2, data2);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        }
        function getConstructorFunction() {
          return ShapeProperty;
        }
        function getKeyframedConstructorFunction() {
          return KeyframedShapeProperty;
        }
        var ob2 = {};
        ob2.getShapeProp = getShapeProp;
        ob2.getConstructorFunction = getConstructorFunction;
        ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob2;
      }();
      /*!
       Transformation Matrix v2.0
       (c) Epistemex 2014-2015
       www.epistemex.com
       By Ken Fyrstenberg
       Contributions by leeoniya.
       License: MIT, header required.
       */
      var Matrix = /* @__PURE__ */ function() {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;
        function reset() {
          this.props[0] = 1;
          this.props[1] = 0;
          this.props[2] = 0;
          this.props[3] = 0;
          this.props[4] = 0;
          this.props[5] = 1;
          this.props[6] = 0;
          this.props[7] = 0;
          this.props[8] = 0;
          this.props[9] = 0;
          this.props[10] = 1;
          this.props[11] = 0;
          this.props[12] = 0;
          this.props[13] = 0;
          this.props[14] = 0;
          this.props[15] = 1;
          return this;
        }
        function rotate(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function rotateX(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }
        function rotateY(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }
        function rotateZ(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function shear(sx, sy) {
          return this._t(1, sy, sx, 1, 0, 0);
        }
        function skew(ax, ay) {
          return this.shear(_tan(ax), _tan(ay));
        }
        function skewFromAxis(ax, angle) {
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function scale2(sx, sy, sz) {
          if (!sz && sz !== 0) {
            sz = 1;
          }
          if (sx === 1 && sy === 1 && sz === 1) {
            return this;
          }
          return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }
        function setTransform(a, b, c6, d2, e2, f, g, h, i2, j, k, l2, m2, n2, o, p2) {
          this.props[0] = a;
          this.props[1] = b;
          this.props[2] = c6;
          this.props[3] = d2;
          this.props[4] = e2;
          this.props[5] = f;
          this.props[6] = g;
          this.props[7] = h;
          this.props[8] = i2;
          this.props[9] = j;
          this.props[10] = k;
          this.props[11] = l2;
          this.props[12] = m2;
          this.props[13] = n2;
          this.props[14] = o;
          this.props[15] = p2;
          return this;
        }
        function translate(tx, ty, tz) {
          tz = tz || 0;
          if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
          }
          return this;
        }
        function transform2(a2, b2, c22, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
          var _p = this.props;
          if (a2 === 1 && b2 === 0 && c22 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
            _p[12] = _p[12] * a2 + _p[15] * m2;
            _p[13] = _p[13] * f2 + _p[15] * n2;
            _p[14] = _p[14] * k2 + _p[15] * o2;
            _p[15] *= p2;
            this._identityCalculated = false;
            return this;
          }
          var a1 = _p[0];
          var b1 = _p[1];
          var c12 = _p[2];
          var d1 = _p[3];
          var e1 = _p[4];
          var f1 = _p[5];
          var g1 = _p[6];
          var h1 = _p[7];
          var i1 = _p[8];
          var j1 = _p[9];
          var k1 = _p[10];
          var l1 = _p[11];
          var m1 = _p[12];
          var n1 = _p[13];
          var o1 = _p[14];
          var p1 = _p[15];
          _p[0] = a1 * a2 + b1 * e2 + c12 * i2 + d1 * m2;
          _p[1] = a1 * b2 + b1 * f2 + c12 * j2 + d1 * n2;
          _p[2] = a1 * c22 + b1 * g2 + c12 * k2 + d1 * o2;
          _p[3] = a1 * d2 + b1 * h2 + c12 * l2 + d1 * p2;
          _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
          _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
          _p[6] = e1 * c22 + f1 * g2 + g1 * k2 + h1 * o2;
          _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
          _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
          _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
          _p[10] = i1 * c22 + j1 * g2 + k1 * k2 + l1 * o2;
          _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
          _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
          _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
          _p[14] = m1 * c22 + n1 * g2 + o1 * k2 + p1 * o2;
          _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
          this._identityCalculated = false;
          return this;
        }
        function multiply(matrix) {
          var matrixProps = matrix.props;
          return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
        }
        function isIdentity() {
          if (!this._identityCalculated) {
            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
            this._identityCalculated = true;
          }
          return this._identity;
        }
        function equals(matr) {
          var i2 = 0;
          while (i2 < 16) {
            if (matr.props[i2] !== this.props[i2]) {
              return false;
            }
            i2 += 1;
          }
          return true;
        }
        function clone2(matr) {
          var i2;
          for (i2 = 0; i2 < 16; i2 += 1) {
            matr.props[i2] = this.props[i2];
          }
          return matr;
        }
        function cloneFromProps(props) {
          var i2;
          for (i2 = 0; i2 < 16; i2 += 1) {
            this.props[i2] = props[i2];
          }
        }
        function applyToPoint(x, y, z) {
          return {
            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
          };
        }
        function applyToX(x, y, z) {
          return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
        }
        function applyToY(x, y, z) {
          return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
        }
        function applyToZ(x, y, z) {
          return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
        }
        function getInverseMatrix() {
          var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
          var a = this.props[5] / determinant;
          var b = -this.props[1] / determinant;
          var c6 = -this.props[4] / determinant;
          var d2 = this.props[0] / determinant;
          var e2 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
          var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
          var inverseMatrix = new Matrix();
          inverseMatrix.props[0] = a;
          inverseMatrix.props[1] = b;
          inverseMatrix.props[4] = c6;
          inverseMatrix.props[5] = d2;
          inverseMatrix.props[12] = e2;
          inverseMatrix.props[13] = f;
          return inverseMatrix;
        }
        function inversePoint(pt) {
          var inverseMatrix = this.getInverseMatrix();
          return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }
        function inversePoints(pts) {
          var i2;
          var len = pts.length;
          var retPts = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            retPts[i2] = inversePoint(pts[i2]);
          }
          return retPts;
        }
        function applyToTriplePoints(pt1, pt2, pt3) {
          var arr = createTypedArray("float32", 6);
          if (this.isIdentity()) {
            arr[0] = pt1[0];
            arr[1] = pt1[1];
            arr[2] = pt2[0];
            arr[3] = pt2[1];
            arr[4] = pt3[0];
            arr[5] = pt3[1];
          } else {
            var p0 = this.props[0];
            var p1 = this.props[1];
            var p4 = this.props[4];
            var p5 = this.props[5];
            var p12 = this.props[12];
            var p13 = this.props[13];
            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
          }
          return arr;
        }
        function applyToPointArray(x, y, z) {
          var arr;
          if (this.isIdentity()) {
            arr = [x, y, z];
          } else {
            arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
          }
          return arr;
        }
        function applyToPointStringified(x, y) {
          if (this.isIdentity()) {
            return x + "," + y;
          }
          var _p = this.props;
          return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
        }
        function toCSS() {
          var i2 = 0;
          var props = this.props;
          var cssValue = "matrix3d(";
          var v = 1e4;
          while (i2 < 16) {
            cssValue += _rnd(props[i2] * v) / v;
            cssValue += i2 === 15 ? ")" : ",";
            i2 += 1;
          }
          return cssValue;
        }
        function roundMatrixProperty(val2) {
          var v = 1e4;
          if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
            return _rnd(val2 * v) / v;
          }
          return val2;
        }
        function to2dCSS() {
          var props = this.props;
          var _a = roundMatrixProperty(props[0]);
          var _b = roundMatrixProperty(props[1]);
          var _c = roundMatrixProperty(props[4]);
          var _d = roundMatrixProperty(props[5]);
          var _e = roundMatrixProperty(props[12]);
          var _f = roundMatrixProperty(props[13]);
          return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
        }
        return function() {
          this.reset = reset;
          this.rotate = rotate;
          this.rotateX = rotateX;
          this.rotateY = rotateY;
          this.rotateZ = rotateZ;
          this.skew = skew;
          this.skewFromAxis = skewFromAxis;
          this.shear = shear;
          this.scale = scale2;
          this.setTransform = setTransform;
          this.translate = translate;
          this.transform = transform2;
          this.multiply = multiply;
          this.applyToPoint = applyToPoint;
          this.applyToX = applyToX;
          this.applyToY = applyToY;
          this.applyToZ = applyToZ;
          this.applyToPointArray = applyToPointArray;
          this.applyToTriplePoints = applyToTriplePoints;
          this.applyToPointStringified = applyToPointStringified;
          this.toCSS = toCSS;
          this.to2dCSS = to2dCSS;
          this.clone = clone2;
          this.cloneFromProps = cloneFromProps;
          this.equals = equals;
          this.inversePoints = inversePoints;
          this.inversePoint = inversePoint;
          this.getInverseMatrix = getInverseMatrix;
          this._t = this.transform;
          this.isIdentity = isIdentity;
          this._identity = true;
          this._identityCalculated = false;
          this.props = createTypedArray("float32", 16);
          this.reset();
        };
      }();
      function _typeof$3(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$3 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$3 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$3(obj);
      }
      var lottie = {};
      function setLocation(href) {
        setLocationHref(href);
      }
      function searchAnimations() {
        {
          animationManager.searchAnimations();
        }
      }
      function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
      }
      function setPrefix(prefix2) {
        setIdPrefix(prefix2);
      }
      function loadAnimation(params) {
        return animationManager.loadAnimation(params);
      }
      function setQuality(value2) {
        if (typeof value2 === "string") {
          switch (value2) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        } else if (!isNaN(value2) && value2 > 1) {
          setDefaultCurveSegments(value2);
        }
      }
      function inBrowser() {
        return typeof navigator !== "undefined";
      }
      function installPlugin(type2, plugin) {
        if (type2 === "expressions") {
          setExpressionsPlugin(plugin);
        }
      }
      function getFactory(name2) {
        switch (name2) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      lottie.play = animationManager.play;
      lottie.pause = animationManager.pause;
      lottie.setLocationHref = setLocation;
      lottie.togglePause = animationManager.togglePause;
      lottie.setSpeed = animationManager.setSpeed;
      lottie.setDirection = animationManager.setDirection;
      lottie.stop = animationManager.stop;
      lottie.searchAnimations = searchAnimations;
      lottie.registerAnimation = animationManager.registerAnimation;
      lottie.loadAnimation = loadAnimation;
      lottie.setSubframeRendering = setSubframeRendering;
      lottie.resize = animationManager.resize;
      lottie.goToAndStop = animationManager.goToAndStop;
      lottie.destroy = animationManager.destroy;
      lottie.setQuality = setQuality;
      lottie.inBrowser = inBrowser;
      lottie.installPlugin = installPlugin;
      lottie.freeze = animationManager.freeze;
      lottie.unfreeze = animationManager.unfreeze;
      lottie.setVolume = animationManager.setVolume;
      lottie.mute = animationManager.mute;
      lottie.unmute = animationManager.unmute;
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
      lottie.useWebWorker = setWebWorker;
      lottie.setIDPrefix = setPrefix;
      lottie.__getFactory = getFactory;
      lottie.version = "5.12.2";
      function checkReady() {
        if (document.readyState === "complete") {
          clearInterval(readyStateCheckInterval);
          searchAnimations();
        }
      }
      function getQueryVariable(variable) {
        var vars = queryString.split("&");
        for (var i2 = 0; i2 < vars.length; i2 += 1) {
          var pair = vars[i2].split("=");
          if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
          }
        }
        return null;
      }
      var queryString = "";
      {
        var scripts = document.getElementsByTagName("script");
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
          src: ""
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
        getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        if (!((false ? "undefined" : _typeof$3(exports)) === "object" && true) && true) {
          window.bodymovin = lottie;
        }
      } catch (err) {
      }
      var ShapeModifiers = function() {
        var ob2 = {};
        var modifiers = {};
        ob2.registerModifier = registerModifier;
        ob2.getModifier = getModifier;
        function registerModifier(nm, factory) {
          if (!modifiers[nm]) {
            modifiers[nm] = factory;
          }
        }
        function getModifier(nm, elem2, data2) {
          return new modifiers[nm](elem2, data2);
        }
        return ob2;
      }();
      function ShapeModifier() {
      }
      ShapeModifier.prototype.initModifierProperties = function() {
      };
      ShapeModifier.prototype.addShapeToModifier = function() {
      };
      ShapeModifier.prototype.addShape = function(data2) {
        if (!this.closed) {
          data2.sh.container.addDynamicProperty(data2.sh);
          var shapeData = {
            shape: data2.sh,
            data: data2,
            localShapeCollection: shapeCollectionPool.newShapeCollection()
          };
          this.shapes.push(shapeData);
          this.addShapeToModifier(shapeData);
          if (this._isAnimated) {
            data2.setAsAnimated();
          }
        }
      };
      ShapeModifier.prototype.init = function(elem2, data2) {
        this.shapes = [];
        this.elem = elem2;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, data2);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      ShapeModifier.prototype.processKeys = function() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {
      }
      extendPrototype([ShapeModifier], TrimModifier);
      TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data2.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
      };
      TrimModifier.prototype.addShapeToModifier = function(shapeData) {
        shapeData.pathsData = [];
      };
      TrimModifier.prototype.calculateShapeEdges = function(s2, e2, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e2 <= 1) {
          segments.push({
            s: s2,
            e: e2
          });
        } else if (s2 >= 1) {
          segments.push({
            s: s2 - 1,
            e: e2 - 1
          });
        } else {
          segments.push({
            s: s2,
            e: 1
          });
          segments.push({
            s: 0,
            e: e2 - 1
          });
        }
        var shapeSegments = [];
        var i2;
        var len = segments.length;
        var segmentOb;
        for (i2 = 0; i2 < len; i2 += 1) {
          segmentOb = segments[i2];
          if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
            var shapeS;
            var shapeE;
            if (segmentOb.s * totalModifierLength <= addedLength) {
              shapeS = 0;
            } else {
              shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
            }
            if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
              shapeE = 1;
            } else {
              shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
            }
            shapeSegments.push([shapeS, shapeE]);
          }
        }
        if (!shapeSegments.length) {
          shapeSegments.push([0, 0]);
        }
        return shapeSegments;
      };
      TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i2;
        var len = pathsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          segmentsLengthPool.release(pathsData[i2]);
        }
        pathsData.length = 0;
        return pathsData;
      };
      TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s2;
        var e2;
        if (this._mdf || _isFirstFrame) {
          var o = this.o.v % 360 / 360;
          if (o < 0) {
            o += 1;
          }
          if (this.s.v > 1) {
            s2 = 1 + o;
          } else if (this.s.v < 0) {
            s2 = 0 + o;
          } else {
            s2 = this.s.v + o;
          }
          if (this.e.v > 1) {
            e2 = 1 + o;
          } else if (this.e.v < 0) {
            e2 = 0 + o;
          } else {
            e2 = this.e.v + o;
          }
          if (s2 > e2) {
            var _s = s2;
            s2 = e2;
            e2 = _s;
          }
          s2 = Math.round(s2 * 1e4) * 1e-4;
          e2 = Math.round(e2 * 1e4) * 1e-4;
          this.sValue = s2;
          this.eValue = e2;
        } else {
          s2 = this.sValue;
          e2 = this.eValue;
        }
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;
        if (e2 === s2) {
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].localShapeCollection.releaseShapes();
            this.shapes[i2].shape._mdf = true;
            this.shapes[i2].shape.paths = this.shapes[i2].localShapeCollection;
            if (this._mdf) {
              this.shapes[i2].pathsData.length = 0;
            }
          }
        } else if (!(e2 === 1 && s2 === 0 || e2 === 0 && s2 === 1)) {
          var segments = [];
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
              shapeData.shape.paths = shapeData.localShapeCollection;
            } else {
              shapePaths = shapeData.shape.paths;
              jLen = shapePaths._length;
              totalShapeLength = 0;
              if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                totalShapeLength = shapeData.totalShapeLength;
              } else {
                pathsData = this.releasePathsData(shapeData.pathsData);
                for (j = 0; j < jLen; j += 1) {
                  pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                  pathsData.push(pathData);
                  totalShapeLength += pathData.totalLength;
                }
                shapeData.totalShapeLength = totalShapeLength;
                shapeData.pathsData = pathsData;
              }
              totalModifierLength += totalShapeLength;
              shapeData.shape._mdf = true;
            }
          }
          var shapeS = s2;
          var shapeE = e2;
          var addedLength = 0;
          var edges;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            shapeData = this.shapes[i2];
            if (shapeData.shape._mdf) {
              localShapeCollection = shapeData.localShapeCollection;
              localShapeCollection.releaseShapes();
              if (this.m === 2 && len > 1) {
                edges = this.calculateShapeEdges(s2, e2, shapeData.totalShapeLength, addedLength, totalModifierLength);
                addedLength += shapeData.totalShapeLength;
              } else {
                edges = [[shapeS, shapeE]];
              }
              jLen = edges.length;
              for (j = 0; j < jLen; j += 1) {
                shapeS = edges[j][0];
                shapeE = edges[j][1];
                segments.length = 0;
                if (shapeE <= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength * shapeE
                  });
                } else if (shapeS >= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * (shapeS - 1),
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                } else {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength
                  });
                  segments.push({
                    s: 0,
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                }
                var newShapesData = this.addShapes(shapeData, segments[0]);
                if (segments[0].s !== segments[0].e) {
                  if (segments.length > 1) {
                    var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                    if (lastShapeInCollection.c) {
                      var lastShape = newShapesData.pop();
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                    } else {
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1]);
                    }
                  }
                  this.addPaths(newShapesData, localShapeCollection);
                }
              }
              shapeData.shape.paths = localShapeCollection;
            }
          }
        } else if (this._mdf) {
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].pathsData.length = 0;
            this.shapes[i2].shape._mdf = true;
          }
        }
      };
      TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i2;
        var len = newPaths.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          localShapeCollection.addShape(newPaths[i2]);
        }
      };
      TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
        shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
        }
        shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
      };
      TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], "o", pos);
        shapePath.setXYAt(points[2], points[6], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(points[0], points[4], "v", pos);
        }
        shapePath.setXYAt(points[3], points[7], "v", pos + 1);
      };
      TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i2;
        var len = shapeData.shape.paths._length;
        var j;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
          shapePath = shapePool.newElement();
          segmentCount = 0;
          initPos = 0;
        } else {
          segmentCount = shapePath._length;
          initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for (i2 = 0; i2 < len; i2 += 1) {
          lengths = pathsData[i2].lengths;
          shapePath.c = shapePaths[i2].c;
          jLen = shapePaths[i2].c ? lengths.length : lengths.length + 1;
          for (j = 1; j < jLen; j += 1) {
            currentLengthData = lengths[j - 1];
            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
              addedLength += currentLengthData.addedLength;
              shapePath.c = false;
            } else if (addedLength > shapeSegment.e) {
              shapePath.c = false;
              break;
            } else {
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], shapePaths[i2].v[j], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[j], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
          }
          if (shapePaths[i2].c && lengths.length) {
            currentLengthData = lengths[j - 1];
            if (addedLength <= shapeSegment.e) {
              var segmentLength = lengths[j - 1].addedLength;
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], shapePaths[i2].v[0], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[0], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
            } else {
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
          if (shapePath._length) {
            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
          }
          if (addedLength > shapeSegment.e) {
            break;
          }
          if (i2 < len - 1) {
            shapePath = shapePool.newElement();
            newShape = true;
            shapes.push(shapePath);
            segmentCount = 0;
          }
        }
        return shapes;
      };
      function PuckerAndBloatModifier() {
      }
      extendPrototype([ShapeModifier], PuckerAndBloatModifier);
      PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
      };
      PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length;
        var i2 = 0;
        for (i2 = 0; i2 < pathLength; i2 += 1) {
          centerPoint[0] += path.v[i2][0];
          centerPoint[1] += path.v[i2][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i2 = 0; i2 < pathLength; i2 += 1) {
          vX = path.v[i2][0] + (centerPoint[0] - path.v[i2][0]) * percent;
          vY = path.v[i2][1] + (centerPoint[1] - path.v[i2][1]) * percent;
          oX = path.o[i2][0] + (centerPoint[0] - path.o[i2][0]) * -percent;
          oY = path.o[i2][1] + (centerPoint[1] - path.o[i2][1]) * -percent;
          iX = path.i[i2][0] + (centerPoint[0] - path.i[i2][0]) * -percent;
          iY = path.i[i2][1] + (centerPoint[1] - path.i[i2][1]) * -percent;
          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i2);
        }
        return clonedPath;
      };
      PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      var TransformPropertyFactory = function() {
        var defaultVector = [0, 0];
        function applyToMatrix(mat) {
          var _mdf = this._mdf;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || _mdf;
          if (this.a) {
            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.s) {
            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk) {
            mat.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r) {
            mat.rotate(-this.r.v);
          } else {
            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.data.p.s) {
            if (this.data.p.z) {
              mat.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              mat.translate(this.px.v, this.py.v, 0);
            }
          } else {
            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        function processKeys(forceRender) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (this._isDirty) {
            this.precalculateMatrix();
            this._isDirty = false;
          }
          this.iterateDynamicProperties();
          if (this._mdf || forceRender) {
            var frameRate;
            this.v.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.appliedTransformations < 2) {
              this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk && this.appliedTransformations < 3) {
              this.v.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r && this.appliedTransformations < 4) {
              this.v.rotate(-this.r.v);
            } else if (!this.r && this.appliedTransformations < 4) {
              this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.autoOriented) {
              var v1;
              var v2;
              frameRate = this.elem.globalData.frameRate;
              if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                  v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                  v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                  v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                  v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                } else {
                  v1 = this.p.pv;
                  v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                }
              } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                v1 = [];
                v2 = [];
                var px = this.px;
                var py = this.py;
                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                  v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                  v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                  v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                  v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                  v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                  v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                  v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                } else {
                  v1 = [px.pv, py.pv];
                  v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                  v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                }
              } else {
                v2 = defaultVector;
                v1 = v2;
              }
              this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
            }
            if (this.data.p && this.data.p.s) {
              if (this.data.p.z) {
                this.v.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                this.v.translate(this.px.v, this.py.v, 0);
              }
            } else {
              this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          this.frameId = this.elem.globalData.frameId;
        }
        function precalculateMatrix() {
          this.appliedTransformations = 0;
          this.pre.reset();
          if (!this.a.effectsSequence.length) {
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            this.appliedTransformations = 1;
          } else {
            return;
          }
          if (!this.s.effectsSequence.length) {
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            this.appliedTransformations = 2;
          } else {
            return;
          }
          if (this.sk) {
            if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
              this.pre.skewFromAxis(-this.sk.v, this.sa.v);
              this.appliedTransformations = 3;
            } else {
              return;
            }
          }
          if (this.r) {
            if (!this.r.effectsSequence.length) {
              this.pre.rotate(-this.r.v);
              this.appliedTransformations = 4;
            }
          } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            this.appliedTransformations = 4;
          }
        }
        function autoOrient() {
        }
        function addDynamicProperty(prop) {
          this._addDynamicProperty(prop);
          this.elem.addDynamicProperty(prop);
          this._isDirty = true;
        }
        function TransformProperty(elem2, data2, container) {
          this.elem = elem2;
          this.frameId = -1;
          this.propType = "transform";
          this.data = data2;
          this.v = new Matrix();
          this.pre = new Matrix();
          this.appliedTransformations = 0;
          this.initDynamicPropertyContainer(container || elem2);
          if (data2.p && data2.p.s) {
            this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
            this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
            if (data2.p.z) {
              this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
            }
          } else {
            this.p = PropertyFactory.getProp(elem2, data2.p || {
              k: [0, 0, 0]
            }, 1, 0, this);
          }
          if (data2.rx) {
            this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
            this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
            this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
            if (data2.or.k[0].ti) {
              var i2;
              var len = data2.or.k.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                data2.or.k[i2].to = null;
                data2.or.k[i2].ti = null;
              }
            }
            this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
            this.or.sh = true;
          } else {
            this.r = PropertyFactory.getProp(elem2, data2.r || {
              k: 0
            }, 0, degToRads, this);
          }
          if (data2.sk) {
            this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
            this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
          }
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: [0, 0, 0]
          }, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: [100, 100, 100]
          }, 1, 0.01, this);
          if (data2.o) {
            this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
          } else {
            this.o = {
              _mdf: false,
              v: 1
            };
          }
          this._isDirty = true;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
        }
        TransformProperty.prototype = {
          applyToMatrix,
          getValue: processKeys,
          precalculateMatrix,
          autoOrient
        };
        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
        function getTransformProperty(elem2, data2, container) {
          return new TransformProperty(elem2, data2, container);
        }
        return {
          getTransformProperty
        };
      }();
      function RepeaterModifier() {
      }
      extendPrototype([ShapeModifier], RepeaterModifier);
      RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
        this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
        this.data = data2;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
      };
      RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
        var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
        pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
        rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        rMatrix.rotate(-transform2.r.v * dir * perc);
        rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
      };
      RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
        this.elem = elem2;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, arr[pos]);
        while (pos > 0) {
          pos -= 1;
          this._elements.unshift(arr[pos]);
        }
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      RepeaterModifier.prototype.resetElements = function(elements) {
        var i2;
        var len = elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          elements[i2]._processed = false;
          if (elements[i2].ty === "gr") {
            this.resetElements(elements[i2].it);
          }
        }
      };
      RepeaterModifier.prototype.cloneElements = function(elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
      };
      RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i2;
        var len = elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          elements[i2]._render = renderFlag;
          if (elements[i2].ty === "gr") {
            this.changeGroupRender(elements[i2].it, renderFlag);
          }
        }
      };
      RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items;
        var itemsTransform;
        var i2;
        var dir;
        var cont;
        var hasReloaded = false;
        if (this._mdf || _isFirstFrame) {
          var copies = Math.ceil(this.c.v);
          if (this._groups.length < copies) {
            while (this._groups.length < copies) {
              var group = {
                it: this.cloneElements(this._elements),
                ty: "gr"
              };
              group.it.push({
                a: {
                  a: 0,
                  ix: 1,
                  k: [0, 0]
                },
                nm: "Transform",
                o: {
                  a: 0,
                  ix: 7,
                  k: 100
                },
                p: {
                  a: 0,
                  ix: 2,
                  k: [0, 0]
                },
                r: {
                  a: 1,
                  ix: 6,
                  k: [{
                    s: 0,
                    e: 0,
                    t: 0
                  }, {
                    s: 0,
                    e: 0,
                    t: 1
                  }]
                },
                s: {
                  a: 0,
                  ix: 3,
                  k: [100, 100]
                },
                sa: {
                  a: 0,
                  ix: 5,
                  k: 0
                },
                sk: {
                  a: 0,
                  ix: 4,
                  k: 0
                },
                ty: "tr"
              });
              this.arr.splice(0, 0, group);
              this._groups.splice(0, 0, group);
              this._currentCopies += 1;
            }
            this.elem.reloadShapes();
            hasReloaded = true;
          }
          cont = 0;
          var renderFlag;
          for (i2 = 0; i2 <= this._groups.length - 1; i2 += 1) {
            renderFlag = cont < copies;
            this._groups[i2]._render = renderFlag;
            this.changeGroupRender(this._groups[i2].it, renderFlag);
            if (!renderFlag) {
              var elems = this.elemsData[i2].it;
              var transformData2 = elems[elems.length - 1];
              if (transformData2.transform.op.v !== 0) {
                transformData2.transform.op._mdf = true;
                transformData2.transform.op.v = 0;
              } else {
                transformData2.transform.op._mdf = false;
              }
            }
            cont += 1;
          }
          this._currentCopies = copies;
          var offset = this.o.v;
          var offsetModulo = offset % 1;
          var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
          var pProps = this.pMatrix.props;
          var rProps = this.rMatrix.props;
          var sProps = this.sMatrix.props;
          this.pMatrix.reset();
          this.rMatrix.reset();
          this.sMatrix.reset();
          this.tMatrix.reset();
          this.matrix.reset();
          var iteration = 0;
          if (offset > 0) {
            while (iteration < roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              iteration += 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
              iteration += offsetModulo;
            }
          } else if (offset < 0) {
            while (iteration > roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
              iteration -= 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
              iteration -= offsetModulo;
            }
          }
          i2 = this.data.m === 1 ? 0 : this._currentCopies - 1;
          dir = this.data.m === 1 ? 1 : -1;
          cont = this._currentCopies;
          var j;
          var jLen;
          while (cont) {
            items = this.elemsData[i2].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            jLen = itemsTransform.length;
            items[items.length - 1].transform.mProps._mdf = true;
            items[items.length - 1].transform.op._mdf = true;
            items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i2 / (this._currentCopies - 1));
            if (iteration !== 0) {
              if (i2 !== 0 && dir === 1 || i2 !== this._currentCopies - 1 && dir === -1) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              }
              this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
              this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
              this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }
              this.matrix.reset();
            } else {
              this.matrix.reset();
              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }
            }
            iteration += 1;
            cont -= 1;
            i2 += dir;
          }
        } else {
          cont = this._currentCopies;
          i2 = 0;
          dir = 1;
          while (cont) {
            items = this.elemsData[i2].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            items[items.length - 1].transform.mProps._mdf = false;
            items[items.length - 1].transform.op._mdf = false;
            cont -= 1;
            i2 += dir;
          }
        }
        return hasReloaded;
      };
      RepeaterModifier.prototype.addShape = function() {
      };
      function RoundCornersModifier() {
      }
      extendPrototype([ShapeModifier], RoundCornersModifier);
      RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
      };
      RoundCornersModifier.prototype.processPath = function(path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i2;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance;
        var newPosPerc;
        var index2 = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i2 = 0; i2 < len; i2 += 1) {
          currentV = path.v[i2];
          currentO = path.o[i2];
          currentI = path.i[i2];
          if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
            if ((i2 === 0 || i2 === len - 1) && !path.c) {
              clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
              index2 += 1;
            } else {
              if (i2 === 0) {
                closerV = path.v[len - 1];
              } else {
                closerV = path.v[i2 - 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = iX;
              iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
              vY = iY;
              oX = vX - (vX - currentV[0]) * roundCorner;
              oY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
              if (i2 === len - 1) {
                closerV = path.v[0];
              } else {
                closerV = path.v[i2 + 1];
              }
              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = oX;
              oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
              vY = oY;
              iX = vX - (vX - currentV[0]) * roundCorner;
              iY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
            }
          } else {
            clonedPath.setTripleAt(path.v[i2][0], path.v[i2][1], path.o[i2][0], path.o[i2][1], path.i[i2][0], path.i[i2][1], index2);
            index2 += 1;
          }
        }
        return clonedPath;
      };
      RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j;
        var jLen;
        var rd = this.rd.v;
        if (rd !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function floatEqual(a, b) {
        return Math.abs(a - b) * 1e5 <= Math.min(Math.abs(a), Math.abs(b));
      }
      function floatZero(f) {
        return Math.abs(f) <= 1e-5;
      }
      function lerp(p0, p1, amount) {
        return p0 * (1 - amount) + p1 * amount;
      }
      function lerpPoint(p0, p1, amount) {
        return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
      }
      function quadRoots(a, b, c6) {
        if (a === 0) return [];
        var s2 = b * b - 4 * a * c6;
        if (s2 < 0) return [];
        var singleRoot = -b / (2 * a);
        if (s2 === 0) return [singleRoot];
        var delta = Math.sqrt(s2) / (2 * a);
        return [singleRoot - delta, singleRoot + delta];
      }
      function polynomialCoefficients(p0, p1, p2, p3) {
        return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
      }
      function singlePoint(p2) {
        return new PolynomialBezier(p2, p2, p2, p2, false);
      }
      function PolynomialBezier(p0, p1, p2, p3, linearize) {
        if (linearize && pointEqual(p0, p1)) {
          p1 = lerpPoint(p0, p3, 1 / 3);
        }
        if (linearize && pointEqual(p2, p3)) {
          p2 = lerpPoint(p0, p3, 2 / 3);
        }
        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
        this.a = [coeffx[0], coeffy[0]];
        this.b = [coeffx[1], coeffy[1]];
        this.c = [coeffx[2], coeffy[2]];
        this.d = [coeffx[3], coeffy[3]];
        this.points = [p0, p1, p2, p3];
      }
      PolynomialBezier.prototype.point = function(t) {
        return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
      };
      PolynomialBezier.prototype.derivative = function(t) {
        return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
      };
      PolynomialBezier.prototype.tangentAngle = function(t) {
        var p2 = this.derivative(t);
        return Math.atan2(p2[1], p2[0]);
      };
      PolynomialBezier.prototype.normalAngle = function(t) {
        var p2 = this.derivative(t);
        return Math.atan2(p2[0], p2[1]);
      };
      PolynomialBezier.prototype.inflectionPoints = function() {
        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
        if (floatZero(denom)) return [];
        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
        if (square < 0) return [];
        var root2 = Math.sqrt(square);
        if (floatZero(root2)) {
          if (root2 > 0 && root2 < 1) return [tcusp];
          return [];
        }
        return [tcusp - root2, tcusp + root2].filter(function(r) {
          return r > 0 && r < 1;
        });
      };
      PolynomialBezier.prototype.split = function(t) {
        if (t <= 0) return [singlePoint(this.points[0]), this];
        if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
        var p10 = lerpPoint(this.points[0], this.points[1], t);
        var p11 = lerpPoint(this.points[1], this.points[2], t);
        var p12 = lerpPoint(this.points[2], this.points[3], t);
        var p20 = lerpPoint(p10, p11, t);
        var p21 = lerpPoint(p11, p12, t);
        var p3 = lerpPoint(p20, p21, t);
        return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
      };
      function extrema(bez2, comp2) {
        var min = bez2.points[0][comp2];
        var max = bez2.points[bez2.points.length - 1][comp2];
        if (min > max) {
          var e2 = max;
          max = min;
          min = e2;
        }
        var f = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
        for (var i2 = 0; i2 < f.length; i2 += 1) {
          if (f[i2] > 0 && f[i2] < 1) {
            var val2 = bez2.point(f[i2])[comp2];
            if (val2 < min) min = val2;
            else if (val2 > max) max = val2;
          }
        }
        return {
          min,
          max
        };
      }
      PolynomialBezier.prototype.bounds = function() {
        return {
          x: extrema(this, 0),
          y: extrema(this, 1)
        };
      };
      PolynomialBezier.prototype.boundingBox = function() {
        var bounds = this.bounds();
        return {
          left: bounds.x.min,
          right: bounds.x.max,
          top: bounds.y.min,
          bottom: bounds.y.max,
          width: bounds.x.max - bounds.x.min,
          height: bounds.y.max - bounds.y.min,
          cx: (bounds.x.max + bounds.x.min) / 2,
          cy: (bounds.y.max + bounds.y.min) / 2
        };
      };
      function intersectData(bez2, t1, t2) {
        var box = bez2.boundingBox();
        return {
          cx: box.cx,
          cy: box.cy,
          width: box.width,
          height: box.height,
          bez: bez2,
          t: (t1 + t2) / 2,
          t1,
          t2
        };
      }
      function splitData(data2) {
        var split = data2.bez.split(0.5);
        return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
      }
      function boxIntersect(b1, b2) {
        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
      }
      function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
        if (!boxIntersect(d1, d2)) return;
        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
          intersections.push([d1.t, d2.t]);
          return;
        }
        var d1s = splitData(d1);
        var d2s = splitData(d2);
        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      }
      PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
        if (tolerance === void 0) tolerance = 2;
        if (maxRecursion === void 0) maxRecursion = 7;
        var intersections = [];
        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
        return intersections;
      };
      PolynomialBezier.shapeSegment = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
      };
      PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
      };
      function crossProduct(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function lineIntersection(start1, end1, start2, end2) {
        var v1 = [start1[0], start1[1], 1];
        var v2 = [end1[0], end1[1], 1];
        var v3 = [start2[0], start2[1], 1];
        var v4 = [end2[0], end2[1], 1];
        var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
        if (floatZero(r[2])) return null;
        return [r[0] / r[2], r[1] / r[2]];
      }
      function polarOffset(p2, angle, length2) {
        return [p2[0] + Math.cos(angle) * length2, p2[1] - Math.sin(angle) * length2];
      }
      function pointDistance(p1, p2) {
        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
      }
      function pointEqual(p1, p2) {
        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
      }
      function ZigZagModifier() {
      }
      extendPrototype([ShapeModifier], ZigZagModifier);
      ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
        this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
      };
      function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
        var angO = angle - Math.PI / 2;
        var angI = angle + Math.PI / 2;
        var px = point[0] + Math.cos(angle) * direction * amplitude;
        var py = point[1] - Math.sin(angle) * direction * amplitude;
        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
      }
      function getPerpendicularVector(pt1, pt2) {
        var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
        var rot = -Math.PI * 0.5;
        var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
        return rotatedVector;
      }
      function getProjectingAngle(path, cur) {
        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
        var nextIndex = (cur + 1) % path.length();
        var prevPoint = path.v[prevIndex];
        var nextPoint = path.v[nextIndex];
        var pVector = getPerpendicularVector(prevPoint, nextPoint);
        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
      }
      function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
        var angle = getProjectingAngle(path, cur);
        var point = path.v[cur % path._length];
        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
        var nextPoint = path.v[(cur + 1) % path._length];
        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
      }
      function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
        for (var i2 = 0; i2 < frequency; i2 += 1) {
          var t = (i2 + 1) / (frequency + 1);
          var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
          var angle = segment.normalAngle(t);
          var point = segment.point(t);
          setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
          direction = -direction;
        }
        return direction;
      }
      ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
        var count = path._length;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        if (!path.c) {
          count -= 1;
        }
        if (count === 0) return clonedPath;
        var direction = -1;
        var segment = PolynomialBezier.shapeSegment(path, 0);
        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
        for (var i2 = 0; i2 < count; i2 += 1) {
          direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
          if (i2 === count - 1 && !path.c) {
            segment = null;
          } else {
            segment = PolynomialBezier.shapeSegment(path, (i2 + 1) % count);
          }
          zigZagCorner(clonedPath, path, i2 + 1, amplitude, frequency, pointType, direction);
        }
        return clonedPath;
      };
      ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amplitude = this.amplitude.v;
        var frequency = Math.max(0, Math.round(this.frequency.v));
        var pointType = this.pointsType.v;
        if (amplitude !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function linearOffset(p1, p2, amount) {
        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
        return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
      }
      function offsetSegment(segment, amount) {
        var p0;
        var p1a;
        var p1b;
        var p2b;
        var p2a;
        var p3;
        var e2;
        e2 = linearOffset(segment.points[0], segment.points[1], amount);
        p0 = e2[0];
        p1a = e2[1];
        e2 = linearOffset(segment.points[1], segment.points[2], amount);
        p1b = e2[0];
        p2b = e2[1];
        e2 = linearOffset(segment.points[2], segment.points[3], amount);
        p2a = e2[0];
        p3 = e2[1];
        var p1 = lineIntersection(p0, p1a, p1b, p2b);
        if (p1 === null) p1 = p1a;
        var p2 = lineIntersection(p2a, p3, p1b, p2b);
        if (p2 === null) p2 = p2a;
        return new PolynomialBezier(p0, p1, p2, p3);
      }
      function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
        var p0 = seg1.points[3];
        var p1 = seg2.points[0];
        if (lineJoin === 3) return p0;
        if (pointEqual(p0, p1)) return p0;
        if (lineJoin === 2) {
          var angleOut = -seg1.tangentAngle(1);
          var angleIn = -seg2.tangentAngle(0) + Math.PI;
          var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
          var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
          var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
          outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
          tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
          outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
          return p1;
        }
        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
        var intersection = lineIntersection(t0, p0, p1, t1);
        if (intersection && pointDistance(intersection, p0) < miterLimit) {
          outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
          return intersection;
        }
        return p0;
      }
      function getIntersection(a, b) {
        var intersect = a.intersections(b);
        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
        if (intersect.length) return intersect[0];
        return null;
      }
      function pruneSegmentIntersection(a, b) {
        var outa = a.slice();
        var outb = b.slice();
        var intersect = getIntersection(a[a.length - 1], b[0]);
        if (intersect) {
          outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
          outb[0] = b[0].split(intersect[1])[1];
        }
        if (a.length > 1 && b.length > 1) {
          intersect = getIntersection(a[0], b[b.length - 1]);
          if (intersect) {
            return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
          }
        }
        return [outa, outb];
      }
      function pruneIntersections(segments) {
        var e2;
        for (var i2 = 1; i2 < segments.length; i2 += 1) {
          e2 = pruneSegmentIntersection(segments[i2 - 1], segments[i2]);
          segments[i2 - 1] = e2[0];
          segments[i2] = e2[1];
        }
        if (segments.length > 1) {
          e2 = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
          segments[segments.length - 1] = e2[0];
          segments[0] = e2[1];
        }
        return segments;
      }
      function offsetSegmentSplit(segment, amount) {
        var flex = segment.inflectionPoints();
        var left;
        var right;
        var split;
        var mid;
        if (flex.length === 0) {
          return [offsetSegment(segment, amount)];
        }
        if (flex.length === 1 || floatEqual(flex[1], 1)) {
          split = segment.split(flex[0]);
          left = split[0];
          right = split[1];
          return [offsetSegment(left, amount), offsetSegment(right, amount)];
        }
        split = segment.split(flex[0]);
        left = split[0];
        var t = (flex[1] - flex[0]) / (1 - flex[0]);
        split = split[1].split(t);
        mid = split[0];
        right = split[1];
        return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
      }
      function OffsetPathModifier() {
      }
      extendPrototype([ShapeModifier], OffsetPathModifier);
      OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
        this.lineJoin = data2.lj;
        this._isAnimated = this.amount.effectsSequence.length !== 0;
      };
      OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
        var outputBezier = shapePool.newElement();
        outputBezier.c = inputBezier.c;
        var count = inputBezier.length();
        if (!inputBezier.c) {
          count -= 1;
        }
        var i2;
        var j;
        var segment;
        var multiSegments = [];
        for (i2 = 0; i2 < count; i2 += 1) {
          segment = PolynomialBezier.shapeSegment(inputBezier, i2);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
        if (!inputBezier.c) {
          for (i2 = count - 1; i2 >= 0; i2 -= 1) {
            segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i2);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
        }
        multiSegments = pruneIntersections(multiSegments);
        var lastPoint = null;
        var lastSeg = null;
        for (i2 = 0; i2 < multiSegments.length; i2 += 1) {
          var multiSegment = multiSegments[i2];
          if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
          lastSeg = multiSegment[multiSegment.length - 1];
          for (j = 0; j < multiSegment.length; j += 1) {
            segment = multiSegment[j];
            if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
              outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
            } else {
              outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
            }
            outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
            lastPoint = segment.points[3];
          }
        }
        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
        return outputBezier;
      };
      OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i2;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;
        var miterLimit = this.miterLimit.v;
        var lineJoin = this.lineJoin;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapeData = this.shapes[i2];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
        var fWeight = "normal";
        var fStyle = "normal";
        var len = styles.length;
        var styleName;
        for (var i2 = 0; i2 < len; i2 += 1) {
          styleName = styles[i2].toLowerCase();
          switch (styleName) {
            case "italic":
              fStyle = "italic";
              break;
            case "bold":
              fWeight = "700";
              break;
            case "black":
              fWeight = "900";
              break;
            case "medium":
              fWeight = "500";
              break;
            case "regular":
            case "normal":
              fWeight = "400";
              break;
            case "light":
            case "thin":
              fWeight = "200";
              break;
          }
        }
        return {
          style: fStyle,
          weight: fontData.fWeight || fWeight
        };
      }
      var FontManager = function() {
        var maxWaitingTime = 5e3;
        var emptyChar = {
          w: 0,
          size: 0,
          shapes: [],
          data: {
            shapes: []
          }
        };
        var combinedCharacters = [];
        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
        var BLACK_FLAG_CODE_POINT = 127988;
        var CANCEL_TAG_CODE_POINT = 917631;
        var A_TAG_CODE_POINT = 917601;
        var Z_TAG_CODE_POINT = 917626;
        var VARIATION_SELECTOR_16_CODE_POINT = 65039;
        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
        var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function trimFontOptions(font) {
          var familyArray = font.split(",");
          var i2;
          var len = familyArray.length;
          var enabledFamilies = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            if (familyArray[i2] !== "sans-serif" && familyArray[i2] !== "monospace") {
              enabledFamilies.push(familyArray[i2]);
            }
          }
          return enabledFamilies.join(",");
        }
        function setUpNode(font, family) {
          var parentNode = createTag("span");
          parentNode.setAttribute("aria-hidden", true);
          parentNode.style.fontFamily = family;
          var node = createTag("span");
          node.innerText = "giItT1WQy@!-/#";
          parentNode.style.position = "absolute";
          parentNode.style.left = "-10000px";
          parentNode.style.top = "-10000px";
          parentNode.style.fontSize = "300px";
          parentNode.style.fontVariant = "normal";
          parentNode.style.fontStyle = "normal";
          parentNode.style.fontWeight = "normal";
          parentNode.style.letterSpacing = "0";
          parentNode.appendChild(node);
          document.body.appendChild(parentNode);
          var width2 = node.offsetWidth;
          node.style.fontFamily = trimFontOptions(font) + ", " + family;
          return {
            node,
            w: width2,
            parent: parentNode
          };
        }
        function checkLoadedFonts() {
          var i2;
          var len = this.fonts.length;
          var node;
          var w;
          var loadedCount = len;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.fonts[i2].loaded) {
              loadedCount -= 1;
            } else if (this.fonts[i2].fOrigin === "n" || this.fonts[i2].origin === 0) {
              this.fonts[i2].loaded = true;
            } else {
              node = this.fonts[i2].monoCase.node;
              w = this.fonts[i2].monoCase.w;
              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i2].loaded = true;
              } else {
                node = this.fonts[i2].sansCase.node;
                w = this.fonts[i2].sansCase.w;
                if (node.offsetWidth !== w) {
                  loadedCount -= 1;
                  this.fonts[i2].loaded = true;
                }
              }
              if (this.fonts[i2].loaded) {
                this.fonts[i2].sansCase.parent.parentNode.removeChild(this.fonts[i2].sansCase.parent);
                this.fonts[i2].monoCase.parent.parentNode.removeChild(this.fonts[i2].monoCase.parent);
              }
            }
          }
          if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
            setTimeout(this.checkLoadedFontsBinded, 20);
          } else {
            setTimeout(this.setIsLoadedBinded, 10);
          }
        }
        function createHelper(fontData, def) {
          var engine = document.body && def ? "svg" : "canvas";
          var helper;
          var fontProps = getFontProperties(fontData);
          if (engine === "svg") {
            var tHelper = createNS("text");
            tHelper.style.fontSize = "100px";
            tHelper.setAttribute("font-family", fontData.fFamily);
            tHelper.setAttribute("font-style", fontProps.style);
            tHelper.setAttribute("font-weight", fontProps.weight);
            tHelper.textContent = "1";
            if (fontData.fClass) {
              tHelper.style.fontFamily = "inherit";
              tHelper.setAttribute("class", fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            helper = tHelper;
          } else {
            var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
            tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
            helper = tCanvasHelper;
          }
          function measure(text2) {
            if (engine === "svg") {
              helper.textContent = text2;
              return helper.getComputedTextLength();
            }
            return helper.measureText(text2).width;
          }
          return {
            measureText: measure
          };
        }
        function addFonts(fontData, defs) {
          if (!fontData) {
            this.isLoaded = true;
            return;
          }
          if (this.chars) {
            this.isLoaded = true;
            this.fonts = fontData.list;
            return;
          }
          if (!document.body) {
            this.isLoaded = true;
            fontData.list.forEach(function(data2) {
              data2.helper = createHelper(data2);
              data2.cache = {};
            });
            this.fonts = fontData.list;
            return;
          }
          var fontArr = fontData.list;
          var i2;
          var len = fontArr.length;
          var _pendingFonts = len;
          for (i2 = 0; i2 < len; i2 += 1) {
            var shouldLoadFont = true;
            var loadedSelector;
            var j;
            fontArr[i2].loaded = false;
            fontArr[i2].monoCase = setUpNode(fontArr[i2].fFamily, "monospace");
            fontArr[i2].sansCase = setUpNode(fontArr[i2].fFamily, "sans-serif");
            if (!fontArr[i2].fPath) {
              fontArr[i2].loaded = true;
              _pendingFonts -= 1;
            } else if (fontArr[i2].fOrigin === "p" || fontArr[i2].origin === 3) {
              loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i2].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i2].fFamily + '"]');
              if (loadedSelector.length > 0) {
                shouldLoadFont = false;
              }
              if (shouldLoadFont) {
                var s2 = createTag("style");
                s2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                s2.setAttribute("f-origin", fontArr[i2].origin);
                s2.setAttribute("f-family", fontArr[i2].fFamily);
                s2.type = "text/css";
                s2.innerText = "@font-face {font-family: " + fontArr[i2].fFamily + "; font-style: normal; src: url('" + fontArr[i2].fPath + "');}";
                defs.appendChild(s2);
              }
            } else if (fontArr[i2].fOrigin === "g" || fontArr[i2].origin === 1) {
              loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
              for (j = 0; j < loadedSelector.length; j += 1) {
                if (loadedSelector[j].href.indexOf(fontArr[i2].fPath) !== -1) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var l2 = createTag("link");
                l2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                l2.setAttribute("f-origin", fontArr[i2].origin);
                l2.type = "text/css";
                l2.rel = "stylesheet";
                l2.href = fontArr[i2].fPath;
                document.body.appendChild(l2);
              }
            } else if (fontArr[i2].fOrigin === "t" || fontArr[i2].origin === 2) {
              loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
              for (j = 0; j < loadedSelector.length; j += 1) {
                if (fontArr[i2].fPath === loadedSelector[j].src) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var sc = createTag("link");
                sc.setAttribute("f-forigin", fontArr[i2].fOrigin);
                sc.setAttribute("f-origin", fontArr[i2].origin);
                sc.setAttribute("rel", "stylesheet");
                sc.setAttribute("href", fontArr[i2].fPath);
                defs.appendChild(sc);
              }
            }
            fontArr[i2].helper = createHelper(fontArr[i2], defs);
            fontArr[i2].cache = {};
            this.fonts.push(fontArr[i2]);
          }
          if (_pendingFonts === 0) {
            this.isLoaded = true;
          } else {
            setTimeout(this.checkLoadedFonts.bind(this), 100);
          }
        }
        function addChars(chars) {
          if (!chars) {
            return;
          }
          if (!this.chars) {
            this.chars = [];
          }
          var i2;
          var len = chars.length;
          var j;
          var jLen = this.chars.length;
          var found;
          for (i2 = 0; i2 < len; i2 += 1) {
            j = 0;
            found = false;
            while (j < jLen) {
              if (this.chars[j].style === chars[i2].style && this.chars[j].fFamily === chars[i2].fFamily && this.chars[j].ch === chars[i2].ch) {
                found = true;
              }
              j += 1;
            }
            if (!found) {
              this.chars.push(chars[i2]);
              jLen += 1;
            }
          }
        }
        function getCharData(_char, style, font) {
          var i2 = 0;
          var len = this.chars.length;
          while (i2 < len) {
            if (this.chars[i2].ch === _char && this.chars[i2].style === style && this.chars[i2].fFamily === font) {
              return this.chars[i2];
            }
            i2 += 1;
          }
          if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
            this._warned = true;
            console.warn("Missing character from exported characters list: ", _char, style, font);
          }
          return emptyChar;
        }
        function measureText(_char2, fontName, size) {
          var fontData = this.getFontByName(fontName);
          var index2 = _char2;
          if (!fontData.cache[index2]) {
            var tHelper = fontData.helper;
            if (_char2 === " ") {
              var doubleSize = tHelper.measureText("|" + _char2 + "|");
              var singleSize = tHelper.measureText("||");
              fontData.cache[index2] = (doubleSize - singleSize) / 100;
            } else {
              fontData.cache[index2] = tHelper.measureText(_char2) / 100;
            }
          }
          return fontData.cache[index2] * size;
        }
        function getFontByName(name2) {
          var i2 = 0;
          var len = this.fonts.length;
          while (i2 < len) {
            if (this.fonts[i2].fName === name2) {
              return this.fonts[i2];
            }
            i2 += 1;
          }
          return this.fonts[0];
        }
        function getCodePoint(string2) {
          var codePoint = 0;
          var first = string2.charCodeAt(0);
          if (first >= 55296 && first <= 56319) {
            var second = string2.charCodeAt(1);
            if (second >= 56320 && second <= 57343) {
              codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            }
          }
          return codePoint;
        }
        function isModifier(firstCharCode, secondCharCode) {
          var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
          return surrogateModifiers.indexOf(sum2) !== -1;
        }
        function isZeroWidthJoiner(charCode) {
          return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
        }
        function isVariationSelector(charCode) {
          return charCode === VARIATION_SELECTOR_16_CODE_POINT;
        }
        function isRegionalCode(string2) {
          var codePoint = getCodePoint(string2);
          if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
            return true;
          }
          return false;
        }
        function isFlagEmoji(string2) {
          return isRegionalCode(string2.substr(0, 2)) && isRegionalCode(string2.substr(2, 2));
        }
        function isCombinedCharacter(_char3) {
          return combinedCharacters.indexOf(_char3) !== -1;
        }
        function isRegionalFlag(text2, index2) {
          var codePoint = getCodePoint(text2.substr(index2, 2));
          if (codePoint !== BLACK_FLAG_CODE_POINT) {
            return false;
          }
          var count = 0;
          index2 += 2;
          while (count < 5) {
            codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
              return false;
            }
            count += 1;
            index2 += 2;
          }
          return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
        }
        function setIsLoaded() {
          this.isLoaded = true;
        }
        var Font = function Font2() {
          this.fonts = [];
          this.chars = null;
          this.typekitLoaded = 0;
          this.isLoaded = false;
          this._warned = false;
          this.initTime = Date.now();
          this.setIsLoadedBinded = this.setIsLoaded.bind(this);
          this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isFlagEmoji = isFlagEmoji;
        Font.isRegionalCode = isRegionalCode;
        Font.isCombinedCharacter = isCombinedCharacter;
        Font.isRegionalFlag = isRegionalFlag;
        Font.isVariationSelector = isVariationSelector;
        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
        var fontPrototype = {
          addChars,
          addFonts,
          getCharData,
          getFontByName,
          measureText,
          checkLoadedFonts,
          setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
      }();
      function SlotManager(animationData) {
        this.animationData = animationData;
      }
      SlotManager.prototype.getProp = function(data2) {
        if (this.animationData.slots && this.animationData.slots[data2.sid]) {
          return Object.assign(data2, this.animationData.slots[data2.sid].p);
        }
        return data2;
      };
      function slotFactory(animationData) {
        return new SlotManager(animationData);
      }
      function RenderableElement() {
      }
      RenderableElement.prototype = {
        initRenderable: function initRenderable() {
          this.isInRange = false;
          this.hidden = false;
          this.isTransparent = false;
          this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) === -1) {
            this.renderableComponents.push(component);
          }
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) !== -1) {
            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
          }
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
          this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
          if (this.finalTransform.mProp.o.v <= 0) {
            if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
              this.isTransparent = true;
              this.hide();
            }
          } else if (this.isTransparent) {
            this.isTransparent = false;
            this.show();
          }
        },
        /**
           * @function
           * Initializes frame related properties.
           *
           * @param {number} num
           * current frame number in Layer's time
           *
           */
        checkLayerLimits: function checkLayerLimits(num) {
          if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
            if (this.isInRange !== true) {
              this.globalData._mdf = true;
              this._mdf = true;
              this.isInRange = true;
              this.show();
            }
          } else if (this.isInRange !== false) {
            this.globalData._mdf = true;
            this.isInRange = false;
            this.hide();
          }
        },
        renderRenderable: function renderRenderable() {
          var i2;
          var len = this.renderableComponents.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.renderableComponents[i2].renderFrame(this._isFirstFrame);
          }
        },
        sourceRectAtTime: function sourceRectAtTime2() {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100
          };
        },
        getLayerSize: function getLayerSize() {
          if (this.data.ty === 5) {
            return {
              w: this.data.textData.width,
              h: this.data.textData.height
            };
          }
          return {
            w: this.data.width,
            h: this.data.height
          };
        }
      };
      var getBlendMode = /* @__PURE__ */ function() {
        var blendModeEnums = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity"
        };
        return function(mode) {
          return blendModeEnums[mode] || "";
        };
      }();
      function SliderEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function AngleEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function ColorEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function PointEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function LayerIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function MaskIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function CheckboxEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(data2, element) {
        var effects = data2.ef || [];
        this.effectElements = [];
        var i2;
        var len = effects.length;
        var effectItem;
        for (i2 = 0; i2 < len; i2 += 1) {
          effectItem = new GroupEffect(effects[i2], element);
          this.effectElements.push(effectItem);
        }
      }
      function GroupEffect(data2, element) {
        this.init(data2, element);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect);
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
      GroupEffect.prototype.init = function(data2, element) {
        this.data = data2;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i2;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;
        for (i2 = 0; i2 < len; i2 += 1) {
          eff = null;
          switch (effects[i2].ty) {
            case 0:
              eff = new SliderEffect(effects[i2], element, this);
              break;
            case 1:
              eff = new AngleEffect(effects[i2], element, this);
              break;
            case 2:
              eff = new ColorEffect(effects[i2], element, this);
              break;
            case 3:
              eff = new PointEffect(effects[i2], element, this);
              break;
            case 4:
            case 7:
              eff = new CheckboxEffect(effects[i2], element, this);
              break;
            case 10:
              eff = new LayerIndexEffect(effects[i2], element, this);
              break;
            case 11:
              eff = new MaskIndexEffect(effects[i2], element, this);
              break;
            case 5:
              eff = new EffectsManager(effects[i2], element);
              break;
            default:
              eff = new NoValueEffect(effects[i2]);
              break;
          }
          if (eff) {
            this.effectElements.push(eff);
          }
        }
      };
      function BaseElement() {
      }
      BaseElement.prototype = {
        checkMasks: function checkMasks() {
          if (!this.data.hasMask) {
            return false;
          }
          var i2 = 0;
          var len = this.data.masksProperties.length;
          while (i2 < len) {
            if (this.data.masksProperties[i2].mode !== "n" && this.data.masksProperties[i2].cl !== false) {
              return true;
            }
            i2 += 1;
          }
          return false;
        },
        initExpressions: function initExpressions() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var LayerExpressionInterface2 = expressionsInterfaces2("layer");
          var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
          var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
          var TextExpressionInterface2 = expressionsInterfaces2("text");
          var CompExpressionInterface2 = expressionsInterfaces2("comp");
          this.layerInterface = LayerExpressionInterface2(this);
          if (this.data.hasMask && this.maskManager) {
            this.layerInterface.registerMaskInterface(this.maskManager);
          }
          var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(effectsInterface);
          if (this.data.ty === 0 || this.data.xt) {
            this.compInterface = CompExpressionInterface2(this);
          } else if (this.data.ty === 4) {
            this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
            this.layerInterface.content = this.layerInterface.shapeInterface;
          } else if (this.data.ty === 5) {
            this.layerInterface.textInterface = TextExpressionInterface2(this);
            this.layerInterface.text = this.layerInterface.textInterface;
          }
        },
        setBlendMode: function setBlendMode() {
          var blendModeValue = getBlendMode(this.data.bm);
          var elem2 = this.baseElement || this.layerElement;
          elem2.style["mix-blend-mode"] = blendModeValue;
        },
        initBaseData: function initBaseData(data2, globalData2, comp2) {
          this.globalData = globalData2;
          this.comp = comp2;
          this.data = data2;
          this.layerId = createElementID();
          if (!this.data.sr) {
            this.data.sr = 1;
          }
          this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType() {
          return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime2() {
        }
      };
      function FrameElement() {
      }
      FrameElement.prototype = {
        /**
           * @function
           * Initializes frame related properties.
           *
           */
        initFrame: function initFrame2() {
          this._isFirstFrame = false;
          this.dynamicProperties = [];
          this._mdf = false;
        },
        /**
           * @function
           * Calculates all dynamic values
           *
           * @param {number} num
           * current frame number in Layer's time
           * @param {boolean} isVisible
           * if layers is currently in range
           *
           */
        prepareProperties: function prepareProperties(num, isVisible) {
          var i2;
          var len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (isVisible || this._isParent && this.dynamicProperties[i2].propType === "transform") {
              this.dynamicProperties[i2].getValue();
              if (this.dynamicProperties[i2]._mdf) {
                this.globalData._mdf = true;
                this._mdf = true;
              }
            }
          }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
          }
        }
      };
      function FootageElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.footageData = globalData2.imageLoader.getAsset(this.assetData);
        this.initBaseData(data2, globalData2, comp2);
      }
      FootageElement.prototype.prepareFrame = function() {
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
      FootageElement.prototype.getBaseElement = function() {
        return null;
      };
      FootageElement.prototype.renderFrame = function() {
      };
      FootageElement.prototype.destroy = function() {
      };
      FootageElement.prototype.initExpressions = function() {
        var expressionsInterfaces2 = getExpressionInterfaces();
        if (!expressionsInterfaces2) {
          return;
        }
        var FootageInterface2 = expressionsInterfaces2("footage");
        this.layerInterface = FootageInterface2(this);
      };
      FootageElement.prototype.getFootageData = function() {
        return this.footageData;
      };
      function AudioElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initBaseData(data2, globalData2, comp2);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
          k: [100]
        }, 1, 0.01, this);
      }
      AudioElement.prototype.prepareFrame = function(num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          this._currentTime = timeRemapped;
        } else {
          this._currentTime = num / this.data.sr;
        }
        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;
        if (this._previousVolume !== totalVolume) {
          this._previousVolume = totalVolume;
          this.audio.volume(totalVolume);
        }
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
      AudioElement.prototype.renderFrame = function() {
        if (this.isInRange && this._canPlay) {
          if (!this._isPlaying) {
            this.audio.play();
            this.audio.seek(this._currentTime / this.globalData.frameRate);
            this._isPlaying = true;
          } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
            this.audio.seek(this._currentTime / this.globalData.frameRate);
          }
        }
      };
      AudioElement.prototype.show = function() {
      };
      AudioElement.prototype.hide = function() {
        this.audio.pause();
        this._isPlaying = false;
      };
      AudioElement.prototype.pause = function() {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
      };
      AudioElement.prototype.resume = function() {
        this._canPlay = true;
      };
      AudioElement.prototype.setRate = function(rateValue) {
        this.audio.rate(rateValue);
      };
      AudioElement.prototype.volume = function(volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
      };
      AudioElement.prototype.getBaseElement = function() {
        return null;
      };
      AudioElement.prototype.destroy = function() {
      };
      AudioElement.prototype.sourceRectAtTime = function() {
      };
      AudioElement.prototype.initExpressions = function() {
      };
      function BaseRenderer() {
      }
      BaseRenderer.prototype.checkLayers = function(num) {
        var i2;
        var len = this.layers.length;
        var data2;
        this.completeLayers = true;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (!this.elements[i2]) {
            data2 = this.layers[i2];
            if (data2.ip - data2.st <= num - this.layers[i2].st && data2.op - data2.st > num - this.layers[i2].st) {
              this.buildItem(i2);
            }
          }
          this.completeLayers = this.elements[i2] ? this.completeLayers : false;
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.createItem = function(layer) {
        switch (layer.ty) {
          case 2:
            return this.createImage(layer);
          case 0:
            return this.createComp(layer);
          case 1:
            return this.createSolid(layer);
          case 3:
            return this.createNull(layer);
          case 4:
            return this.createShape(layer);
          case 5:
            return this.createText(layer);
          case 6:
            return this.createAudio(layer);
          case 13:
            return this.createCamera(layer);
          case 15:
            return this.createFootage(layer);
          default:
            return this.createNull(layer);
        }
      };
      BaseRenderer.prototype.createCamera = function() {
        throw new Error("You're using a 3d camera. Try the html renderer.");
      };
      BaseRenderer.prototype.createAudio = function(data2) {
        return new AudioElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.createFootage = function(data2) {
        return new FootageElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.buildAllItems = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.buildItem(i2);
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.includeLayers = function(newLayers) {
        this.completeLayers = false;
        var i2;
        var len = newLayers.length;
        var j;
        var jLen = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          j = 0;
          while (j < jLen) {
            if (this.layers[j].id === newLayers[i2].id) {
              this.layers[j] = newLayers[i2];
              break;
            }
            j += 1;
          }
        }
      };
      BaseRenderer.prototype.setProjectInterface = function(pInterface) {
        this.globalData.projectInterface = pInterface;
      };
      BaseRenderer.prototype.initItems = function() {
        if (!this.globalData.progressiveLoad) {
          this.buildAllItems();
        }
      };
      BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i2 = 0;
        var len = layers.length;
        while (i2 < len) {
          if (layers[i2].ind == parentName) {
            if (!elements[i2] || elements[i2] === true) {
              this.buildItem(i2);
              this.addPendingElement(element);
            } else {
              hierarchy.push(elements[i2]);
              elements[i2].setAsParent();
              if (layers[i2].parent !== void 0) {
                this.buildElementParenting(element, layers[i2].parent, hierarchy);
              } else {
                element.setHierarchy(hierarchy);
              }
            }
          }
          i2 += 1;
        }
      };
      BaseRenderer.prototype.addPendingElement = function(element) {
        this.pendingElements.push(element);
      };
      BaseRenderer.prototype.searchExtraCompositions = function(assets) {
        var i2;
        var len = assets.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (assets[i2].xt) {
            var comp2 = this.createComp(assets[i2]);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      BaseRenderer.prototype.getElementById = function(ind) {
        var i2;
        var len = this.elements.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2].data.ind === ind) {
            return this.elements[i2];
          }
        }
        return null;
      };
      BaseRenderer.prototype.getElementByPath = function(path) {
        var pathValue = path.shift();
        var element;
        if (typeof pathValue === "number") {
          element = this.elements[pathValue];
        } else {
          var i2;
          var len = this.elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2].data.nm === pathValue) {
              element = this.elements[i2];
              break;
            }
          }
        }
        if (path.length === 0) {
          return element;
        }
        return element.getElementByPath(path);
      };
      BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.slotManager = slotFactory(animData);
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
          w: animData.w,
          h: animData.h
        };
      };
      var effectTypes = {
        TRANSFORM_EFFECT: "transformEFfect"
      };
      function TransformElement() {
      }
      TransformElement.prototype = {
        initTransform: function initTransform() {
          var mat = new Matrix();
          this.finalTransform = {
            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
              o: 0
            },
            _matMdf: false,
            _localMatMdf: false,
            _opMdf: false,
            mat,
            localMat: mat,
            localOpacity: 1
          };
          if (this.data.ao) {
            this.finalTransform.mProp.autoOriented = true;
          }
          if (this.data.ty !== 11) ;
        },
        renderTransform: function renderTransform() {
          this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
          this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
          if (this.hierarchy) {
            var mat;
            var finalMat = this.finalTransform.mat;
            var i2 = 0;
            var len = this.hierarchy.length;
            if (!this.finalTransform._matMdf) {
              while (i2 < len) {
                if (this.hierarchy[i2].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = true;
                  break;
                }
                i2 += 1;
              }
            }
            if (this.finalTransform._matMdf) {
              mat = this.finalTransform.mProp.v.props;
              finalMat.cloneFromProps(mat);
              for (i2 = 0; i2 < len; i2 += 1) {
                finalMat.multiply(this.hierarchy[i2].finalTransform.mProp.v);
              }
            }
          }
          if (this.finalTransform._matMdf) {
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          }
          if (this.finalTransform._opMdf) {
            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
          }
        },
        renderLocalTransform: function renderLocalTransform() {
          if (this.localTransforms) {
            var i2 = 0;
            var len = this.localTransforms.length;
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
              while (i2 < len) {
                if (this.localTransforms[i2]._mdf) {
                  this.finalTransform._localMatMdf = true;
                }
                if (this.localTransforms[i2]._opMdf && !this.finalTransform._opMdf) {
                  this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                  this.finalTransform._opMdf = true;
                }
                i2 += 1;
              }
            }
            if (this.finalTransform._localMatMdf) {
              var localMat = this.finalTransform.localMat;
              this.localTransforms[0].matrix.clone(localMat);
              for (i2 = 1; i2 < len; i2 += 1) {
                var lmat = this.localTransforms[i2].matrix;
                localMat.multiply(lmat);
              }
              localMat.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var localOp = this.finalTransform.localOpacity;
              for (i2 = 0; i2 < len; i2 += 1) {
                localOp *= this.localTransforms[i2].opacity * 0.01;
              }
              this.finalTransform.localOpacity = localOp;
            }
          }
        },
        searchEffectTransforms: function searchEffectTransforms() {
          if (this.renderableEffectsManager) {
            var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
            if (transformEffects.length) {
              this.localTransforms = [];
              this.finalTransform.localMat = new Matrix();
              var i2 = 0;
              var len = transformEffects.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.localTransforms.push(transformEffects[i2]);
              }
            }
          }
        },
        globalToLocal: function globalToLocal(pt) {
          var transforms = [];
          transforms.push(this.finalTransform);
          var flag = true;
          var comp2 = this.comp;
          while (flag) {
            if (comp2.finalTransform) {
              if (comp2.data.hasMask) {
                transforms.splice(0, 0, comp2.finalTransform);
              }
              comp2 = comp2.comp;
            } else {
              flag = false;
            }
          }
          var i2;
          var len = transforms.length;
          var ptNew;
          for (i2 = 0; i2 < len; i2 += 1) {
            ptNew = transforms[i2].mat.applyToPointArray(0, 0, 0);
            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
          }
          return pt;
        },
        mHelper: new Matrix()
      };
      function MaskElement(data2, element, globalData2) {
        this.data = data2;
        this.element = element;
        this.globalData = globalData2;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i2;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = "";
        var path;
        var properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x;
        var maskType = "clipPath";
        var maskRef = "clip-path";
        for (i2 = 0; i2 < len; i2 += 1) {
          if (properties[i2].mode !== "a" && properties[i2].mode !== "n" || properties[i2].inv || properties[i2].o.k !== 100 || properties[i2].o.x) {
            maskType = "mask";
            maskRef = "mask";
          }
          if ((properties[i2].mode === "s" || properties[i2].mode === "i") && count === 0) {
            rect = createNS("rect");
            rect.setAttribute("fill", "#ffffff");
            rect.setAttribute("width", this.element.comp.data.w || 0);
            rect.setAttribute("height", this.element.comp.data.h || 0);
            currentMasks.push(rect);
          } else {
            rect = null;
          }
          path = createNS("path");
          if (properties[i2].mode === "n") {
            this.viewData[i2] = {
              op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
              elem: path,
              lastPath: ""
            };
            defs.appendChild(path);
          } else {
            count += 1;
            path.setAttribute("fill", properties[i2].mode === "s" ? "#000000" : "#ffffff");
            path.setAttribute("clip-rule", "nonzero");
            var filterID;
            if (properties[i2].x.k !== 0) {
              maskType = "mask";
              maskRef = "mask";
              x = PropertyFactory.getProp(this.element, properties[i2].x, 0, null, this.element);
              filterID = createElementID();
              expansor = createNS("filter");
              expansor.setAttribute("id", filterID);
              feMorph = createNS("feMorphology");
              feMorph.setAttribute("operator", "erode");
              feMorph.setAttribute("in", "SourceGraphic");
              feMorph.setAttribute("radius", "0");
              expansor.appendChild(feMorph);
              defs.appendChild(expansor);
              path.setAttribute("stroke", properties[i2].mode === "s" ? "#000000" : "#ffffff");
            } else {
              feMorph = null;
              x = null;
            }
            this.storedData[i2] = {
              elem: path,
              x,
              expan: feMorph,
              lastPath: "",
              lastOperator: "",
              filterId: filterID,
              lastRadius: 0
            };
            if (properties[i2].mode === "i") {
              jLen = currentMasks.length;
              var g = createNS("g");
              for (j = 0; j < jLen; j += 1) {
                g.appendChild(currentMasks[j]);
              }
              var mask2 = createNS("mask");
              mask2.setAttribute("mask-type", "alpha");
              mask2.setAttribute("id", layerId + "_" + count);
              mask2.appendChild(path);
              defs.appendChild(mask2);
              g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
              currentMasks.length = 0;
              currentMasks.push(g);
            } else {
              currentMasks.push(path);
            }
            if (properties[i2].inv && !this.solidPath) {
              this.solidPath = this.createLayerSolidPath();
            }
            this.viewData[i2] = {
              elem: path,
              lastPath: "",
              op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
              invRect: rect
            };
            if (!this.viewData[i2].prop.k) {
              this.drawPath(properties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
            }
          }
        }
        this.maskElement = createNS(maskType);
        len = currentMasks.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.maskElement.appendChild(currentMasks[i2]);
        }
        if (count > 0) {
          this.maskElement.setAttribute("id", layerId);
          this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
          defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) {
          this.element.addRenderableComponent(this);
        }
      }
      MaskElement.prototype.getMaskProperty = function(pos) {
        return this.viewData[pos].prop;
      };
      MaskElement.prototype.renderFrame = function(isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i2;
        var len = this.masksProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.viewData[i2].prop._mdf || isFirstFrame) {
            this.drawPath(this.masksProperties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
          }
          if (this.viewData[i2].op._mdf || isFirstFrame) {
            this.viewData[i2].elem.setAttribute("fill-opacity", this.viewData[i2].op.v);
          }
          if (this.masksProperties[i2].mode !== "n") {
            if (this.viewData[i2].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
              this.viewData[i2].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
            }
            if (this.storedData[i2].x && (this.storedData[i2].x._mdf || isFirstFrame)) {
              var feMorph = this.storedData[i2].expan;
              if (this.storedData[i2].x.v < 0) {
                if (this.storedData[i2].lastOperator !== "erode") {
                  this.storedData[i2].lastOperator = "erode";
                  this.storedData[i2].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i2].filterId + ")");
                }
                feMorph.setAttribute("radius", -this.storedData[i2].x.v);
              } else {
                if (this.storedData[i2].lastOperator !== "dilate") {
                  this.storedData[i2].lastOperator = "dilate";
                  this.storedData[i2].elem.setAttribute("filter", null);
                }
                this.storedData[i2].elem.setAttribute("stroke-width", this.storedData[i2].x.v * 2);
              }
            }
          }
        }
      };
      MaskElement.prototype.getMaskelement = function() {
        return this.maskElement;
      };
      MaskElement.prototype.createLayerSolidPath = function() {
        var path = "M0,0 ";
        path += " h" + this.globalData.compSize.w;
        path += " v" + this.globalData.compSize.h;
        path += " h-" + this.globalData.compSize.w;
        path += " v-" + this.globalData.compSize.h + " ";
        return path;
      };
      MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
        var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        var i2;
        var len;
        len = pathNodes._length;
        for (i2 = 1; i2 < len; i2 += 1) {
          pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[i2][0] + "," + pathNodes.i[i2][1] + " " + pathNodes.v[i2][0] + "," + pathNodes.v[i2][1];
        }
        if (pathNodes.c && len > 1) {
          pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        }
        if (viewData.lastPath !== pathString) {
          var pathShapeValue = "";
          if (viewData.elem) {
            if (pathNodes.c) {
              pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
            }
            viewData.elem.setAttribute("d", pathShapeValue);
          }
          viewData.lastPath = pathString;
        }
      };
      MaskElement.prototype.destroy = function() {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
      };
      var filtersFactory = function() {
        var ob2 = {};
        ob2.createFilter = createFilter;
        ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
        function createFilter(filId, skipCoordinates) {
          var fil = createNS("filter");
          fil.setAttribute("id", filId);
          if (skipCoordinates !== true) {
            fil.setAttribute("filterUnits", "objectBoundingBox");
            fil.setAttribute("x", "0%");
            fil.setAttribute("y", "0%");
            fil.setAttribute("width", "100%");
            fil.setAttribute("height", "100%");
          }
          return fil;
        }
        function createAlphaToLuminanceFilter() {
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
          return feColorMatrix;
        }
        return ob2;
      }();
      var featureSupport = function() {
        var ob2 = {
          maskType: true,
          svgLumaHidden: true,
          offscreenCanvas: typeof OffscreenCanvas !== "undefined"
        };
        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
          ob2.maskType = false;
        }
        if (/firefox/i.test(navigator.userAgent)) {
          ob2.svgLumaHidden = false;
        }
        return ob2;
      }();
      var registeredEffects$1 = {};
      var idPrefix = "filter_result_";
      function SVGEffects(elem2) {
        var i2;
        var source = "SourceGraphic";
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count = 0;
        this.filters = [];
        var filterManager;
        for (i2 = 0; i2 < len; i2 += 1) {
          filterManager = null;
          var type2 = elem2.data.ef[i2].ty;
          if (registeredEffects$1[type2]) {
            var Effect = registeredEffects$1[type2].effect;
            filterManager = new Effect(fil, elem2.effectsManager.effectElements[i2], elem2, idPrefix + count, source);
            source = idPrefix + count;
            if (registeredEffects$1[type2].countsAsEffect) {
              count += 1;
            }
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (count) {
          elem2.globalData.defs.appendChild(fil);
          elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i2;
        var len = this.filters.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.filters[i2].renderFrame(_isFirstFrame);
        }
      };
      SVGEffects.prototype.getEffects = function(type2) {
        var i2;
        var len = this.filters.length;
        var effects = [];
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.filters[i2].type === type2) {
            effects.push(this.filters[i2]);
          }
        }
        return effects;
      };
      function registerEffect$1(id, effect2, countsAsEffect) {
        registeredEffects$1[id] = {
          effect: effect2,
          countsAsEffect
        };
      }
      function SVGBaseElement() {
      }
      SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
          this.layerElement = createNS("g");
        },
        createContainerElements: function createContainerElements() {
          this.matteElement = createNS("g");
          this.transformedElement = this.layerElement;
          this.maskedElement = this.layerElement;
          this._sizeChanged = false;
          var layerElementParent = null;
          if (this.data.td) {
            this.matteMasks = {};
            var gg = createNS("g");
            gg.setAttribute("id", this.layerId);
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            this.globalData.defs.appendChild(gg);
          } else if (this.data.tt) {
            this.matteElement.appendChild(this.layerElement);
            layerElementParent = this.matteElement;
            this.baseElement = this.matteElement;
          } else {
            this.baseElement = this.layerElement;
          }
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.ty === 0 && !this.data.hd) {
            var cp = createNS("clipPath");
            var pt = createNS("path");
            pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
            var clipId = createElementID();
            cp.setAttribute("id", clipId);
            cp.appendChild(pt);
            this.globalData.defs.appendChild(cp);
            if (this.checkMasks()) {
              var cpGroup = createNS("g");
              cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              cpGroup.appendChild(this.layerElement);
              this.transformedElement = cpGroup;
              if (layerElementParent) {
                layerElementParent.appendChild(this.transformedElement);
              } else {
                this.baseElement = this.transformedElement;
              }
            } else {
              this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            }
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          if (this.finalTransform._localMatMdf) {
            this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
          }
          if (this.finalTransform._opMdf) {
            this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
          }
        },
        destroyBaseElement: function destroyBaseElement() {
          this.layerElement = null;
          this.matteElement = null;
          this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
          if (this.data.hd) {
            return null;
          }
          return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
          this.renderableEffectsManager = new SVGEffects(this);
          this.searchEffectTransforms();
        },
        getMatte: function getMatte(matteType) {
          if (!this.matteMasks) {
            this.matteMasks = {};
          }
          if (!this.matteMasks[matteType]) {
            var id = this.layerId + "_" + matteType;
            var filId;
            var fil;
            var useElement;
            var gg;
            if (matteType === 1 || matteType === 3) {
              var masker = createNS("mask");
              masker.setAttribute("id", id);
              masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              masker.appendChild(useElement);
              this.globalData.defs.appendChild(masker);
              if (!featureSupport.maskType && matteType === 1) {
                masker.setAttribute("mask-type", "luminance");
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                this.globalData.defs.appendChild(fil);
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                gg.appendChild(useElement);
                masker.appendChild(gg);
                gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              }
            } else if (matteType === 2) {
              var maskGroup = createNS("mask");
              maskGroup.setAttribute("id", id);
              maskGroup.setAttribute("mask-type", "alpha");
              var maskGrouper = createNS("g");
              maskGroup.appendChild(maskGrouper);
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              var feCTr = createNS("feComponentTransfer");
              feCTr.setAttribute("in", "SourceGraphic");
              fil.appendChild(feCTr);
              var feFunc = createNS("feFuncA");
              feFunc.setAttribute("type", "table");
              feFunc.setAttribute("tableValues", "1.0 0.0");
              feCTr.appendChild(feFunc);
              this.globalData.defs.appendChild(fil);
              var alphaRect = createNS("rect");
              alphaRect.setAttribute("width", this.comp.data.w);
              alphaRect.setAttribute("height", this.comp.data.h);
              alphaRect.setAttribute("x", "0");
              alphaRect.setAttribute("y", "0");
              alphaRect.setAttribute("fill", "#ffffff");
              alphaRect.setAttribute("opacity", "0");
              maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              maskGrouper.appendChild(alphaRect);
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              maskGrouper.appendChild(useElement);
              if (!featureSupport.maskType) {
                maskGroup.setAttribute("mask-type", "luminance");
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                maskGrouper.appendChild(alphaRect);
                gg.appendChild(this.layerElement);
                maskGrouper.appendChild(gg);
              }
              this.globalData.defs.appendChild(maskGroup);
            }
            this.matteMasks[matteType] = id;
          }
          return this.matteMasks[matteType];
        },
        setMatte: function setMatte(id) {
          if (!this.matteElement) {
            return;
          }
          this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        }
      };
      function HierarchyElement() {
      }
      HierarchyElement.prototype = {
        /**
           * @function
           * Initializes hierarchy properties
           *
           */
        initHierarchy: function initHierarchy() {
          this.hierarchy = [];
          this._isParent = false;
          this.checkParenting();
        },
        /**
           * @function
           * Sets layer's hierarchy.
           * @param {array} hierarch
           * layer's parent list
           *
           */
        setHierarchy: function setHierarchy(hierarchy) {
          this.hierarchy = hierarchy;
        },
        /**
           * @function
           * Sets layer as parent.
           *
           */
        setAsParent: function setAsParent() {
          this._isParent = true;
        },
        /**
           * @function
           * Searches layer's parenting chain
           *
           */
        checkParenting: function checkParenting() {
          if (this.data.parent !== void 0) {
            this.comp.buildElementParenting(this, this.data.parent, []);
          }
        }
      };
      function RenderableDOMElement() {
      }
      (function() {
        var _prototype = {
          initElement: function initElement(data2, globalData2, comp2) {
            this.initFrame();
            this.initBaseData(data2, globalData2, comp2);
            this.initTransform(data2, globalData2, comp2);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
          },
          hide: function hide() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var elem2 = this.baseElement || this.layerElement;
              elem2.style.display = "none";
              this.hidden = true;
            }
          },
          show: function show2() {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "block";
              }
              this.hidden = false;
              this._isFirstFrame = true;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          renderInnerContent: function renderInnerContent() {
          },
          prepareFrame: function prepareFrame(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            this.checkTransparency();
          },
          destroy: function destroy() {
            this.innerElem = null;
            this.destroyBaseElement();
          }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
      })();
      function IImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        if (this.assetData && this.assetData.sid) {
          this.assetData = globalData2.slotManager.getProp(this.assetData);
        }
        this.initElement(data2, globalData2, comp2);
        this.sourceRect = {
          top: 0,
          left: 0,
          width: this.assetData.w,
          height: this.assetData.h
        };
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
      IImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS("image");
        this.innerElem.setAttribute("width", this.assetData.w + "px");
        this.innerElem.setAttribute("height", this.assetData.h + "px");
        this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.innerElem);
      };
      IImageElement.prototype.sourceRectAtTime = function() {
        return this.sourceRect;
      };
      function ProcessedElement(element, position2) {
        this.elem = element;
        this.pos = position2;
      }
      function IShapeElement() {
      }
      IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data2) {
          var i2;
          var len = this.shapeModifiers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapeModifiers[i2].addShape(data2);
          }
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
          var i2 = 0;
          var len = this.shapeModifiers.length;
          while (i2 < len) {
            if (this.shapeModifiers[i2].isAnimatedWithShape(data2)) {
              return true;
            }
          }
          return false;
        },
        renderModifiers: function renderModifiers() {
          if (!this.shapeModifiers.length) {
            return;
          }
          var i2;
          var len = this.shapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.shapes[i2].sh.reset();
          }
          len = this.shapeModifiers.length;
          var shouldBreakProcess;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            shouldBreakProcess = this.shapeModifiers[i2].processShapes(this._isFirstFrame);
            if (shouldBreakProcess) {
              break;
            }
          }
        },
        searchProcessedElement: function searchProcessedElement(elem2) {
          var elements = this.processedElements;
          var i2 = 0;
          var len = elements.length;
          while (i2 < len) {
            if (elements[i2].elem === elem2) {
              return elements[i2].pos;
            }
            i2 += 1;
          }
          return 0;
        },
        addProcessedElement: function addProcessedElement(elem2, pos) {
          var elements = this.processedElements;
          var i2 = elements.length;
          while (i2) {
            i2 -= 1;
            if (elements[i2].elem === elem2) {
              elements[i2].pos = pos;
              return;
            }
          }
          elements.push(new ProcessedElement(elem2, pos));
        },
        prepareFrame: function prepareFrame(num) {
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        }
      };
      var lineCapEnum = {
        1: "butt",
        2: "round",
        3: "square"
      };
      var lineJoinEnum = {
        1: "miter",
        2: "round",
        3: "bevel"
      };
      function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = "";
        this.sh = shape;
        this.lvl = level;
        this._isAnimated = !!shape.k;
        var i2 = 0;
        var len = transformers.length;
        while (i2 < len) {
          if (transformers[i2].mProps.dynamicProperties.length) {
            this._isAnimated = true;
            break;
          }
          i2 += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
      };
      function SVGStyleData(data2, level) {
        this.data = data2;
        this.type = data2.ty;
        this.d = "";
        this.lvl = level;
        this._mdf = false;
        this.closed = data2.hd === true;
        this.pElem = createNS("path");
        this.msElem = null;
      }
      SVGStyleData.prototype.reset = function() {
        this.d = "";
        this._mdf = false;
      };
      function DashProperty(elem2, data2, renderer, container) {
        this.elem = elem2;
        this.frameId = -1;
        this.dataProps = createSizedArray(data2.length);
        this.renderer = renderer;
        this.k = false;
        this.dashStr = "";
        this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
        this.dashoffset = createTypedArray("float32", 1);
        this.initDynamicPropertyContainer(container);
        var i2;
        var len = data2.length || 0;
        var prop;
        for (i2 = 0; i2 < len; i2 += 1) {
          prop = PropertyFactory.getProp(elem2, data2[i2].v, 0, 0, this);
          this.k = prop.k || this.k;
          this.dataProps[i2] = {
            n: data2[i2].n,
            p: prop
          };
        }
        if (!this.k) {
          this.getValue(true);
        }
        this._isAnimated = this.k;
      }
      DashProperty.prototype.getValue = function(forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
          var i2 = 0;
          var len = this.dataProps.length;
          if (this.renderer === "svg") {
            this.dashStr = "";
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.dataProps[i2].n !== "o") {
              if (this.renderer === "svg") {
                this.dashStr += " " + this.dataProps[i2].p.v;
              } else {
                this.dashArray[i2] = this.dataProps[i2].p.v;
              }
            } else {
              this.dashoffset[0] = this.dataProps[i2].p.v;
            }
          }
        }
      };
      extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(elem2, data2, container) {
        this.data = data2;
        this.c = createTypedArray("uint8c", data2.p * 4);
        var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
        this.o = createTypedArray("float32", cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
      }
      GradientProperty.prototype.comparePoints = function(values, points) {
        var i2 = 0;
        var len = this.o.length / 2;
        var diff;
        while (i2 < len) {
          diff = Math.abs(values[i2 * 4] - values[points * 4 + i2 * 2]);
          if (diff > 0.01) {
            return false;
          }
          i2 += 1;
        }
        return true;
      };
      GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length / 2 !== this.c.length / 4) {
          return false;
        }
        if (this.data.k.k[0].s) {
          var i2 = 0;
          var len = this.data.k.k.length;
          while (i2 < len) {
            if (!this.comparePoints(this.data.k.k[i2].s, this.data.p)) {
              return false;
            }
            i2 += 1;
          }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
          return false;
        }
        return true;
      };
      GradientProperty.prototype.getValue = function(forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if (this.prop._mdf || forceRender) {
          var i2;
          var len = this.data.p * 4;
          var mult;
          var val2;
          for (i2 = 0; i2 < len; i2 += 1) {
            mult = i2 % 4 === 0 ? 100 : 255;
            val2 = Math.round(this.prop.v[i2] * mult);
            if (this.c[i2] !== val2) {
              this.c[i2] = val2;
              this._cmdf = !forceRender;
            }
          }
          if (this.o.length) {
            len = this.prop.v.length;
            for (i2 = this.data.p * 4; i2 < len; i2 += 1) {
              mult = i2 % 2 === 0 ? 100 : 1;
              val2 = i2 % 2 === 0 ? Math.round(this.prop.v[i2] * 100) : this.prop.v[i2];
              if (this.o[i2 - this.data.p * 4] !== val2) {
                this.o[i2 - this.data.p * 4] = val2;
                this._omdf = !forceRender;
              }
            }
          }
          this._mdf = !forceRender;
        }
      };
      extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem2, data2, styleOb);
      }
      SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem2, data2.h || {
          k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem2, data2.a || {
          k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem2, data2.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data2);
        this.setGradientOpacity(data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      };
      SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
        var gradientId = createElementID();
        var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
        gfill.setAttribute("id", gradientId);
        gfill.setAttribute("spreadMethod", "pad");
        gfill.setAttribute("gradientUnits", "userSpaceOnUse");
        var stops = [];
        var stop2;
        var j;
        var jLen;
        jLen = data2.g.p * 4;
        for (j = 0; j < jLen; j += 4) {
          stop2 = createNS("stop");
          gfill.appendChild(stop2);
          stops.push(stop2);
        }
        pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
        this.gf = gfill;
        this.cst = stops;
      };
      SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
          var stop2;
          var j;
          var jLen;
          var mask2 = createNS("mask");
          var maskElement = createNS("path");
          mask2.appendChild(maskElement);
          var opacityId = createElementID();
          var maskId = createElementID();
          mask2.setAttribute("id", maskId);
          var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          opFill.setAttribute("id", opacityId);
          opFill.setAttribute("spreadMethod", "pad");
          opFill.setAttribute("gradientUnits", "userSpaceOnUse");
          jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
          var stops = this.stops;
          for (j = data2.g.p * 4; j < jLen; j += 2) {
            stop2 = createNS("stop");
            stop2.setAttribute("stop-color", "rgb(255,255,255)");
            opFill.appendChild(stop2);
            stops.push(stop2);
          }
          maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
          if (data2.ty === "gs") {
            maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            if (data2.lj === 1) {
              maskElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          this.of = opFill;
          this.ms = mask2;
          this.ost = stops;
          this.maskId = maskId;
          styleOb.msElem = maskElement;
        }
      };
      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.initGradientData(elem2, data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
      function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS("g");
      }
      function SVGTransformData(mProps, op, container) {
        this.transform = {
          mProps,
          op,
          container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
      }
      var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
        if (length2 === 0) {
          return "";
        }
        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i2;
        var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        for (i2 = 1; i2 < length2; i2 += 1) {
          shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[i2][0], _i[i2][1]) + " " + mat.applyToPointStringified(_v[i2][0], _v[i2][1]);
        }
        if (closed && length2) {
          shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          shapeString += "z";
        }
        return shapeString;
      };
      var SVGElementsRenderer = function() {
        var _identityMatrix = new Matrix();
        var _matrixHelper = new Matrix();
        var ob2 = {
          createRenderFunction
        };
        function createRenderFunction(data2) {
          switch (data2.ty) {
            case "fl":
              return renderFill;
            case "gf":
              return renderGradient;
            case "gs":
              return renderGradientStroke;
            case "st":
              return renderStroke;
            case "sh":
            case "el":
            case "rc":
            case "sr":
              return renderPath;
            case "tr":
              return renderContentTransform;
            case "no":
              return renderNoop;
            default:
              return null;
          }
        }
        function renderContentTransform(styleData, itemData, isFirstFrame) {
          if (isFirstFrame || itemData.transform.op._mdf) {
            itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
          }
          if (isFirstFrame || itemData.transform.mProps._mdf) {
            itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
          }
        }
        function renderNoop() {
        }
        function renderPath(styleData, itemData, isFirstFrame) {
          var j;
          var jLen;
          var pathStringTransformed;
          var redraw;
          var pathNodes;
          var l2;
          var lLen = itemData.styles.length;
          var lvl = itemData.lvl;
          var paths;
          var mat;
          var iterations;
          var k;
          for (l2 = 0; l2 < lLen; l2 += 1) {
            redraw = itemData.sh._mdf || isFirstFrame;
            if (itemData.styles[l2].lvl < lvl) {
              mat = _matrixHelper.reset();
              iterations = lvl - itemData.styles[l2].lvl;
              k = itemData.transformers.length - 1;
              while (!redraw && iterations > 0) {
                redraw = itemData.transformers[k].mProps._mdf || redraw;
                iterations -= 1;
                k -= 1;
              }
              if (redraw) {
                iterations = lvl - itemData.styles[l2].lvl;
                k = itemData.transformers.length - 1;
                while (iterations > 0) {
                  mat.multiply(itemData.transformers[k].mProps.v);
                  iterations -= 1;
                  k -= 1;
                }
              }
            } else {
              mat = _identityMatrix;
            }
            paths = itemData.sh.paths;
            jLen = paths._length;
            if (redraw) {
              pathStringTransformed = "";
              for (j = 0; j < jLen; j += 1) {
                pathNodes = paths.shapes[j];
                if (pathNodes && pathNodes._length) {
                  pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                }
              }
              itemData.caches[l2] = pathStringTransformed;
            } else {
              pathStringTransformed = itemData.caches[l2];
            }
            itemData.styles[l2].d += styleData.hd === true ? "" : pathStringTransformed;
            itemData.styles[l2]._mdf = redraw || itemData.styles[l2]._mdf;
          }
        }
        function renderFill(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
          }
        }
        function renderGradientStroke(styleData, itemData, isFirstFrame) {
          renderGradient(styleData, itemData, isFirstFrame);
          renderStroke(styleData, itemData, isFirstFrame);
        }
        function renderGradient(styleData, itemData, isFirstFrame) {
          var gfill = itemData.gf;
          var hasOpacity = itemData.g._hasOpacity;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (itemData.o._mdf || isFirstFrame) {
            var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
            itemData.style.pElem.setAttribute(attr, itemData.o.v);
          }
          if (itemData.s._mdf || isFirstFrame) {
            var attr1 = styleData.t === 1 ? "x1" : "cx";
            var attr2 = attr1 === "x1" ? "y1" : "cy";
            gfill.setAttribute(attr1, pt1[0]);
            gfill.setAttribute(attr2, pt1[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute(attr1, pt1[0]);
              itemData.of.setAttribute(attr2, pt1[1]);
            }
          }
          var stops;
          var i2;
          var len;
          var stop2;
          if (itemData.g._cmdf || isFirstFrame) {
            stops = itemData.cst;
            var cValues = itemData.g.c;
            len = stops.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              stop2 = stops[i2];
              stop2.setAttribute("offset", cValues[i2 * 4] + "%");
              stop2.setAttribute("stop-color", "rgb(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + ")");
            }
          }
          if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
            var oValues = itemData.g.o;
            if (itemData.g._collapsable) {
              stops = itemData.cst;
            } else {
              stops = itemData.ost;
            }
            len = stops.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              stop2 = stops[i2];
              if (!itemData.g._collapsable) {
                stop2.setAttribute("offset", oValues[i2 * 2] + "%");
              }
              stop2.setAttribute("stop-opacity", oValues[i2 * 2 + 1]);
            }
          }
          if (styleData.t === 1) {
            if (itemData.e._mdf || isFirstFrame) {
              gfill.setAttribute("x2", pt2[0]);
              gfill.setAttribute("y2", pt2[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("x2", pt2[0]);
                itemData.of.setAttribute("y2", pt2[1]);
              }
            }
          } else {
            var rad;
            if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              gfill.setAttribute("r", rad);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("r", rad);
              }
            }
            if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
              if (!rad) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              }
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              gfill.setAttribute("fx", x);
              gfill.setAttribute("fy", y);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("fx", x);
                itemData.of.setAttribute("fy", y);
              }
            }
          }
        }
        function renderStroke(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          var d2 = itemData.d;
          if (d2 && (d2._mdf || isFirstFrame) && d2.dashStr) {
            styleElem.pElem.setAttribute("stroke-dasharray", d2.dashStr);
            styleElem.pElem.setAttribute("stroke-dashoffset", d2.dashoffset[0]);
          }
          if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
            styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
          }
          if (itemData.w._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
            if (styleElem.msElem) {
              styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
            }
          }
        }
        return ob2;
      }();
      function SVGShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
      SVGShapeElement.prototype.initSecondaryElement = function() {
      };
      SVGShapeElement.prototype.identityMatrix = new Matrix();
      SVGShapeElement.prototype.buildExpressionInterface = function() {
      };
      SVGShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
      };
      SVGShapeElement.prototype.filterUniqueShapes = function() {
        var i2;
        var len = this.shapes.length;
        var shape;
        var j;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for (j = 0; j < jLen; j += 1) {
          style = this.stylesList[j];
          areAnimated = false;
          tempShapes.length = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            shape = this.shapes[i2];
            if (shape.styles.indexOf(style) !== -1) {
              tempShapes.push(shape);
              areAnimated = shape._isAnimated || areAnimated;
            }
          }
          if (tempShapes.length > 1 && areAnimated) {
            this.setShapesAsAnimated(tempShapes);
          }
        }
      };
      SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
        var i2;
        var len = shapes.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          shapes[i2].setAsAnimated();
        }
      };
      SVGShapeElement.prototype.createStyleElement = function(data2, level) {
        var elementData;
        var styleOb = new SVGStyleData(data2, level);
        var pathElement = styleOb.pElem;
        if (data2.ty === "st") {
          elementData = new SVGStrokeStyleData(this, data2, styleOb);
        } else if (data2.ty === "fl") {
          elementData = new SVGFillStyleData(this, data2, styleOb);
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
          elementData = new GradientConstructor(this, data2, styleOb);
          this.globalData.defs.appendChild(elementData.gf);
          if (elementData.maskId) {
            this.globalData.defs.appendChild(elementData.ms);
            this.globalData.defs.appendChild(elementData.of);
            pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
          }
        } else if (data2.ty === "no") {
          elementData = new SVGNoStyleData(this, data2, styleOb);
        }
        if (data2.ty === "st" || data2.ty === "gs") {
          pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
          pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
          pathElement.setAttribute("fill-opacity", "0");
          if (data2.lj === 1) {
            pathElement.setAttribute("stroke-miterlimit", data2.ml);
          }
        }
        if (data2.r === 2) {
          pathElement.setAttribute("fill-rule", "evenodd");
        }
        if (data2.ln) {
          pathElement.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          pathElement.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createGroupElement = function(data2) {
        var elementData = new ShapeGroupData();
        if (data2.ln) {
          elementData.gr.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          elementData.gr.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        return elementData;
      };
      SVGShapeElement.prototype.createTransformElement = function(data2, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
        var i2 = 0;
        var len = this.animatedContents.length;
        while (i2 < len) {
          if (this.animatedContents[i2].element === element) {
            return;
          }
          i2 += 1;
        }
        this.animatedContents.push({
          fn: SVGElementsRenderer.createRenderFunction(data2),
          element,
          data: data2
        });
      };
      SVGShapeElement.prototype.setElementStyles = function(elementData) {
        var arr = elementData.styles;
        var j;
        var jLen = this.stylesList.length;
        for (j = 0; j < jLen; j += 1) {
          if (!this.stylesList[j].closed) {
            arr.push(this.stylesList[j]);
          }
        }
      };
      SVGShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i2;
        var len = this.itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.prevViewData[i2] = this.itemsData[i2];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.dynamicProperties[i2].getValue();
        }
        this.renderModifiers();
      };
      SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render2) {
        var ownTransformers = [].concat(transformers);
        var i2;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;
        for (i2 = len; i2 >= 0; i2 -= 1) {
          processedPos = this.searchProcessedElement(arr[i2]);
          if (!processedPos) {
            arr[i2]._render = render2;
          } else {
            itemsData[i2] = prevViewData[processedPos - 1];
          }
          if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs" || arr[i2].ty === "no") {
            if (!processedPos) {
              itemsData[i2] = this.createStyleElement(arr[i2], level);
            } else {
              itemsData[i2].style.closed = false;
            }
            if (arr[i2]._render) {
              if (itemsData[i2].style.pElem.parentNode !== container) {
                container.appendChild(itemsData[i2].style.pElem);
              }
            }
            ownStyles.push(itemsData[i2].style);
          } else if (arr[i2].ty === "gr") {
            if (!processedPos) {
              itemsData[i2] = this.createGroupElement(arr[i2]);
            } else {
              jLen = itemsData[i2].it.length;
              for (j = 0; j < jLen; j += 1) {
                itemsData[i2].prevViewData[j] = itemsData[i2].it[j];
              }
            }
            this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, itemsData[i2].gr, level + 1, ownTransformers, render2);
            if (arr[i2]._render) {
              if (itemsData[i2].gr.parentNode !== container) {
                container.appendChild(itemsData[i2].gr);
              }
            }
          } else if (arr[i2].ty === "tr") {
            if (!processedPos) {
              itemsData[i2] = this.createTransformElement(arr[i2], container);
            }
            currentTransform = itemsData[i2].transform;
            ownTransformers.push(currentTransform);
          } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
            if (!processedPos) {
              itemsData[i2] = this.createShapeElement(arr[i2], ownTransformers, level);
            }
            this.setElementStyles(itemsData[i2]);
          } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "ms" || arr[i2].ty === "pb" || arr[i2].ty === "zz" || arr[i2].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              modifier.init(this, arr[i2]);
              itemsData[i2] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i2];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i2].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              itemsData[i2] = modifier;
              modifier.init(this, arr, i2, itemsData);
              this.shapeModifiers.push(modifier);
              render2 = false;
            } else {
              modifier = itemsData[i2];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i2], i2 + 1);
        }
        len = ownStyles.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownStyles[i2].closed = true;
        }
        len = ownModifiers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownModifiers[i2].closed = true;
        }
      };
      SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.stylesList[i2].reset();
        }
        this.renderShape();
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.stylesList[i2]._mdf || this._isFirstFrame) {
            if (this.stylesList[i2].msElem) {
              this.stylesList[i2].msElem.setAttribute("d", this.stylesList[i2].d);
              this.stylesList[i2].d = "M0 0" + this.stylesList[i2].d;
            }
            this.stylesList[i2].pElem.setAttribute("d", this.stylesList[i2].d || "M0 0");
          }
        }
      };
      SVGShapeElement.prototype.renderShape = function() {
        var i2;
        var len = this.animatedContents.length;
        var animatedContent;
        for (i2 = 0; i2 < len; i2 += 1) {
          animatedContent = this.animatedContents[i2];
          if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
          }
        }
      };
      SVGShapeElement.prototype.destroy = function() {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
      };
      function LetterProps(o, sw, sc, fc, m2, p2) {
        this.o = o;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m2;
        this.p = p2;
        this._mdf = {
          o: true,
          sw: !!sw,
          sc: !!sc,
          fc: !!fc,
          m: true,
          p: true
        };
      }
      LetterProps.prototype.update = function(o, sw, sc, fc, m2, p2) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;
        if (this.o !== o) {
          this.o = o;
          this._mdf.o = true;
          updated = true;
        }
        if (this.sw !== sw) {
          this.sw = sw;
          this._mdf.sw = true;
          updated = true;
        }
        if (this.sc !== sc) {
          this.sc = sc;
          this._mdf.sc = true;
          updated = true;
        }
        if (this.fc !== fc) {
          this.fc = fc;
          this._mdf.fc = true;
          updated = true;
        }
        if (this.m !== m2) {
          this.m = m2;
          this._mdf.m = true;
          updated = true;
        }
        if (p2.length && (this.p[0] !== p2[0] || this.p[1] !== p2[1] || this.p[4] !== p2[4] || this.p[5] !== p2[5] || this.p[12] !== p2[12] || this.p[13] !== p2[13])) {
          this.p = p2;
          this._mdf.p = true;
          updated = true;
        }
        return updated;
      };
      function TextProperty(elem2, data2) {
        this._frameId = initialDefaultFrame;
        this.pv = "";
        this.v = "";
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        if (data2.d && data2.d.sid) {
          data2.d = elem2.globalData.slotManager.getProp(data2.d);
        }
        this.data = data2;
        this.elem = elem2;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
          ascent: 0,
          boxWidth: this.defaultBoxWidth,
          f: "",
          fStyle: "",
          fWeight: "",
          fc: "",
          j: "",
          justifyOffset: "",
          l: [],
          lh: 0,
          lineWidths: [],
          ls: "",
          of: "",
          s: "",
          sc: "",
          sw: 0,
          t: 0,
          tr: 0,
          sz: 0,
          ps: null,
          fillColorAnim: false,
          strokeColorAnim: false,
          strokeWidthAnim: false,
          yOffset: 0,
          finalSize: 0,
          finalText: [],
          finalLineHeight: 0,
          __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);
        if (!this.searchProperty()) {
          this.completeTextData(this.currentData);
        }
      }
      TextProperty.prototype.defaultBoxWidth = [0, 0];
      TextProperty.prototype.copyData = function(obj, data2) {
        for (var s2 in data2) {
          if (Object.prototype.hasOwnProperty.call(data2, s2)) {
            obj[s2] = data2[s2];
          }
        }
        return obj;
      };
      TextProperty.prototype.setCurrentData = function(data2) {
        if (!data2.__complete) {
          this.completeTextData(data2);
        }
        this.currentData = data2;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
      };
      TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
      };
      TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if (this.kf) {
          this.addEffect(this.getKeyframeValue.bind(this));
        }
        return this.kf;
      };
      TextProperty.prototype.addEffect = function(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.getValue = function(_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
          return;
        }
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var i2;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (currentIndex !== this.keysIndex) {
            finalValue = this.effectsSequence[i2](finalValue, finalValue.t);
          } else {
            finalValue = this.effectsSequence[i2](this.currentData, finalValue.t);
          }
        }
        if (currentValue !== finalValue) {
          this.setCurrentData(finalValue);
        }
        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      };
      TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i2 = 0;
        var len = textKeys.length;
        while (i2 <= len - 1) {
          if (i2 === len - 1 || textKeys[i2 + 1].t > frameNum) {
            break;
          }
          i2 += 1;
        }
        if (this.keysIndex !== i2) {
          this.keysIndex = i2;
        }
        return this.data.d.k[this.keysIndex].s;
      };
      TextProperty.prototype.buildFinalText = function(text2) {
        var charactersArray = [];
        var i2 = 0;
        var len = text2.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;
        var shouldCombineNext = false;
        var currentChars = "";
        while (i2 < len) {
          shouldCombine = shouldCombineNext;
          shouldCombineNext = false;
          charCode = text2.charCodeAt(i2);
          currentChars = text2.charAt(i2);
          if (FontManager.isCombinedCharacter(charCode)) {
            shouldCombine = true;
          } else if (charCode >= 55296 && charCode <= 56319) {
            if (FontManager.isRegionalFlag(text2, i2)) {
              currentChars = text2.substr(i2, 14);
            } else {
              secondCharCode = text2.charCodeAt(i2 + 1);
              if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                if (FontManager.isModifier(charCode, secondCharCode)) {
                  currentChars = text2.substr(i2, 2);
                  shouldCombine = true;
                } else if (FontManager.isFlagEmoji(text2.substr(i2, 4))) {
                  currentChars = text2.substr(i2, 4);
                } else {
                  currentChars = text2.substr(i2, 2);
                }
              }
            }
          } else if (charCode > 56319) {
            secondCharCode = text2.charCodeAt(i2 + 1);
            if (FontManager.isVariationSelector(charCode)) {
              shouldCombine = true;
            }
          } else if (FontManager.isZeroWidthJoiner(charCode)) {
            shouldCombine = true;
            shouldCombineNext = true;
          }
          if (shouldCombine) {
            charactersArray[charactersArray.length - 1] += currentChars;
            shouldCombine = false;
          } else {
            charactersArray.push(currentChars);
          }
          i2 += currentChars.length;
        }
        return charactersArray;
      };
      TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data2 = this.data;
        var letters = [];
        var i2;
        var len;
        var newLineFlag;
        var index2 = 0;
        var val2;
        var anchorGrouping = data2.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
        var charCode;
        if (documentData.sz) {
          var flag = true;
          var boxWidth = documentData.sz[0];
          var boxHeight = documentData.sz[1];
          var currentHeight;
          var finalText;
          while (flag) {
            finalText = this.buildFinalText(documentData.t);
            currentHeight = 0;
            lineWidth = 0;
            len = finalText.length;
            trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
            var lastSpaceIndex = -1;
            for (i2 = 0; i2 < len; i2 += 1) {
              charCode = finalText[i2].charCodeAt(0);
              newLineFlag = false;
              if (finalText[i2] === " ") {
                lastSpaceIndex = i2;
              } else if (charCode === 13 || charCode === 3) {
                lineWidth = 0;
                newLineFlag = true;
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              }
              if (fontManager.chars) {
                charData = fontManager.getCharData(finalText[i2], fontData.fStyle, fontData.fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                cLength = fontManager.measureText(finalText[i2], documentData.f, documentData.finalSize);
              }
              if (lineWidth + cLength > boxWidth && finalText[i2] !== " ") {
                if (lastSpaceIndex === -1) {
                  len += 1;
                } else {
                  i2 = lastSpaceIndex;
                }
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                finalText.splice(i2, lastSpaceIndex === i2 ? 1 : 0, "\r");
                lastSpaceIndex = -1;
                lineWidth = 0;
              } else {
                lineWidth += cLength;
                lineWidth += trackingOffset;
              }
            }
            currentHeight += fontData.ascent * documentData.finalSize / 100;
            if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
              documentData.finalSize -= 1;
              documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
            } else {
              documentData.finalText = finalText;
              len = documentData.finalText.length;
              flag = false;
            }
          }
        }
        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for (i2 = 0; i2 < len; i2 += 1) {
          newLineFlag = false;
          currentChar = documentData.finalText[i2];
          charCode = currentChar.charCodeAt(0);
          if (charCode === 13 || charCode === 3) {
            uncollapsedSpaces = 0;
            lineWidths.push(lineWidth);
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidth = -2 * trackingOffset;
            val2 = "";
            newLineFlag = true;
            currentLine += 1;
          } else {
            val2 = currentChar;
          }
          if (fontManager.chars) {
            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
          }
          if (currentChar === " ") {
            uncollapsedSpaces += cLength + trackingOffset;
          } else {
            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
            uncollapsedSpaces = 0;
          }
          letters.push({
            l: cLength,
            an: cLength,
            add: currentSize,
            n: newLineFlag,
            anIndexes: [],
            val: val2,
            line: currentLine,
            animatorJustifyOffset: 0
          });
          if (anchorGrouping == 2) {
            currentSize += cLength;
            if (val2 === "" || val2 === " " || i2 === len - 1) {
              if (val2 === "" || val2 === " ") {
                currentSize -= cLength;
              }
              while (currentPos <= i2) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              index2 += 1;
              currentSize = 0;
            }
          } else if (anchorGrouping == 3) {
            currentSize += cLength;
            if (val2 === "" || i2 === len - 1) {
              if (val2 === "") {
                currentSize -= cLength;
              }
              while (currentPos <= i2) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              currentSize = 0;
              index2 += 1;
            }
          } else {
            letters[index2].ind = index2;
            letters[index2].extra = 0;
            index2 += 1;
          }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if (documentData.sz) {
          documentData.boxWidth = documentData.sz[0];
          documentData.justifyOffset = 0;
        } else {
          documentData.boxWidth = maxLineWidth;
          switch (documentData.j) {
            case 1:
              documentData.justifyOffset = -documentData.boxWidth;
              break;
            case 2:
              documentData.justifyOffset = -documentData.boxWidth / 2;
              break;
            default:
              documentData.justifyOffset = 0;
          }
        }
        documentData.lineWidths = lineWidths;
        var animators = data2.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];
        for (j = 0; j < jLen; j += 1) {
          animatorData = animators[j];
          if (animatorData.a.sc) {
            documentData.strokeColorAnim = true;
          }
          if (animatorData.a.sw) {
            documentData.strokeWidthAnim = true;
          }
          if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
            documentData.fillColorAnim = true;
          }
          ind = 0;
          based = animatorData.s.b;
          for (i2 = 0; i2 < len; i2 += 1) {
            letterData = letters[i2];
            letterData.anIndexes[j] = ind;
            if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i2 == len - 1) || based == 4 && (letterData.n || i2 == len - 1)) {
              if (animatorData.s.rn === 1) {
                indexes.push(ind);
              }
              ind += 1;
            }
          }
          data2.a[j].s.totalChars = ind;
          var currentInd = -1;
          var newInd;
          if (animatorData.s.rn === 1) {
            for (i2 = 0; i2 < len; i2 += 1) {
              letterData = letters[i2];
              if (currentInd != letterData.anIndexes[j]) {
                currentInd = letterData.anIndexes[j];
                newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
              }
              letterData.anIndexes[j] = newInd;
            }
          }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
      };
      TextProperty.prototype.updateDocumentData = function(newData, index2) {
        index2 = index2 === void 0 ? this.keysIndex : index2;
        var dData = this.copyData({}, this.data.d.k[index2].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index2].s = dData;
        this.recalculate(index2);
        this.setCurrentData(dData);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.recalculate = function(index2) {
        var dData = this.data.d.k[index2].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
      };
      TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      var TextSelectorProp = function() {
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        function TextSelectorPropFactory(elem2, data2) {
          this._currentTextLength = -1;
          this.k = false;
          this.data = data2;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.finalS = 0;
          this.finalE = 0;
          this.initDynamicPropertyContainer(elem2);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: 0
          }, 0, 0, this);
          if ("e" in data2) {
            this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
          } else {
            this.e = {
              v: 100
            };
          }
          this.o = PropertyFactory.getProp(elem2, data2.o || {
            k: 0
          }, 0, 0, this);
          this.xe = PropertyFactory.getProp(elem2, data2.xe || {
            k: 0
          }, 0, 0, this);
          this.ne = PropertyFactory.getProp(elem2, data2.ne || {
            k: 0
          }, 0, 0, this);
          this.sm = PropertyFactory.getProp(elem2, data2.sm || {
            k: 100
          }, 0, 0, this);
          this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
          if (!this.dynamicProperties.length) {
            this.getValue();
          }
        }
        TextSelectorPropFactory.prototype = {
          getMult: function getMult(ind) {
            if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
              this.getValue();
            }
            var x1 = 0;
            var y1 = 0;
            var x2 = 1;
            var y2 = 1;
            if (this.ne.v > 0) {
              x1 = this.ne.v / 100;
            } else {
              y1 = -this.ne.v / 100;
            }
            if (this.xe.v > 0) {
              x2 = 1 - this.xe.v / 100;
            } else {
              y2 = 1 + this.xe.v / 100;
            }
            var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
            var mult = 0;
            var s2 = this.finalS;
            var e2 = this.finalE;
            var type2 = this.data.sh;
            if (type2 === 2) {
              if (e2 === s2) {
                mult = ind >= e2 ? 1 : 0;
              } else {
                mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
              }
              mult = easer(mult);
            } else if (type2 === 3) {
              if (e2 === s2) {
                mult = ind >= e2 ? 0 : 1;
              } else {
                mult = 1 - max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
              }
              mult = easer(mult);
            } else if (type2 === 4) {
              if (e2 === s2) {
                mult = 0;
              } else {
                mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                if (mult < 0.5) {
                  mult *= 2;
                } else {
                  mult = 1 - 2 * (mult - 0.5);
                }
              }
              mult = easer(mult);
            } else if (type2 === 5) {
              if (e2 === s2) {
                mult = 0;
              } else {
                var tot = e2 - s2;
                ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                var x = -tot / 2 + ind;
                var a = tot / 2;
                mult = Math.sqrt(1 - x * x / (a * a));
              }
              mult = easer(mult);
            } else if (type2 === 6) {
              if (e2 === s2) {
                mult = 0;
              } else {
                ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e2 - s2))) / 2;
              }
              mult = easer(mult);
            } else {
              if (ind >= floor(s2)) {
                if (ind - s2 < 0) {
                  mult = max(0, min(min(e2, 1) - (s2 - ind), 1));
                } else {
                  mult = max(0, min(e2 - ind, 1));
                }
              }
              mult = easer(mult);
            }
            if (this.sm.v !== 100) {
              var smoothness = this.sm.v * 0.01;
              if (smoothness === 0) {
                smoothness = 1e-8;
              }
              var threshold = 0.5 - smoothness * 0.5;
              if (mult < threshold) {
                mult = 0;
              } else {
                mult = (mult - threshold) / smoothness;
                if (mult > 1) {
                  mult = 1;
                }
              }
            }
            return mult * this.a.v;
          },
          getValue: function getValue2(newCharsFlag) {
            this.iterateDynamicProperties();
            this._mdf = newCharsFlag || this._mdf;
            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
            if (newCharsFlag && this.data.r === 2) {
              this.e.v = this._currentTextLength;
            }
            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
            var o = this.o.v / divisor;
            var s2 = this.s.v / divisor + o;
            var e2 = this.e.v / divisor + o;
            if (s2 > e2) {
              var _s = s2;
              s2 = e2;
              e2 = _s;
            }
            this.finalS = s2;
            this.finalE = e2;
          }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
        function getTextSelectorProp(elem2, data2, arr) {
          return new TextSelectorPropFactory(elem2, data2);
        }
        return {
          getTextSelectorProp
        };
      }();
      function TextAnimatorDataProperty(elem2, animatorProps, container) {
        var defaultData = {
          propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
          r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
          rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
          ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
          sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
          sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
          s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
          a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
          o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
          p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
          sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
          sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
          fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
          fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
          fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
          fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
          t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
      }
      function TextAnimatorProperty(textData, renderType, elem2) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem2;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
          alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem2);
      }
      TextAnimatorProperty.prototype.searchProperties = function() {
        var i2;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;
        for (i2 = 0; i2 < len; i2 += 1) {
          animatorProps = this._textData.a[i2];
          this._animatorsData[i2] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if (this._textData.p && "m" in this._textData.p) {
          this._pathData = {
            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          };
          this._hasMaskedPath = true;
        } else {
          this._hasMaskedPath = false;
        }
        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
      };
      TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;
        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
          return;
        }
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i2;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength;
        var perc;
        var tanAngle;
        var mask2;
        if (this._hasMaskedPath) {
          mask2 = this._pathData.m;
          if (!this._pathData.n || this._pathData._mdf) {
            var paths = mask2.v;
            if (this._pathData.r.v) {
              paths = paths.reverse();
            }
            pathInfo = {
              tLength: 0,
              segments: []
            };
            len = paths._length - 1;
            var bezierData;
            totalLength = 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierData = bez.buildBezierData(paths.v[i2], paths.v[i2 + 1], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[i2 + 1][0] - paths.v[i2 + 1][0], paths.i[i2 + 1][1] - paths.v[i2 + 1][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            i2 = len;
            if (mask2.v.c) {
              bezierData = bez.buildBezierData(paths.v[i2], paths.v[0], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }
            this._pathData.pi = pathInfo;
          }
          pathInfo = this._pathData.pi;
          currentLength = this._pathData.f.v;
          segmentInd = 0;
          pointInd = 1;
          segmentLength = 0;
          flag = true;
          segments = pathInfo.segments;
          if (currentLength < 0 && mask2.v.c) {
            if (pathInfo.tLength < Math.abs(currentLength)) {
              currentLength = -Math.abs(currentLength) % pathInfo.tLength;
            }
            segmentInd = segments.length - 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;
            while (currentLength < 0) {
              currentLength += points[pointInd].partialLength;
              pointInd -= 1;
              if (pointInd < 0) {
                segmentInd -= 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
              }
            }
          }
          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
        }
        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = "";
        var letterP = this.defaultPropsArray;
        var letterO;
        if (documentData.j === 2 || documentData.j === 1) {
          var animatorJustifyOffset = 0;
          var animatorFirstCharOffset = 0;
          var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
          var lastIndex = 0;
          var isNewLine = true;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (letters[i2].n) {
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }
              while (lastIndex < i2) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }
              animatorJustifyOffset = 0;
              isNewLine = true;
            } else {
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.t.propType) {
                  if (isNewLine && documentData.j === 2) {
                    animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                  }
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                  } else {
                    animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                  }
                }
              }
              isNewLine = false;
            }
          }
          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }
          while (lastIndex < i2) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }
        }
        for (i2 = 0; i2 < len; i2 += 1) {
          matrixHelper.reset();
          elemOpacity = 1;
          if (letters[i2].n) {
            xPos = 0;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            currentLength = initPathPos;
            firstLine = false;
            if (this._hasMaskedPath) {
              segmentInd = initSegmentInd;
              pointInd = initPointInd;
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
              segmentLength = 0;
            }
            letterM = "";
            letterFc = "";
            letterSw = "";
            letterO = "";
            letterP = this.defaultPropsArray;
          } else {
            if (this._hasMaskedPath) {
              if (currentLine !== letters[i2].line) {
                switch (documentData.j) {
                  case 1:
                    currentLength += totalLength - documentData.lineWidths[letters[i2].line];
                    break;
                  case 2:
                    currentLength += (totalLength - documentData.lineWidths[letters[i2].line]) / 2;
                    break;
                }
                currentLine = letters[i2].line;
              }
              if (ind !== letters[i2].ind) {
                if (letters[ind]) {
                  currentLength += letters[ind].extra;
                }
                currentLength += letters[i2].an / 2;
                ind = letters[i2].ind;
              }
              currentLength += alignment[0] * letters[i2].an * 5e-3;
              var animatorOffset = 0;
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.p.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.p.v[0] * mult;
                  }
                }
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.a.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.a.v[0] * mult;
                  }
                }
              }
              flag = true;
              if (this._pathData.a.v) {
                currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                currentLength += this._pathData.f.v;
              }
              while (flag) {
                if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                  perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                  xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                  yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                  matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                  flag = false;
                } else if (points) {
                  segmentLength += currentPoint.partialLength;
                  pointInd += 1;
                  if (pointInd >= points.length) {
                    pointInd = 0;
                    segmentInd += 1;
                    if (!segments[segmentInd]) {
                      if (mask2.v.c) {
                        pointInd = 0;
                        segmentInd = 0;
                        points = segments[segmentInd].points;
                      } else {
                        segmentLength -= currentPoint.partialLength;
                        points = null;
                      }
                    } else {
                      points = segments[segmentInd].points;
                    }
                  }
                  if (points) {
                    prevPoint = currentPoint;
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                  }
                }
              }
              offf = letters[i2].an / 2 - letters[i2].add;
              matrixHelper.translate(-offf, 0, 0);
            } else {
              offf = letters[i2].an / 2 - letters[i2].add;
              matrixHelper.translate(-offf, 0, 0);
              matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.t.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                if (xPos !== 0 || documentData.j !== 0) {
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      currentLength += animatorProps.t.v * mult[0];
                    } else {
                      currentLength += animatorProps.t.v * mult;
                    }
                  } else if (mult.length) {
                    xPos += animatorProps.t.v * mult[0];
                  } else {
                    xPos += animatorProps.t.v * mult;
                  }
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              sw = documentData.sw || 0;
            }
            if (documentData.strokeColorAnim) {
              if (documentData.sc) {
                sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
              } else {
                sc = [0, 0, 0];
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.s.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                } else {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
              if (animatorProps.sk.propType) {
                if (mult.length) {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                } else {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                }
              }
              if (animatorProps.r.propType) {
                if (mult.length) {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                } else {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult);
                }
              }
              if (animatorProps.ry.propType) {
                if (mult.length) {
                  matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                } else {
                  matrixHelper.rotateY(animatorProps.ry.v * mult);
                }
              }
              if (animatorProps.rx.propType) {
                if (mult.length) {
                  matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                } else {
                  matrixHelper.rotateX(animatorProps.rx.v * mult);
                }
              }
              if (animatorProps.o.propType) {
                if (mult.length) {
                  elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                } else {
                  elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                }
              }
              if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                if (mult.length) {
                  sw += animatorProps.sw.v * mult[0];
                } else {
                  sw += animatorProps.sw.v * mult;
                }
              }
              if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                  } else {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                  }
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                if (animatorProps.fc.propType) {
                  for (k = 0; k < 3; k += 1) {
                    if (mult.length) {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                    } else {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                    }
                  }
                }
                if (animatorProps.fh.propType) {
                  if (mult.length) {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                  } else {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                  }
                }
                if (animatorProps.fs.propType) {
                  if (mult.length) {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                  } else {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                  }
                }
                if (animatorProps.fb.propType) {
                  if (mult.length) {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                  } else {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                  }
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                  } else {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                } else if (mult.length) {
                  matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              letterSw = sw < 0 ? 0 : sw;
            }
            if (documentData.strokeColorAnim) {
              letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
            }
            if (documentData.fillColorAnim && documentData.fc) {
              letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
            }
            if (this._hasMaskedPath) {
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
              if (this._pathData.p.v) {
                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                var rot = Math.atan(tanAngle) * 180 / Math.PI;
                if (currentPoint.point[0] < prevPoint.point[0]) {
                  rot += 180;
                }
                matrixHelper.rotate(-rot * Math.PI / 180);
              }
              matrixHelper.translate(xPathPos, yPathPos, 0);
              currentLength -= alignment[0] * letters[i2].an * 5e-3;
              if (letters[i2 + 1] && ind !== letters[i2 + 1].ind) {
                currentLength += letters[i2].an / 2;
                currentLength += documentData.tr * 1e-3 * documentData.finalSize;
              }
            } else {
              matrixHelper.translate(xPos, yPos, 0);
              if (documentData.ps) {
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }
              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]), 0, 0);
                  break;
                case 2:
                  matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]) / 2, 0, 0);
                  break;
              }
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(offf, 0, 0);
              matrixHelper.translate(alignment[0] * letters[i2].an * 5e-3, alignment[1] * yOff * 0.01, 0);
              xPos += letters[i2].l + documentData.tr * 1e-3 * documentData.finalSize;
            }
            if (renderType === "html") {
              letterM = matrixHelper.toCSS();
            } else if (renderType === "svg") {
              letterM = matrixHelper.to2dCSS();
            } else {
              letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
            }
            letterO = elemOpacity;
          }
          if (renderedLettersCount <= i2) {
            letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
            this.renderedLetters.push(letterValue);
            renderedLettersCount += 1;
            this.lettersChangedFlag = true;
          } else {
            letterValue = this.renderedLetters[i2];
            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
          }
        }
      };
      TextAnimatorProperty.prototype.getValue = function() {
        if (this._elem.globalData.frameId === this._frameId) {
          return;
        }
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      TextAnimatorProperty.prototype.mHelper = new Matrix();
      TextAnimatorProperty.prototype.defaultPropsArray = [];
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {
      }
      ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
      };
      ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      };
      ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = "";
        for (j = 0; j < jLen; j += 1) {
          if (shapes[j].ty === "sh") {
            pathNodes = shapes[j].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
        }
        return shapeStr;
      };
      ITextElement.prototype.updateDocumentData = function(newData, index2) {
        this.textProperty.updateDocumentData(newData, index2);
      };
      ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
      };
      ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
      };
      ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) {
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        matrixHelper.translate(0, -documentData.ls, 0);
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
            break;
        }
        matrixHelper.translate(xPos, yPos, 0);
      };
      ITextElement.prototype.buildColor = function(colorData) {
        return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
      };
      ITextElement.prototype.emptyProp = new LetterProps();
      ITextElement.prototype.destroy = function() {
      };
      ITextElement.prototype.validateText = function() {
        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
          this.buildNewText();
          this.textProperty._isFirstFrame = false;
          this.textProperty._mdf = false;
        }
      };
      var emptyShapeData = {
        shapes: []
      };
      function SVGTextLottieElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.renderType = "svg";
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
      SVGTextLottieElement.prototype.createContent = function() {
        if (this.data.singleShape && !this.globalData.fontManager.chars) {
          this.textContainer = createNS("text");
        }
      };
      SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
        var i2 = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = "";
        while (i2 < len) {
          if (textArray[i2] === String.fromCharCode(13) || textArray[i2] === String.fromCharCode(3)) {
            textContents.push(currentTextContent);
            currentTextContent = "";
          } else {
            currentTextContent += textArray[i2];
          }
          i2 += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
      };
      SVGTextLottieElement.prototype.buildShapeData = function(data2, scale2) {
        if (data2.shapes && data2.shapes.length) {
          var shape = data2.shapes[0];
          if (shape.it) {
            var shapeItem = shape.it[shape.it.length - 1];
            if (shapeItem.s) {
              shapeItem.s.k[0] = scale2;
              shapeItem.s.k[1] = scale2;
            }
          }
        }
        return data2;
      };
      SVGTextLottieElement.prototype.buildNewText = function() {
        this.addDynamicProperty(this);
        var i2;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if (documentData.fc) {
          this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
        } else {
          this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
        }
        if (documentData.sc) {
          this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
          this.layerElement.setAttribute("stroke-width", documentData.sw);
        }
        this.layerElement.setAttribute("font-size", documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (fontData.fClass) {
          this.layerElement.setAttribute("class", fontData.fClass);
        } else {
          this.layerElement.setAttribute("font-family", fontData.fFamily);
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          this.layerElement.setAttribute("font-style", fStyle);
          this.layerElement.setAttribute("font-weight", fWeight);
        }
        this.layerElement.setAttribute("aria-label", documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = "";
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        if (singleShape && !usesGlyphs && !documentData.sz) {
          var tElement = this.textContainer;
          var justify = "start";
          switch (documentData.j) {
            case 1:
              justify = "end";
              break;
            case 2:
              justify = "middle";
              break;
            default:
              justify = "start";
              break;
          }
          tElement.setAttribute("text-anchor", justify);
          tElement.setAttribute("letter-spacing", trackingOffset);
          var textContent = this.buildTextContents(documentData.finalText);
          len = textContent.length;
          yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            tSpan = this.textSpans[i2].span || createNS("tspan");
            tSpan.textContent = textContent[i2];
            tSpan.setAttribute("x", 0);
            tSpan.setAttribute("y", yPos);
            tSpan.style.display = "inherit";
            tElement.appendChild(tSpan);
            if (!this.textSpans[i2]) {
              this.textSpans[i2] = {
                span: null,
                glyph: null
              };
            }
            this.textSpans[i2].span = tSpan;
            yPos += documentData.finalLineHeight;
          }
          this.layerElement.appendChild(tElement);
        } else {
          var cachedSpansLength = this.textSpans.length;
          var charData;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!this.textSpans[i2]) {
              this.textSpans[i2] = {
                span: null,
                childSpan: null,
                glyph: null
              };
            }
            if (!usesGlyphs || !singleShape || i2 === 0) {
              tSpan = cachedSpansLength > i2 ? this.textSpans[i2].span : createNS(usesGlyphs ? "g" : "text");
              if (cachedSpansLength <= i2) {
                tSpan.setAttribute("stroke-linecap", "butt");
                tSpan.setAttribute("stroke-linejoin", "round");
                tSpan.setAttribute("stroke-miterlimit", "4");
                this.textSpans[i2].span = tSpan;
                if (usesGlyphs) {
                  var childSpan = createNS("g");
                  tSpan.appendChild(childSpan);
                  this.textSpans[i2].childSpan = childSpan;
                }
                this.textSpans[i2].span = tSpan;
                this.layerElement.appendChild(tSpan);
              }
              tSpan.style.display = "inherit";
            }
            matrixHelper.reset();
            if (singleShape) {
              if (letters[i2].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
              xPos += letters[i2].l || 0;
              xPos += trackingOffset;
            }
            if (usesGlyphs) {
              charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var glyphElement;
              if (charData.t === 1) {
                glyphElement = new SVGCompElement(charData.data, this.globalData, this);
              } else {
                var data2 = emptyShapeData;
                if (charData.data && charData.data.shapes) {
                  data2 = this.buildShapeData(charData.data, documentData.finalSize);
                }
                glyphElement = new SVGShapeElement(data2, this.globalData, this);
              }
              if (this.textSpans[i2].glyph) {
                var glyph = this.textSpans[i2].glyph;
                this.textSpans[i2].childSpan.removeChild(glyph.layerElement);
                glyph.destroy();
              }
              this.textSpans[i2].glyph = glyphElement;
              glyphElement._debug = true;
              glyphElement.prepareFrame(0);
              glyphElement.renderFrame();
              this.textSpans[i2].childSpan.appendChild(glyphElement.layerElement);
              if (charData.t === 1) {
                this.textSpans[i2].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
              }
            } else {
              if (singleShape) {
                tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
              }
              tSpan.textContent = letters[i2].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            }
          }
          if (singleShape && tSpan) {
            tSpan.setAttribute("d", shapeStr);
          }
        }
        while (i2 < this.textSpans.length) {
          this.textSpans[i2].span.style.display = "none";
          i2 += 1;
        }
        this._sizeChanged = true;
      };
      SVGTextLottieElement.prototype.sourceRectAtTime = function() {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if (this._sizeChanged) {
          this._sizeChanged = false;
          var textBox = this.layerElement.getBBox();
          this.bbox = {
            top: textBox.y,
            left: textBox.x,
            width: textBox.width,
            height: textBox.height
          };
        }
        return this.bbox;
      };
      SVGTextLottieElement.prototype.getValue = function() {
        var i2;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;
        for (i2 = 0; i2 < len; i2 += 1) {
          glyphElement = this.textSpans[i2].glyph;
          if (glyphElement) {
            glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
            if (glyphElement._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      SVGTextLottieElement.prototype.renderInnerContent = function() {
        this.validateText();
        if (!this.data.singleShape || this._mdf) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
            this._sizeChanged = true;
            var i2;
            var len;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var glyphElement;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!letters[i2].n) {
                renderedLetter = renderedLetters[i2];
                textSpan = this.textSpans[i2].span;
                glyphElement = this.textSpans[i2].glyph;
                if (glyphElement) {
                  glyphElement.renderFrame();
                }
                if (renderedLetter._mdf.m) {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
                if (renderedLetter._mdf.o) {
                  textSpan.setAttribute("opacity", renderedLetter.o);
                }
                if (renderedLetter._mdf.sw) {
                  textSpan.setAttribute("stroke-width", renderedLetter.sw);
                }
                if (renderedLetter._mdf.sc) {
                  textSpan.setAttribute("stroke", renderedLetter.sc);
                }
                if (renderedLetter._mdf.fc) {
                  textSpan.setAttribute("fill", renderedLetter.fc);
                }
              }
            }
          }
        }
      };
      function ISolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([IImageElement], ISolidElement);
      ISolidElement.prototype.createContent = function() {
        var rect = createNS("rect");
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.layerElement.appendChild(rect);
      };
      function NullElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initFrame();
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
      }
      NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      NullElement.prototype.renderFrame = function() {
      };
      NullElement.prototype.getBaseElement = function() {
        return null;
      };
      NullElement.prototype.destroy = function() {
      };
      NullElement.prototype.sourceRectAtTime = function() {
      };
      NullElement.prototype.hide = function() {
      };
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
      function SVGRendererBase() {
      }
      extendPrototype([BaseRenderer], SVGRendererBase);
      SVGRendererBase.prototype.createNull = function(data2) {
        return new NullElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createShape = function(data2) {
        return new SVGShapeElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createText = function(data2) {
        return new SVGTextLottieElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createImage = function(data2) {
        return new IImageElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createSolid = function(data2) {
        return new ISolidElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.configAnimation = function(animData) {
        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        if (this.renderConfig.viewBoxSize) {
          this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
        } else {
          this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
        }
        if (!this.renderConfig.viewBoxOnly) {
          this.svgElement.setAttribute("width", animData.w);
          this.svgElement.setAttribute("height", animData.h);
          this.svgElement.style.width = "100%";
          this.svgElement.style.height = "100%";
          this.svgElement.style.transform = "translate3d(0,0,0)";
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }
        if (this.renderConfig.width) {
          this.svgElement.setAttribute("width", this.renderConfig.width);
        }
        if (this.renderConfig.height) {
          this.svgElement.setAttribute("height", this.renderConfig.height);
        }
        if (this.renderConfig.className) {
          this.svgElement.setAttribute("class", this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.svgElement.setAttribute("id", this.renderConfig.id);
        }
        if (this.renderConfig.focusable !== void 0) {
          this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
        }
        this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
        this.animationItem.wrapper.appendChild(this.svgElement);
        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS("clipPath");
        var rect = createNS("rect");
        rect.setAttribute("width", animData.w);
        rect.setAttribute("height", animData.h);
        rect.setAttribute("x", 0);
        rect.setAttribute("y", 0);
        var maskId = createElementID();
        maskElement.setAttribute("id", maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
      };
      SVGRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.layerElement = null;
        this.globalData.defs = null;
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      SVGRendererBase.prototype.updateContainerSize = function() {
      };
      SVGRendererBase.prototype.findIndexByInd = function(ind) {
        var i2 = 0;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.layers[i2].ind === ind) {
            return i2;
          }
        }
        return -1;
      };
      SVGRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;
        if (getExpressionsPlugin()) {
          if (this.layers[pos].ty === 0) {
            this.globalData.projectInterface.registerComposition(element);
          }
          element.initExpressions();
        }
        this.appendElementInPos(element, pos);
        if (this.layers[pos].tt) {
          var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
          if (elementIndex === -1) {
            return;
          }
          if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
            this.buildItem(elementIndex);
            this.addPendingElement(element);
          } else {
            var matteElement = elements[elementIndex];
            var matteMask = matteElement.getMatte(this.layers[pos].tt);
            element.setMatte(matteMask);
          }
        }
      };
      SVGRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
          if (element.data.tt) {
            var i2 = 0;
            var len = this.elements.length;
            while (i2 < len) {
              if (this.elements[i2] === element) {
                var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i2 - 1;
                var matteElement = this.elements[elementIndex];
                var matteMask = matteElement.getMatte(this.layers[i2].tt);
                element.setMatte(matteMask);
                break;
              }
              i2 += 1;
            }
          }
        }
      };
      SVGRendererBase.prototype.renderFrame = function(num) {
        if (this.renderedFrame === num || this.destroyed) {
          return;
        }
        if (num === null) {
          num = this.renderedFrame;
        } else {
          this.renderedFrame = num;
        }
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i2;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(num - this.layers[i2].st);
          }
        }
        if (this.globalData._mdf) {
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
        }
      };
      SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newElement = element.getBaseElement();
        if (!newElement) {
          return;
        }
        var i2 = 0;
        var nextElement;
        while (i2 < pos) {
          if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement()) {
            nextElement = this.elements[i2].getBaseElement();
          }
          i2 += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(newElement, nextElement);
        } else {
          this.layerElement.appendChild(newElement);
        }
      };
      SVGRendererBase.prototype.hide = function() {
        this.layerElement.style.display = "none";
      };
      SVGRendererBase.prototype.show = function() {
        this.layerElement.style.display = "block";
      };
      function ICompElement() {
      }
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
      ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initTransform(data2, globalData2, comp2);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if (this.data.xt || !globalData2.progressiveLoad) {
          this.buildAllItems();
        }
        this.hide();
      };
      ICompElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (!this.isInRange && !this.data.xt) {
          return;
        }
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          if (timeRemapped === this.data.op) {
            timeRemapped = this.data.op - 1;
          }
          this.renderedFrame = timeRemapped;
        } else {
          this.renderedFrame = num / this.data.sr;
        }
        var i2;
        var len = this.elements.length;
        if (!this.completeLayers) {
          this.checkLayers(this.renderedFrame);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(this.renderedFrame - this.layers[i2].st);
            if (this.elements[i2]._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      ICompElement.prototype.renderInnerContent = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].renderFrame();
          }
        }
      };
      ICompElement.prototype.setElements = function(elems) {
        this.elements = elems;
      };
      ICompElement.prototype.getElements = function() {
        return this.elements;
      };
      ICompElement.prototype.destroyElements = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2]) {
            this.elements[i2].destroy();
          }
        }
      };
      ICompElement.prototype.destroy = function() {
        this.destroyElements();
        this.destroyBaseElement();
      };
      function SVGCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
      SVGCompElement.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function SVGRenderer(animationItem, config2) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS("svg");
        var ariaLabel = "";
        if (config2 && config2.title) {
          var titleElement = createNS("title");
          var titleId = createElementID();
          titleElement.setAttribute("id", titleId);
          titleElement.textContent = config2.title;
          this.svgElement.appendChild(titleElement);
          ariaLabel += titleId;
        }
        if (config2 && config2.description) {
          var descElement = createNS("desc");
          var descId = createElementID();
          descElement.setAttribute("id", descId);
          descElement.textContent = config2.description;
          this.svgElement.appendChild(descElement);
          ariaLabel += " " + descId;
        }
        if (ariaLabel) {
          this.svgElement.setAttribute("aria-labelledby", ariaLabel);
        }
        var defs = createNS("defs");
        this.svgElement.appendChild(defs);
        var maskElement = createNS("g");
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
          preserveAspectRatio: config2 && config2.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config2 && config2.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config2 && config2.contentVisibility || "visible",
          progressiveLoad: config2 && config2.progressiveLoad || false,
          hideOnTransparent: !(config2 && config2.hideOnTransparent === false),
          viewBoxOnly: config2 && config2.viewBoxOnly || false,
          viewBoxSize: config2 && config2.viewBoxSize || false,
          className: config2 && config2.className || "",
          id: config2 && config2.id || "",
          focusable: config2 && config2.focusable,
          filterSize: {
            width: config2 && config2.filterSize && config2.filterSize.width || "100%",
            height: config2 && config2.filterSize && config2.filterSize.height || "100%",
            x: config2 && config2.filterSize && config2.filterSize.x || "0%",
            y: config2 && config2.filterSize && config2.filterSize.y || "0%"
          },
          width: config2 && config2.width,
          height: config2 && config2.height,
          runExpressions: !config2 || config2.runExpressions === void 0 || config2.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          defs,
          renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = "svg";
      }
      extendPrototype([SVGRendererBase], SVGRenderer);
      SVGRenderer.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
          var i2;
          var len = transforms.length;
          var key2 = "_";
          for (i2 = 0; i2 < len; i2 += 1) {
            key2 += transforms[i2].transform.key + "_";
          }
          var sequence = this.sequences[key2];
          if (!sequence) {
            sequence = {
              transforms: [].concat(transforms),
              finalTransform: new Matrix(),
              _mdf: false
            };
            this.sequences[key2] = sequence;
            this.sequenceList.push(sequence);
          }
          return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
          var i2 = 0;
          var len = sequence.transforms.length;
          var _mdf = isFirstFrame;
          while (i2 < len && !isFirstFrame) {
            if (sequence.transforms[i2].transform.mProps._mdf) {
              _mdf = true;
              break;
            }
            i2 += 1;
          }
          if (_mdf) {
            sequence.finalTransform.reset();
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              sequence.finalTransform.multiply(sequence.transforms[i2].transform.mProps.v);
            }
          }
          sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
          var i2;
          var len = this.sequenceList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.processSequence(this.sequenceList[i2], isFirstFrame);
          }
        },
        getNewKey: function getNewKey() {
          this.transform_key_count += 1;
          return "_" + this.transform_key_count;
        }
      };
      var lumaLoader = function lumaLoader2() {
        var id = "__lottie_element_luma_buffer";
        var lumaBuffer = null;
        var lumaBufferCtx = null;
        var svg = null;
        function createLumaSvgFilter() {
          var _svg = createNS("svg");
          var fil = createNS("filter");
          var matrix = createNS("feColorMatrix");
          fil.setAttribute("id", id);
          matrix.setAttribute("type", "matrix");
          matrix.setAttribute("color-interpolation-filters", "sRGB");
          matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
          fil.appendChild(matrix);
          _svg.appendChild(fil);
          _svg.setAttribute("id", id + "_svg");
          if (featureSupport.svgLumaHidden) {
            _svg.style.display = "none";
          }
          return _svg;
        }
        function loadLuma() {
          if (!lumaBuffer) {
            svg = createLumaSvgFilter();
            document.body.appendChild(svg);
            lumaBuffer = createTag("canvas");
            lumaBufferCtx = lumaBuffer.getContext("2d");
            lumaBufferCtx.filter = "url(#" + id + ")";
            lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
            lumaBufferCtx.fillRect(0, 0, 1, 1);
          }
        }
        function getLuma(canvas) {
          if (!lumaBuffer) {
            loadLuma();
          }
          lumaBuffer.width = canvas.width;
          lumaBuffer.height = canvas.height;
          lumaBufferCtx.filter = "url(#" + id + ")";
          return lumaBuffer;
        }
        return {
          load: loadLuma,
          get: getLuma
        };
      };
      function createCanvas(width2, height2) {
        if (featureSupport.offscreenCanvas) {
          return new OffscreenCanvas(width2, height2);
        }
        var canvas = createTag("canvas");
        canvas.width = width2;
        canvas.height = height2;
        return canvas;
      }
      var assetLoader = function() {
        return {
          loadLumaCanvas: lumaLoader.load,
          getLumaCanvas: lumaLoader.get,
          createCanvas
        };
      }();
      var registeredEffects = {};
      function CVEffects(elem2) {
        var i2;
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        this.filters = [];
        var filterManager;
        for (i2 = 0; i2 < len; i2 += 1) {
          filterManager = null;
          var type2 = elem2.data.ef[i2].ty;
          if (registeredEffects[type2]) {
            var Effect = registeredEffects[type2].effect;
            filterManager = new Effect(elem2.effectsManager.effectElements[i2], elem2);
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      CVEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i2;
        var len = this.filters.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.filters[i2].renderFrame(_isFirstFrame);
        }
      };
      CVEffects.prototype.getEffects = function(type2) {
        var i2;
        var len = this.filters.length;
        var effects = [];
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.filters[i2].type === type2) {
            effects.push(this.filters[i2]);
          }
        }
        return effects;
      };
      function registerEffect(id, effect2) {
        registeredEffects[id] = {
          effect: effect2
        };
      }
      function CVMaskElement(data2, element) {
        this.data = data2;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i2;
        var len = this.masksProperties.length;
        var hasMasks = false;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.masksProperties[i2].mode !== "n") {
            hasMasks = true;
          }
          this.viewData[i2] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i2], 3);
        }
        this.hasMasks = hasMasks;
        if (hasMasks) {
          this.element.addRenderableComponent(this);
        }
      }
      CVMaskElement.prototype.renderFrame = function() {
        if (!this.hasMasks) {
          return;
        }
        var transform2 = this.element.finalTransform.mat;
        var ctx2 = this.element.canvasContext;
        var i2;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data2;
        ctx2.beginPath();
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.masksProperties[i2].mode !== "n") {
            if (this.masksProperties[i2].inv) {
              ctx2.moveTo(0, 0);
              ctx2.lineTo(this.element.globalData.compSize.w, 0);
              ctx2.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
              ctx2.lineTo(0, this.element.globalData.compSize.h);
              ctx2.lineTo(0, 0);
            }
            data2 = this.viewData[i2].v;
            pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
            ctx2.moveTo(pt[0], pt[1]);
            var j;
            var jLen = data2._length;
            for (j = 1; j < jLen; j += 1) {
              pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[j], data2.v[j]);
              ctx2.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
            pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[0], data2.v[0]);
            ctx2.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
        }
        this.element.globalData.renderer.save(true);
        ctx2.clip();
      };
      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
      CVMaskElement.prototype.destroy = function() {
        this.element = null;
      };
      function CVBaseElement() {
      }
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out"
      };
      CVBaseElement.prototype = {
        createElements: function createElements() {
        },
        initRendererElement: function initRendererElement() {
        },
        createContainerElements: function createContainerElements() {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var canvasContext = this.globalData.canvasContext;
            var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas);
            var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas2);
            if (this.data.tt >= 3 && !document._isProxy) {
              assetLoader.loadLumaCanvas();
            }
          }
          this.canvasContext = this.globalData.canvasContext;
          this.transformCanvas = this.globalData.transformCanvas;
          this.renderableEffectsManager = new CVEffects(this);
          this.searchEffectTransforms();
        },
        createContent: function createContent() {
        },
        setBlendMode: function setBlendMode() {
          var globalData2 = this.globalData;
          if (globalData2.blendMode !== this.data.bm) {
            globalData2.blendMode = this.data.bm;
            var blendModeValue = getBlendMode(this.data.bm);
            globalData2.canvasContext.globalCompositeOperation = blendModeValue;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new CVMaskElement(this.data, this);
          this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
        },
        hideElement: function hideElement() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            this.hidden = true;
          }
        },
        showElement: function showElement() {
          if (this.isInRange && !this.isTransparent) {
            this.hidden = false;
            this._isFirstFrame = true;
            this.maskManager._isFirstFrame = true;
          }
        },
        clearCanvas: function clearCanvas(canvasContext) {
          canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
        },
        prepareLayer: function prepareLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[0];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.currentTransform = this.canvasContext.getTransform();
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function exitLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[1];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
            var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
            mask2.renderFrame(true);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            if (this.data.tt >= 3 && !document._isProxy) {
              var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
              var lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.drawImage(lumaBuffer, 0, 0);
            }
            this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
            this.canvasContext.drawImage(buffer, 0, 0);
            this.canvasContext.globalCompositeOperation = "destination-over";
            this.canvasContext.drawImage(this.buffers[0], 0, 0);
            this.canvasContext.setTransform(this.currentTransform);
            this.canvasContext.globalCompositeOperation = "source-over";
          }
        },
        renderFrame: function renderFrame(forceRender) {
          if (this.hidden || this.data.hd) {
            return;
          }
          if (this.data.td === 1 && !forceRender) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.setBlendMode();
          var forceRealStack = this.data.ty === 0;
          this.prepareLayer();
          this.globalData.renderer.save(forceRealStack);
          this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
          this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
          this.renderInnerContent();
          this.globalData.renderer.restore(forceRealStack);
          this.exitLayer();
          if (this.maskManager.hasMasks) {
            this.globalData.renderer.restore(true);
          }
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.canvasContext = null;
          this.data = null;
          this.globalData = null;
          this.maskManager.destroy();
        },
        mHelper: new Matrix()
      };
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
      function CVShapeData(element, data2, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0, 0, 0, 0, 0, 0];
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
        var i2;
        var len = styles.length;
        var styledShape;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!styles[i2].closed) {
            styledShape = {
              transforms: transformsManager.addTransformSequence(styles[i2].transforms),
              trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i2].elements.push(styledShape);
          }
        }
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
      CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
      };
      CVShapeElement.prototype.dashResetter = [];
      CVShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      };
      CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
        var styleElem = {
          data: data2,
          type: data2.ty,
          preTransforms: this.transformsManager.addTransformSequence(transforms),
          transforms: [],
          elements: [],
          closed: data2.hd === true
        };
        var elementData = {};
        if (data2.ty === "fl" || data2.ty === "st") {
          elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
          if (!elementData.c.k) {
            styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
          }
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
          elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
          elementData.h = PropertyFactory.getProp(this, data2.h || {
            k: 0
          }, 0, 0.01, this);
          elementData.a = PropertyFactory.getProp(this, data2.a || {
            k: 0
          }, 0, degToRads, this);
          elementData.g = new GradientProperty(this, data2.g, this);
        }
        elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
        if (data2.ty === "st" || data2.ty === "gs") {
          styleElem.lc = lineCapEnum[data2.lc || 2];
          styleElem.lj = lineJoinEnum[data2.lj || 2];
          if (data2.lj == 1) {
            styleElem.ml = data2.ml;
          }
          elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
          if (!elementData.w.k) {
            styleElem.wi = elementData.w.v;
          }
          if (data2.d) {
            var d2 = new DashProperty(this, data2.d, "canvas", this);
            elementData.d = d2;
            if (!elementData.d.k) {
              styleElem.da = elementData.d.dashArray;
              styleElem["do"] = elementData.d.dashoffset[0];
            }
          }
        } else {
          styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
        }
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
      };
      CVShapeElement.prototype.createGroupElement = function() {
        var elementData = {
          it: [],
          prevViewData: []
        };
        return elementData;
      };
      CVShapeElement.prototype.createTransformElement = function(data2) {
        var elementData = {
          transform: {
            opacity: 1,
            _opMdf: false,
            key: this.transformsManager.getNewKey(),
            op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
            mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
          }
        };
        return elementData;
      };
      CVShapeElement.prototype.createShapeElement = function(data2) {
        var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
      };
      CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i2;
        var len = this.itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.prevViewData[i2] = this.itemsData[i2];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          this.dynamicProperties[i2].getValue();
        }
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
      };
      CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!this.stylesList[i2].closed) {
            this.stylesList[i2].transforms.push(transform2);
          }
        }
      };
      CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i2;
        var len = this.stylesList.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!this.stylesList[i2].closed) {
            this.stylesList[i2].transforms.pop();
          }
        }
      };
      CVShapeElement.prototype.closeStyles = function(styles) {
        var i2;
        var len = styles.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          styles[i2].closed = true;
        }
      };
      CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
        var i2;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);
        for (i2 = len; i2 >= 0; i2 -= 1) {
          processedPos = this.searchProcessedElement(arr[i2]);
          if (!processedPos) {
            arr[i2]._shouldRender = shouldRender;
          } else {
            itemsData[i2] = prevViewData[processedPos - 1];
          }
          if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs") {
            if (!processedPos) {
              itemsData[i2] = this.createStyleElement(arr[i2], ownTransforms);
            } else {
              itemsData[i2].style.closed = false;
            }
            ownStyles.push(itemsData[i2].style);
          } else if (arr[i2].ty === "gr") {
            if (!processedPos) {
              itemsData[i2] = this.createGroupElement(arr[i2]);
            } else {
              jLen = itemsData[i2].it.length;
              for (j = 0; j < jLen; j += 1) {
                itemsData[i2].prevViewData[j] = itemsData[i2].it[j];
              }
            }
            this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, shouldRender, ownTransforms);
          } else if (arr[i2].ty === "tr") {
            if (!processedPos) {
              currentTransform = this.createTransformElement(arr[i2]);
              itemsData[i2] = currentTransform;
            }
            ownTransforms.push(itemsData[i2]);
            this.addTransformToStyleList(itemsData[i2]);
          } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
            if (!processedPos) {
              itemsData[i2] = this.createShapeElement(arr[i2]);
            }
          } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "pb" || arr[i2].ty === "zz" || arr[i2].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              modifier.init(this, arr[i2]);
              itemsData[i2] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i2];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i2].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i2].ty);
              itemsData[i2] = modifier;
              modifier.init(this, arr, i2, itemsData);
              this.shapeModifiers.push(modifier);
              shouldRender = false;
            } else {
              modifier = itemsData[i2];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i2], i2 + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          ownModifiers[i2].closed = true;
        }
      };
      CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
      };
      CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
          groupTransform.opacity = parentTransform.opacity;
          groupTransform.opacity *= groupTransform.op.v;
          groupTransform._opMdf = true;
        }
      };
      CVShapeElement.prototype.drawLayer = function() {
        var i2;
        var len = this.stylesList.length;
        var j;
        var jLen;
        var k;
        var kLen;
        var elems;
        var nodes;
        var renderer = this.globalData.renderer;
        var ctx2 = this.globalData.canvasContext;
        var type2;
        var currentStyle;
        for (i2 = 0; i2 < len; i2 += 1) {
          currentStyle = this.stylesList[i2];
          type2 = currentStyle.type;
          if (!((type2 === "st" || type2 === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
            renderer.save();
            elems = currentStyle.elements;
            if (type2 === "st" || type2 === "gs") {
              renderer.ctxStrokeStyle(type2 === "st" ? currentStyle.co : currentStyle.grd);
              renderer.ctxLineWidth(currentStyle.wi);
              renderer.ctxLineCap(currentStyle.lc);
              renderer.ctxLineJoin(currentStyle.lj);
              renderer.ctxMiterLimit(currentStyle.ml || 0);
            } else {
              renderer.ctxFillStyle(type2 === "fl" ? currentStyle.co : currentStyle.grd);
            }
            renderer.ctxOpacity(currentStyle.coOp);
            if (type2 !== "st" && type2 !== "gs") {
              ctx2.beginPath();
            }
            renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;
            for (j = 0; j < jLen; j += 1) {
              if (type2 === "st" || type2 === "gs") {
                ctx2.beginPath();
                if (currentStyle.da) {
                  ctx2.setLineDash(currentStyle.da);
                  ctx2.lineDashOffset = currentStyle["do"];
                }
              }
              nodes = elems[j].trNodes;
              kLen = nodes.length;
              for (k = 0; k < kLen; k += 1) {
                if (nodes[k].t === "m") {
                  ctx2.moveTo(nodes[k].p[0], nodes[k].p[1]);
                } else if (nodes[k].t === "c") {
                  ctx2.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
                } else {
                  ctx2.closePath();
                }
              }
              if (type2 === "st" || type2 === "gs") {
                renderer.ctxStroke();
                if (currentStyle.da) {
                  ctx2.setLineDash(this.dashResetter);
                }
              }
            }
            if (type2 !== "st" && type2 !== "gs") {
              this.globalData.renderer.ctxFill(currentStyle.r);
            }
            renderer.restore();
          }
        }
      };
      CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
        var i2;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for (i2 = len; i2 >= 0; i2 -= 1) {
          if (items[i2].ty === "tr") {
            groupTransform = data2[i2].transform;
            this.renderShapeTransform(parentTransform, groupTransform);
          } else if (items[i2].ty === "sh" || items[i2].ty === "el" || items[i2].ty === "rc" || items[i2].ty === "sr") {
            this.renderPath(items[i2], data2[i2]);
          } else if (items[i2].ty === "fl") {
            this.renderFill(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "st") {
            this.renderStroke(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "gf" || items[i2].ty === "gs") {
            this.renderGradientFill(items[i2], data2[i2], groupTransform);
          } else if (items[i2].ty === "gr") {
            this.renderShape(groupTransform, items[i2].it, data2[i2].it);
          } else if (items[i2].ty === "tm") ;
        }
        if (isMain) {
          this.drawLayer();
        }
      };
      CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
          var shapeNodes = styledShape.trNodes;
          var paths = shape.paths;
          var i2;
          var len;
          var j;
          var jLen = paths._length;
          shapeNodes.length = 0;
          var groupTransformMat = styledShape.transforms.finalTransform;
          for (j = 0; j < jLen; j += 1) {
            var pathNodes = paths.shapes[j];
            if (pathNodes && pathNodes.v) {
              len = pathNodes._length;
              for (i2 = 1; i2 < len; i2 += 1) {
                if (i2 === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[i2], pathNodes.v[i2])
                });
              }
              if (len === 1) {
                shapeNodes.push({
                  t: "m",
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              if (pathNodes.c && len) {
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[0], pathNodes.v[0])
                });
                shapeNodes.push({
                  t: "z"
                });
              }
            }
          }
          styledShape.trNodes = shapeNodes;
        }
      };
      CVShapeElement.prototype.renderPath = function(pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
          var i2;
          var len = itemData.styledShapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.renderStyledShape(itemData.styledShapes[i2], itemData.sh);
          }
        }
      };
      CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
      };
      CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;
        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
          var ctx2 = this.globalData.canvasContext;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (styleData.t === 1) {
            grd = ctx2.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
          } else {
            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            grd = ctx2.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
          }
          var i2;
          var len = styleData.g.p;
          var cValues = itemData.g.c;
          var opacity = 1;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (itemData.g._hasOpacity && itemData.g._collapsable) {
              opacity = itemData.g.o[i2 * 2 + 1];
            }
            grd.addColorStop(cValues[i2 * 4] / 100, "rgba(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + "," + opacity + ")");
          }
          styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      };
      CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d2 = itemData.d;
        if (d2 && (d2._mdf || this._isFirstFrame)) {
          styleElem.da = d2.dashArray;
          styleElem["do"] = d2.dashoffset[0];
        }
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
        if (itemData.w._mdf || this._isFirstFrame) {
          styleElem.wi = itemData.w.v;
        }
      };
      CVShapeElement.prototype.destroy = function() {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
      };
      function CVTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = "canvas";
        this.values = {
          fill: "rgba(0,0,0,0)",
          stroke: "rgba(0,0,0,0)",
          sWidth: 0,
          fValue: ""
        };
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
      CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
      CVTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;
        if (documentData.fc) {
          hasFill = true;
          this.values.fill = this.buildColor(documentData.fc);
        } else {
          this.values.fill = "rgba(0,0,0,0)";
        }
        this.fill = hasFill;
        var hasStroke = false;
        if (documentData.sc) {
          hasStroke = true;
          this.values.stroke = this.buildColor(documentData.sc);
          this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i2;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length;
        var charData;
        var shapeData;
        var k;
        var kLen;
        var shapes;
        var j;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          matrixHelper.reset();
          if (singleShape && letters[i2].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }
          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
          jLen = shapes.length;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          if (singleShape) {
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
          }
          commands = createSizedArray(jLen - 1);
          var commandsCounter = 0;
          for (j = 0; j < jLen; j += 1) {
            if (shapes[j].ty === "sh") {
              kLen = shapes[j].ks.k.i.length;
              pathNodes = shapes[j].ks.k;
              pathArr = [];
              for (k = 1; k < kLen; k += 1) {
                if (k === 1) {
                  pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              commands[commandsCounter] = pathArr;
              commandsCounter += 1;
            }
          }
          if (singleShape) {
            xPos += letters[i2].l;
            xPos += trackingOffset;
          }
          if (this.textSpans[cnt]) {
            this.textSpans[cnt].elem = commands;
          } else {
            this.textSpans[cnt] = {
              elem: commands
            };
          }
          cnt += 1;
        }
      };
      CVTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var ctx2 = this.canvasContext;
        ctx2.font = this.values.fValue;
        this.globalData.renderer.ctxLineCap("butt");
        this.globalData.renderer.ctxLineJoin("miter");
        this.globalData.renderer.ctxMiterLimit(4);
        if (!this.data.singleShape) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }
        var i2;
        var len;
        var j;
        var jLen;
        var k;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;
        var renderer = this.globalData.renderer;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (!letters[i2].n) {
            renderedLetter = renderedLetters[i2];
            if (renderedLetter) {
              renderer.save();
              renderer.ctxTransform(renderedLetter.p);
              renderer.ctxOpacity(renderedLetter.o);
            }
            if (this.fill) {
              if (renderedLetter && renderedLetter.fc) {
                if (lastFill !== renderedLetter.fc) {
                  renderer.ctxFillStyle(renderedLetter.fc);
                  lastFill = renderedLetter.fc;
                }
              } else if (lastFill !== this.values.fill) {
                lastFill = this.values.fill;
                renderer.ctxFillStyle(this.values.fill);
              }
              commands = this.textSpans[i2].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer.ctxFill();
            }
            if (this.stroke) {
              if (renderedLetter && renderedLetter.sw) {
                if (lastStrokeW !== renderedLetter.sw) {
                  lastStrokeW = renderedLetter.sw;
                  renderer.ctxLineWidth(renderedLetter.sw);
                }
              } else if (lastStrokeW !== this.values.sWidth) {
                lastStrokeW = this.values.sWidth;
                renderer.ctxLineWidth(this.values.sWidth);
              }
              if (renderedLetter && renderedLetter.sc) {
                if (lastStroke !== renderedLetter.sc) {
                  lastStroke = renderedLetter.sc;
                  renderer.ctxStrokeStyle(renderedLetter.sc);
                }
              } else if (lastStroke !== this.values.stroke) {
                lastStroke = this.values.stroke;
                renderer.ctxStrokeStyle(this.values.stroke);
              }
              commands = this.textSpans[i2].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer.ctxStroke();
            }
            if (renderedLetter) {
              this.globalData.renderer.restore();
            }
          }
        }
      };
      function CVImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.img = globalData2.imageLoader.getAsset(this.assetData);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVImageElement.prototype.createContent = function() {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
          var canvas = createTag("canvas");
          canvas.width = this.assetData.w;
          canvas.height = this.assetData.h;
          var ctx2 = canvas.getContext("2d");
          var imgW = this.img.width;
          var imgH = this.img.height;
          var imgRel = imgW / imgH;
          var canvasRel = this.assetData.w / this.assetData.h;
          var widthCrop;
          var heightCrop;
          var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
          if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
            heightCrop = imgH;
            widthCrop = heightCrop * canvasRel;
          } else {
            widthCrop = imgW;
            heightCrop = widthCrop / canvasRel;
          }
          ctx2.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
          this.img = canvas;
        }
      };
      CVImageElement.prototype.renderInnerContent = function() {
        this.canvasContext.drawImage(this.img, 0, 0);
      };
      CVImageElement.prototype.destroy = function() {
        this.img = null;
      };
      function CVSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVSolidElement.prototype.renderInnerContent = function() {
        this.globalData.renderer.ctxFillStyle(this.data.sc);
        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
      };
      function CanvasRendererBase() {
      }
      extendPrototype([BaseRenderer], CanvasRendererBase);
      CanvasRendererBase.prototype.createShape = function(data2) {
        return new CVShapeElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createText = function(data2) {
        return new CVTextElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createImage = function(data2) {
        return new CVImageElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createSolid = function(data2) {
        return new CVSolidElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      CanvasRendererBase.prototype.ctxTransform = function(props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
          return;
        }
        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
      };
      CanvasRendererBase.prototype.ctxOpacity = function(op) {
        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
      };
      CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
        this.canvasContext.fillStyle = value2;
      };
      CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
        this.canvasContext.strokeStyle = value2;
      };
      CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
        this.canvasContext.lineWidth = value2;
      };
      CanvasRendererBase.prototype.ctxLineCap = function(value2) {
        this.canvasContext.lineCap = value2;
      };
      CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
        this.canvasContext.lineJoin = value2;
      };
      CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
        this.canvasContext.miterLimit = value2;
      };
      CanvasRendererBase.prototype.ctxFill = function(rule) {
        this.canvasContext.fill(rule);
      };
      CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {
        this.canvasContext.fillRect(x, y, w, h);
      };
      CanvasRendererBase.prototype.ctxStroke = function() {
        this.canvasContext.stroke();
      };
      CanvasRendererBase.prototype.reset = function() {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        this.contextData.reset();
      };
      CanvasRendererBase.prototype.save = function() {
        this.canvasContext.save();
      };
      CanvasRendererBase.prototype.restore = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        if (actionFlag) {
          this.globalData.blendMode = "source-over";
        }
        this.contextData.restore(actionFlag);
      };
      CanvasRendererBase.prototype.configAnimation = function(animData) {
        if (this.animationItem.wrapper) {
          this.animationItem.container = createTag("canvas");
          var containerStyle = this.animationItem.container.style;
          containerStyle.width = "100%";
          containerStyle.height = "100%";
          var origin = "0px 0px 0px";
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          containerStyle["-webkit-transform"] = origin;
          containerStyle.contentVisibility = this.renderConfig.contentVisibility;
          this.animationItem.wrapper.appendChild(this.animationItem.container);
          this.canvasContext = this.animationItem.container.getContext("2d");
          if (this.renderConfig.className) {
            this.animationItem.container.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.animationItem.container.setAttribute("id", this.renderConfig.id);
          }
        } else {
          this.canvasContext = this.renderConfig.context;
        }
        this.contextData.setContext(this.canvasContext);
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
          w: animData.w,
          h: animData.h,
          sx: 0,
          sy: 0,
          tx: 0,
          ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
      };
      CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
        this.reset();
        var elementWidth;
        var elementHeight;
        if (width2) {
          elementWidth = width2;
          elementHeight = height2;
          this.canvasContext.canvas.width = elementWidth;
          this.canvasContext.canvas.height = elementHeight;
        } else {
          if (this.animationItem.wrapper && this.animationItem.container) {
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
          } else {
            elementWidth = this.canvasContext.canvas.width;
            elementHeight = this.canvasContext.canvas.height;
          }
          this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
          this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
        }
        var elementRel;
        var animationRel;
        if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
          var par = this.renderConfig.preserveAspectRatio.split(" ");
          var fillType = par[1] || "meet";
          var pos = par[0] || "xMidYMid";
          var xPos = pos.substr(0, 4);
          var yPos = pos.substr(4);
          elementRel = elementWidth / elementHeight;
          animationRel = this.transformCanvas.w / this.transformCanvas.h;
          if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          } else {
            this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          }
          if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
          } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.tx = 0;
          }
          if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
          } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.ty = 0;
          }
        } else if (this.renderConfig.preserveAspectRatio === "none") {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        } else {
          this.transformCanvas.sx = this.renderConfig.dpr;
          this.transformCanvas.sy = this.renderConfig.dpr;
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
      };
      CanvasRendererBase.prototype.destroy = function() {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
      };
      CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
          return;
        }
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num;
        var i2;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].prepareFrame(num - this.layers[i2].st);
          }
        }
        if (this.globalData._mdf) {
          if (this.renderConfig.clearCanvas === true) {
            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          } else {
            this.save();
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
          if (this.renderConfig.clearCanvas !== true) {
            this.restore();
          }
        }
      };
      CanvasRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
      };
      CanvasRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      CanvasRendererBase.prototype.hide = function() {
        this.animationItem.container.style.display = "none";
      };
      CanvasRendererBase.prototype.show = function() {
        this.animationItem.container.style.display = "block";
      };
      function CanvasContext() {
        this.opacity = -1;
        this.transform = createTypedArray("float32", 16);
        this.fillStyle = "";
        this.strokeStyle = "";
        this.lineWidth = "";
        this.lineCap = "";
        this.lineJoin = "";
        this.miterLimit = "";
        this.id = Math.random();
      }
      function CVContextData() {
        this.stack = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        var i2;
        var len = 15;
        for (i2 = 0; i2 < len; i2 += 1) {
          var canvasContext = new CanvasContext();
          this.stack[i2] = canvasContext;
        }
        this._length = len;
        this.nativeContext = null;
        this.transformMat = new Matrix();
        this.currentOpacity = 1;
        this.currentFillStyle = "";
        this.appliedFillStyle = "";
        this.currentStrokeStyle = "";
        this.appliedStrokeStyle = "";
        this.currentLineWidth = "";
        this.appliedLineWidth = "";
        this.currentLineCap = "";
        this.appliedLineCap = "";
        this.currentLineJoin = "";
        this.appliedLineJoin = "";
        this.appliedMiterLimit = "";
        this.currentMiterLimit = "";
      }
      CVContextData.prototype.duplicate = function() {
        var newLength = this._length * 2;
        var i2 = 0;
        for (i2 = this._length; i2 < newLength; i2 += 1) {
          this.stack[i2] = new CanvasContext();
        }
        this._length = newLength;
      };
      CVContextData.prototype.reset = function() {
        this.cArrPos = 0;
        this.cTr.reset();
        this.stack[this.cArrPos].opacity = 1;
      };
      CVContextData.prototype.restore = function(forceRestore) {
        this.cArrPos -= 1;
        var currentContext = this.stack[this.cArrPos];
        var transform2 = currentContext.transform;
        var i2;
        var arr = this.cTr.props;
        for (i2 = 0; i2 < 16; i2 += 1) {
          arr[i2] = transform2[i2];
        }
        if (forceRestore) {
          this.nativeContext.restore();
          var prevStack = this.stack[this.cArrPos + 1];
          this.appliedFillStyle = prevStack.fillStyle;
          this.appliedStrokeStyle = prevStack.strokeStyle;
          this.appliedLineWidth = prevStack.lineWidth;
          this.appliedLineCap = prevStack.lineCap;
          this.appliedLineJoin = prevStack.lineJoin;
          this.appliedMiterLimit = prevStack.miterLimit;
        }
        this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
          this.nativeContext.globalAlpha = currentContext.opacity;
          this.currentOpacity = currentContext.opacity;
        }
        this.currentFillStyle = currentContext.fillStyle;
        this.currentStrokeStyle = currentContext.strokeStyle;
        this.currentLineWidth = currentContext.lineWidth;
        this.currentLineCap = currentContext.lineCap;
        this.currentLineJoin = currentContext.lineJoin;
        this.currentMiterLimit = currentContext.miterLimit;
      };
      CVContextData.prototype.save = function(saveOnNativeFlag) {
        if (saveOnNativeFlag) {
          this.nativeContext.save();
        }
        var props = this.cTr.props;
        if (this._length <= this.cArrPos) {
          this.duplicate();
        }
        var currentStack = this.stack[this.cArrPos];
        var i2;
        for (i2 = 0; i2 < 16; i2 += 1) {
          currentStack.transform[i2] = props[i2];
        }
        this.cArrPos += 1;
        var newStack = this.stack[this.cArrPos];
        newStack.opacity = currentStack.opacity;
        newStack.fillStyle = currentStack.fillStyle;
        newStack.strokeStyle = currentStack.strokeStyle;
        newStack.lineWidth = currentStack.lineWidth;
        newStack.lineCap = currentStack.lineCap;
        newStack.lineJoin = currentStack.lineJoin;
        newStack.miterLimit = currentStack.miterLimit;
      };
      CVContextData.prototype.setOpacity = function(value2) {
        this.stack[this.cArrPos].opacity = value2;
      };
      CVContextData.prototype.setContext = function(value2) {
        this.nativeContext = value2;
      };
      CVContextData.prototype.fillStyle = function(value2) {
        if (this.stack[this.cArrPos].fillStyle !== value2) {
          this.currentFillStyle = value2;
          this.stack[this.cArrPos].fillStyle = value2;
        }
      };
      CVContextData.prototype.strokeStyle = function(value2) {
        if (this.stack[this.cArrPos].strokeStyle !== value2) {
          this.currentStrokeStyle = value2;
          this.stack[this.cArrPos].strokeStyle = value2;
        }
      };
      CVContextData.prototype.lineWidth = function(value2) {
        if (this.stack[this.cArrPos].lineWidth !== value2) {
          this.currentLineWidth = value2;
          this.stack[this.cArrPos].lineWidth = value2;
        }
      };
      CVContextData.prototype.lineCap = function(value2) {
        if (this.stack[this.cArrPos].lineCap !== value2) {
          this.currentLineCap = value2;
          this.stack[this.cArrPos].lineCap = value2;
        }
      };
      CVContextData.prototype.lineJoin = function(value2) {
        if (this.stack[this.cArrPos].lineJoin !== value2) {
          this.currentLineJoin = value2;
          this.stack[this.cArrPos].lineJoin = value2;
        }
      };
      CVContextData.prototype.miterLimit = function(value2) {
        if (this.stack[this.cArrPos].miterLimit !== value2) {
          this.currentMiterLimit = value2;
          this.stack[this.cArrPos].miterLimit = value2;
        }
      };
      CVContextData.prototype.transform = function(props) {
        this.transformMat.cloneFromProps(props);
        var currentTransform = this.cTr;
        this.transformMat.multiply(currentTransform);
        currentTransform.cloneFromProps(this.transformMat.props);
        var trProps = currentTransform.props;
        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
      };
      CVContextData.prototype.opacity = function(op) {
        var currentOpacity = this.stack[this.cArrPos].opacity;
        currentOpacity *= op < 0 ? 0 : op;
        if (this.stack[this.cArrPos].opacity !== currentOpacity) {
          if (this.currentOpacity !== op) {
            this.nativeContext.globalAlpha = op;
            this.currentOpacity = op;
          }
          this.stack[this.cArrPos].opacity = currentOpacity;
        }
      };
      CVContextData.prototype.fill = function(rule) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fill(rule);
      };
      CVContextData.prototype.fillRect = function(x, y, w, h) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fillRect(x, y, w, h);
      };
      CVContextData.prototype.stroke = function() {
        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
          this.appliedStrokeStyle = this.currentStrokeStyle;
          this.nativeContext.strokeStyle = this.appliedStrokeStyle;
        }
        if (this.appliedLineWidth !== this.currentLineWidth) {
          this.appliedLineWidth = this.currentLineWidth;
          this.nativeContext.lineWidth = this.appliedLineWidth;
        }
        if (this.appliedLineCap !== this.currentLineCap) {
          this.appliedLineCap = this.currentLineCap;
          this.nativeContext.lineCap = this.appliedLineCap;
        }
        if (this.appliedLineJoin !== this.currentLineJoin) {
          this.appliedLineJoin = this.currentLineJoin;
          this.nativeContext.lineJoin = this.appliedLineJoin;
        }
        if (this.appliedMiterLimit !== this.currentMiterLimit) {
          this.appliedMiterLimit = this.currentMiterLimit;
          this.nativeContext.miterLimit = this.appliedMiterLimit;
        }
        this.nativeContext.stroke();
      };
      function CVCompElement(data2, globalData2, comp2) {
        this.completeLayers = false;
        this.layers = data2.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
      CVCompElement.prototype.renderInnerContent = function() {
        var ctx2 = this.canvasContext;
        ctx2.beginPath();
        ctx2.moveTo(0, 0);
        ctx2.lineTo(this.data.w, 0);
        ctx2.lineTo(this.data.w, this.data.h);
        ctx2.lineTo(0, this.data.h);
        ctx2.lineTo(0, 0);
        ctx2.clip();
        var i2;
        var len = this.layers.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.completeLayers || this.elements[i2]) {
            this.elements[i2].renderFrame();
          }
        }
      };
      CVCompElement.prototype.destroy = function() {
        var i2;
        var len = this.layers.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          if (this.elements[i2]) {
            this.elements[i2].destroy();
          }
        }
        this.layers = null;
        this.elements = null;
      };
      CVCompElement.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function CanvasRenderer(animationItem, config2) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config2 && config2.clearCanvas !== void 0 ? config2.clearCanvas : true,
          context: config2 && config2.context || null,
          progressiveLoad: config2 && config2.progressiveLoad || false,
          preserveAspectRatio: config2 && config2.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config2 && config2.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config2 && config2.contentVisibility || "visible",
          className: config2 && config2.className || "",
          id: config2 && config2.id || "",
          runExpressions: !config2 || config2.runExpressions === void 0 || config2.runExpressions
        };
        this.renderConfig.dpr = config2 && config2.dpr || 1;
        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config2 && config2.dpr || window.devicePixelRatio || 1;
        }
        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
        if (this.renderConfig.clearCanvas) {
          this.ctxTransform = this.contextData.transform.bind(this.contextData);
          this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
          this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
          this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
          this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
          this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
          this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
          this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
          this.ctxFill = this.contextData.fill.bind(this.contextData);
          this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
          this.ctxStroke = this.contextData.stroke.bind(this.contextData);
          this.save = this.contextData.save.bind(this.contextData);
        }
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer);
      CanvasRenderer.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function HBaseElement() {
      }
      HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {
        },
        initRendererElement: function initRendererElement() {
          this.baseElement = createTag(this.data.tg || "div");
          if (this.data.hasMask) {
            this.svgElement = createNS("svg");
            this.layerElement = createNS("g");
            this.maskedElement = this.layerElement;
            this.svgElement.appendChild(this.layerElement);
            this.baseElement.appendChild(this.svgElement);
          } else {
            this.layerElement = this.baseElement;
          }
          styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
          this.renderableEffectsManager = new CVEffects(this);
          this.transformedElement = this.baseElement;
          this.maskedElement = this.layerElement;
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var matrixValue = this.finalTransform.mat.toCSS();
            transformedElementStyle.transform = matrixValue;
            transformedElementStyle.webkitTransform = matrixValue;
          }
          if (this.finalTransform._opMdf) {
            transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
          }
        },
        renderFrame: function renderFrame() {
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.layerElement = null;
          this.transformedElement = null;
          if (this.matteElement) {
            this.matteElement = null;
          }
          if (this.maskManager) {
            this.maskManager.destroy();
            this.maskManager = null;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {
        },
        setMatte: function setMatte() {
        }
      };
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
      function HSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
      HSolidElement.prototype.createContent = function() {
        var rect;
        if (this.data.hasMask) {
          rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.svgElement.setAttribute("width", this.data.sw);
          this.svgElement.setAttribute("height", this.data.sh);
        } else {
          rect = createTag("div");
          rect.style.width = this.data.sw + "px";
          rect.style.height = this.data.sh + "px";
          rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
      };
      function HShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.shapesContainer = createNS("g");
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
      }
      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
      HShapeElement.prototype.createContent = function() {
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
          this.layerElement.appendChild(this.shapesContainer);
          cont = this.svgElement;
        } else {
          cont = createNS("svg");
          var size = this.comp.data ? this.comp.data : this.globalData.compSize;
          cont.setAttribute("width", size.w);
          cont.setAttribute("height", size.h);
          cont.appendChild(this.shapesContainer);
          this.layerElement.appendChild(cont);
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
      };
      HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
        var i2;
        var len = transformers.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          point = transformers[i2].mProps.v.applyToPointArray(point[0], point[1], 0);
        }
        return point;
      };
      HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i2;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;
        if (len <= 1) {
          return;
        }
        for (i2 = 0; i2 < len - 1; i2 += 1) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[i2 + 1]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[i2 + 1]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if (shape.c) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
      };
      HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
      };
      HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
      };
      HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
        var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
        for (var a, b, c6, t, b2ac, t1, t2, i2 = 0; i2 < 2; ++i2) {
          b = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
          a = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
          c6 = 3 * p1[i2] - 3 * p0[i2];
          b |= 0;
          a |= 0;
          c6 |= 0;
          if (a === 0 && b === 0) ;
          else if (a === 0) {
            t = -c6 / b;
            if (t > 0 && t < 1) {
              bounds[i2].push(this.calculateF(t, p0, p1, p2, p3, i2));
            }
          } else {
            b2ac = b * b - 4 * c6 * a;
            if (b2ac >= 0) {
              t1 = (-b + bmSqrt(b2ac)) / (2 * a);
              if (t1 > 0 && t1 < 1) bounds[i2].push(this.calculateF(t1, p0, p1, p2, p3, i2));
              t2 = (-b - bmSqrt(b2ac)) / (2 * a);
              if (t2 > 0 && t2 < 1) bounds[i2].push(this.calculateF(t2, p0, p1, p2, p3, i2));
            }
          }
        }
        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
      };
      HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i2) {
        return bmPow(1 - t, 3) * p0[i2] + 3 * bmPow(1 - t, 2) * t * p1[i2] + 3 * (1 - t) * bmPow(t, 2) * p2[i2] + bmPow(t, 3) * p3[i2];
      };
      HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i2;
        var len = itemsData.length;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (itemsData[i2] && itemsData[i2].sh) {
            this.calculateShapeBoundingBox(itemsData[i2], boundingBox);
          } else if (itemsData[i2] && itemsData[i2].it) {
            this.calculateBoundingBox(itemsData[i2].it, boundingBox);
          } else if (itemsData[i2] && itemsData[i2].style && itemsData[i2].w) {
            this.expandStrokeBoundingBox(itemsData[i2].w, boundingBox);
          }
        }
      };
      HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
        var width2 = 0;
        if (widthProperty.keyframes) {
          for (var i2 = 0; i2 < widthProperty.keyframes.length; i2 += 1) {
            var kfw = widthProperty.keyframes[i2].s;
            if (kfw > width2) {
              width2 = kfw;
            }
          }
          width2 *= widthProperty.mult;
        } else {
          width2 = widthProperty.v * widthProperty.mult;
        }
        boundingBox.x -= width2;
        boundingBox.xMax += width2;
        boundingBox.y -= width2;
        boundingBox.yMax += width2;
      };
      HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
      };
      HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();
        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
          var tempBoundingBox = this.tempBoundingBox;
          var max = 999999;
          tempBoundingBox.x = max;
          tempBoundingBox.xMax = -max;
          tempBoundingBox.y = max;
          tempBoundingBox.yMax = -max;
          this.calculateBoundingBox(this.itemsData, tempBoundingBox);
          tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
          tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
          if (this.currentBoxContains(tempBoundingBox)) {
            return;
          }
          var changed = false;
          if (this.currentBBox.w !== tempBoundingBox.width) {
            this.currentBBox.w = tempBoundingBox.width;
            this.shapeCont.setAttribute("width", tempBoundingBox.width);
            changed = true;
          }
          if (this.currentBBox.h !== tempBoundingBox.height) {
            this.currentBBox.h = tempBoundingBox.height;
            this.shapeCont.setAttribute("height", tempBoundingBox.height);
            changed = true;
          }
          if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
            this.currentBBox.w = tempBoundingBox.width;
            this.currentBBox.h = tempBoundingBox.height;
            this.currentBBox.x = tempBoundingBox.x;
            this.currentBBox.y = tempBoundingBox.y;
            this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            var shapeStyle = this.shapeCont.style;
            var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            shapeStyle.transform = shapeTransform;
            shapeStyle.webkitTransform = shapeTransform;
          }
        }
      };
      function HTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
        this.renderType = "svg";
        this.isMasked = false;
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
      HTextElement.prototype.createContent = function() {
        this.isMasked = this.checkMasks();
        if (this.isMasked) {
          this.renderType = "svg";
          this.compW = this.comp.data.w;
          this.compH = this.comp.data.h;
          this.svgElement.setAttribute("width", this.compW);
          this.svgElement.setAttribute("height", this.compH);
          var g = createNS("g");
          this.maskedElement.appendChild(g);
          this.innerElem = g;
        } else {
          this.renderType = "html";
          this.innerElem = this.layerElement;
        }
        this.checkParenting();
      };
      HTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;
        if (documentData.sc) {
          innerElemStyle.stroke = this.buildColor(documentData.sc);
          innerElemStyle.strokeWidth = documentData.sw + "px";
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (!this.globalData.fontManager.chars) {
          innerElemStyle.fontSize = documentData.finalSize + "px";
          innerElemStyle.lineHeight = documentData.finalSize + "px";
          if (fontData.fClass) {
            this.innerElem.className = fontData.fClass;
          } else {
            innerElemStyle.fontFamily = fontData.fFamily;
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            innerElemStyle.fontStyle = fStyle;
            innerElemStyle.fontWeight = fWeight;
          }
        }
        var i2;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = "";
        var cnt = 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.globalData.fontManager.chars) {
            if (!this.textPaths[cnt]) {
              tSpan = createNS("path");
              tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
              tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
              tSpan.setAttribute("stroke-miterlimit", "4");
            } else {
              tSpan = this.textPaths[cnt];
            }
            if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tCont = tParent.children[0];
              } else {
                tParent = createTag("div");
                tParent.style.lineHeight = 0;
                tCont = createNS("svg");
                tCont.appendChild(tSpan);
                styleDiv(tParent);
              }
            }
          } else if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tSpan = this.textPaths[cnt];
            } else {
              tParent = createTag("span");
              styleDiv(tParent);
              tSpan = createTag("span");
              styleDiv(tSpan);
              tParent.appendChild(tSpan);
            }
          } else {
            tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
          }
          if (this.globalData.fontManager.chars) {
            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var shapeData;
            if (charData) {
              shapeData = charData.data;
            } else {
              shapeData = null;
            }
            matrixHelper.reset();
            if (shapeData && shapeData.shapes && shapeData.shapes.length) {
              shapes = shapeData.shapes[0].it;
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              shapeStr = this.createPathShape(matrixHelper, shapes);
              tSpan.setAttribute("d", shapeStr);
            }
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              if (shapeData && shapeData.shapes) {
                document.body.appendChild(tCont);
                var boundingBox = tCont.getBBox();
                tCont.setAttribute("width", boundingBox.width + 2);
                tCont.setAttribute("height", boundingBox.height + 2);
                tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                var tContStyle = tCont.style;
                var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                tContStyle.transform = tContTranslation;
                tContStyle.webkitTransform = tContTranslation;
                letters[i2].yOffset = boundingBox.y - 1;
              } else {
                tCont.setAttribute("width", 1);
                tCont.setAttribute("height", 1);
              }
              tParent.appendChild(tCont);
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } else {
            tSpan.textContent = letters[i2].val;
            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              var tStyle = tSpan.style;
              var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
              tStyle.transform = tSpanTranslation;
              tStyle.webkitTransform = tSpanTranslation;
            } else {
              this.innerElem.appendChild(tSpan);
            }
          }
          if (!this.isMasked) {
            this.textSpans[cnt] = tParent;
          } else {
            this.textSpans[cnt] = tSpan;
          }
          this.textSpans[cnt].style.display = "block";
          this.textPaths[cnt] = tSpan;
          cnt += 1;
        }
        while (cnt < this.textSpans.length) {
          this.textSpans[cnt].style.display = "none";
          cnt += 1;
        }
      };
      HTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var svgStyle;
        if (this.data.singleShape) {
          if (!this._isFirstFrame && !this.lettersChangedFlag) {
            return;
          }
          if (this.isMasked && this.finalTransform._matMdf) {
            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
            svgStyle = this.svgElement.style;
            var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
            svgStyle.transform = translation;
            svgStyle.webkitTransform = translation;
          }
        }
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
          return;
        }
        var i2;
        var len;
        var count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (letters[i2].n) {
            count += 1;
          } else {
            textSpan = this.textSpans[i2];
            textPath = this.textPaths[i2];
            renderedLetter = renderedLetters[count];
            count += 1;
            if (renderedLetter._mdf.m) {
              if (!this.isMasked) {
                textSpan.style.webkitTransform = renderedLetter.m;
                textSpan.style.transform = renderedLetter.m;
              } else {
                textSpan.setAttribute("transform", renderedLetter.m);
              }
            }
            textSpan.style.opacity = renderedLetter.o;
            if (renderedLetter.sw && renderedLetter._mdf.sw) {
              textPath.setAttribute("stroke-width", renderedLetter.sw);
            }
            if (renderedLetter.sc && renderedLetter._mdf.sc) {
              textPath.setAttribute("stroke", renderedLetter.sc);
            }
            if (renderedLetter.fc && renderedLetter._mdf.fc) {
              textPath.setAttribute("fill", renderedLetter.fc);
              textPath.style.color = renderedLetter.fc;
            }
          }
        }
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var boundingBox = this.innerElem.getBBox();
          if (this.currentBBox.w !== boundingBox.width) {
            this.currentBBox.w = boundingBox.width;
            this.svgElement.setAttribute("width", boundingBox.width);
          }
          if (this.currentBBox.h !== boundingBox.height) {
            this.currentBBox.h = boundingBox.height;
            this.svgElement.setAttribute("height", boundingBox.height);
          }
          var margin = 1;
          if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
            this.currentBBox.w = boundingBox.width + margin * 2;
            this.currentBBox.h = boundingBox.height + margin * 2;
            this.currentBBox.x = boundingBox.x - margin;
            this.currentBBox.y = boundingBox.y - margin;
            this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            svgStyle = this.svgElement.style;
            var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            svgStyle.transform = svgTransform;
            svgStyle.webkitTransform = svgTransform;
          }
        }
      };
      function HCameraElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data2.pe, 0, 0, this);
        if (data2.ks.p.s) {
          this.px = getProp(this, data2.ks.p.x, 1, 0, this);
          this.py = getProp(this, data2.ks.p.y, 1, 0, this);
          this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
        } else {
          this.p = getProp(this, data2.ks.p, 1, 0, this);
        }
        if (data2.ks.a) {
          this.a = getProp(this, data2.ks.a, 1, 0, this);
        }
        if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
          var i2;
          var len = data2.ks.or.k.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            data2.ks.or.k[i2].to = null;
            data2.ks.or.k[i2].ti = null;
          }
        }
        this.or = getProp(this, data2.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true;
        this.finalTransform = {
          mProp: this
        };
      }
      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
      HCameraElement.prototype.setup = function() {
        var i2;
        var len = this.comp.threeDElements.length;
        var comp2;
        var perspectiveStyle;
        var containerStyle;
        for (i2 = 0; i2 < len; i2 += 1) {
          comp2 = this.comp.threeDElements[i2];
          if (comp2.type === "3d") {
            perspectiveStyle = comp2.perspectiveElem.style;
            containerStyle = comp2.container.style;
            var perspective = this.pe.v + "px";
            var origin = "0px 0px 0px";
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            perspectiveStyle.perspective = perspective;
            perspectiveStyle.webkitPerspective = perspective;
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            perspectiveStyle.transform = matrix;
            perspectiveStyle.webkitTransform = matrix;
          }
        }
      };
      HCameraElement.prototype.createElements = function() {
      };
      HCameraElement.prototype.hide = function() {
      };
      HCameraElement.prototype.renderFrame = function() {
        var _mdf = this._isFirstFrame;
        var i2;
        var len;
        if (this.hierarchy) {
          len = this.hierarchy.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            _mdf = this.hierarchy[i2].finalTransform.mProp._mdf || _mdf;
          }
        }
        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
          this.mat.reset();
          if (this.hierarchy) {
            len = this.hierarchy.length - 1;
            for (i2 = len; i2 >= 0; i2 -= 1) {
              var mTransf = this.hierarchy[i2].finalTransform.mProp;
              this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
              this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
              this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
              this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
              this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
            }
          }
          if (this.p) {
            this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
          } else {
            this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
          }
          if (this.a) {
            var diffVector;
            if (this.p) {
              diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
            } else {
              diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
            }
            var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
            var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
            var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
            var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
            var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
            this.mat.rotateY(mRotationY).rotateX(-mRotationX);
          }
          this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
          this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
          this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
          this.mat.translate(0, 0, this.pe.v);
          var hasMatrixChanged = !this._prevMat.equals(this.mat);
          if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
            len = this.comp.threeDElements.length;
            var comp2;
            var perspectiveStyle;
            var containerStyle;
            for (i2 = 0; i2 < len; i2 += 1) {
              comp2 = this.comp.threeDElements[i2];
              if (comp2.type === "3d") {
                if (hasMatrixChanged) {
                  var matValue = this.mat.toCSS();
                  containerStyle = comp2.container.style;
                  containerStyle.transform = matValue;
                  containerStyle.webkitTransform = matValue;
                }
                if (this.pe._mdf) {
                  perspectiveStyle = comp2.perspectiveElem.style;
                  perspectiveStyle.perspective = this.pe.v + "px";
                  perspectiveStyle.webkitPerspective = this.pe.v + "px";
                }
              }
            }
            this.mat.clone(this._prevMat);
          }
        }
        this._isFirstFrame = false;
      };
      HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      HCameraElement.prototype.destroy = function() {
      };
      HCameraElement.prototype.getBaseElement = function() {
        return null;
      };
      function HImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
      HImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();
        if (this.data.hasMask) {
          this.imageElem = createNS("image");
          this.imageElem.setAttribute("width", this.assetData.w + "px");
          this.imageElem.setAttribute("height", this.assetData.h + "px");
          this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.imageElem);
          this.baseElement.setAttribute("width", this.assetData.w);
          this.baseElement.setAttribute("height", this.assetData.h);
        } else {
          this.layerElement.appendChild(img);
        }
        img.crossOrigin = "anonymous";
        img.src = assetPath;
        if (this.data.ln) {
          this.baseElement.setAttribute("id", this.data.ln);
        }
      };
      function HybridRendererBase(animationItem, config2) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config2 && config2.className || "",
          imagePreserveAspectRatio: config2 && config2.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config2 && config2.hideOnTransparent === false),
          filterSize: {
            width: config2 && config2.filterSize && config2.filterSize.width || "400%",
            height: config2 && config2.filterSize && config2.filterSize.height || "400%",
            x: config2 && config2.filterSize && config2.filterSize.x || "-100%",
            y: config2 && config2.filterSize && config2.filterSize.y || "-100%"
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([BaseRenderer], HybridRendererBase);
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
      HybridRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newDOMElement = element.getBaseElement();
        if (!newDOMElement) {
          return;
        }
        var layer = this.layers[pos];
        if (!layer.ddd || !this.supports3d) {
          if (this.threeDElements) {
            this.addTo3dContainer(newDOMElement, pos);
          } else {
            var i2 = 0;
            var nextDOMElement;
            var nextLayer;
            var tmpDOMElement;
            while (i2 < pos) {
              if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement) {
                nextLayer = this.elements[i2];
                tmpDOMElement = this.layers[i2].ddd ? this.getThreeDContainerByPos(i2) : nextLayer.getBaseElement();
                nextDOMElement = tmpDOMElement || nextDOMElement;
              }
              i2 += 1;
            }
            if (nextDOMElement) {
              if (!layer.ddd || !this.supports3d) {
                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
              }
            } else if (!layer.ddd || !this.supports3d) {
              this.layerElement.appendChild(newDOMElement);
            }
          }
        } else {
          this.addTo3dContainer(newDOMElement, pos);
        }
      };
      HybridRendererBase.prototype.createShape = function(data2) {
        if (!this.supports3d) {
          return new SVGShapeElement(data2, this.globalData, this);
        }
        return new HShapeElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createText = function(data2) {
        if (!this.supports3d) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        }
        return new HTextElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createCamera = function(data2) {
        this.camera = new HCameraElement(data2, this.globalData, this);
        return this.camera;
      };
      HybridRendererBase.prototype.createImage = function(data2) {
        if (!this.supports3d) {
          return new IImageElement(data2, this.globalData, this);
        }
        return new HImageElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createSolid = function(data2) {
        if (!this.supports3d) {
          return new ISolidElement(data2, this.globalData, this);
        }
        return new HSolidElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
        var i2 = 0;
        var len = this.threeDElements.length;
        while (i2 < len) {
          if (this.threeDElements[i2].startPos <= pos && this.threeDElements[i2].endPos >= pos) {
            return this.threeDElements[i2].perspectiveElem;
          }
          i2 += 1;
        }
        return null;
      };
      HybridRendererBase.prototype.createThreeDContainer = function(pos, type2) {
        var perspectiveElem = createTag("div");
        var style;
        var containerStyle;
        styleDiv(perspectiveElem);
        var container = createTag("div");
        styleDiv(container);
        if (type2 === "3d") {
          style = perspectiveElem.style;
          style.width = this.globalData.compSize.w + "px";
          style.height = this.globalData.compSize.h + "px";
          var center = "50% 50%";
          style.webkitTransformOrigin = center;
          style.mozTransformOrigin = center;
          style.transformOrigin = center;
          containerStyle = container.style;
          var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          containerStyle.transform = matrix;
          containerStyle.webkitTransform = matrix;
        }
        perspectiveElem.appendChild(container);
        var threeDContainerData = {
          container,
          perspectiveElem,
          startPos: pos,
          endPos: pos,
          type: type2
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
      };
      HybridRendererBase.prototype.build3dContainers = function() {
        var i2;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = "";
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.layers[i2].ddd && this.layers[i2].ty !== 3) {
            if (currentContainer !== "3d") {
              currentContainer = "3d";
              lastThreeDContainerData = this.createThreeDContainer(i2, "3d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
          } else {
            if (currentContainer !== "2d") {
              currentContainer = "2d";
              lastThreeDContainerData = this.createThreeDContainer(i2, "2d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
          }
        }
        len = this.threeDElements.length;
        for (i2 = len - 1; i2 >= 0; i2 -= 1) {
          this.resizerElem.appendChild(this.threeDElements[i2].perspectiveElem);
        }
      };
      HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
        var i2 = 0;
        var len = this.threeDElements.length;
        while (i2 < len) {
          if (pos <= this.threeDElements[i2].endPos) {
            var j = this.threeDElements[i2].startPos;
            var nextElement;
            while (j < pos) {
              if (this.elements[j] && this.elements[j].getBaseElement) {
                nextElement = this.elements[j].getBaseElement();
              }
              j += 1;
            }
            if (nextElement) {
              this.threeDElements[i2].container.insertBefore(elem2, nextElement);
            } else {
              this.threeDElements[i2].container.appendChild(elem2);
            }
            break;
          }
          i2 += 1;
        }
      };
      HybridRendererBase.prototype.configAnimation = function(animData) {
        var resizerElem = createTag("div");
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + "px";
        style.height = animData.h + "px";
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = "flat";
        style.mozTransformStyle = "flat";
        style.webkitTransformStyle = "flat";
        if (this.renderConfig.className) {
          resizerElem.setAttribute("class", this.renderConfig.className);
        }
        wrapper.appendChild(resizerElem);
        style.overflow = "hidden";
        var svg = createNS("svg");
        svg.setAttribute("width", "1");
        svg.setAttribute("height", "1");
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS("defs");
        svg.appendChild(defs);
        this.data = animData;
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
      };
      HybridRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i2;
        var len = this.layers ? this.layers.length : 0;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.elements[i2] && this.elements[i2].destroy) {
            this.elements[i2].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      HybridRendererBase.prototype.updateContainerSize = function() {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;
        if (animationRel > elementRel) {
          sx = elementWidth / this.globalData.compSize.w;
          sy = elementWidth / this.globalData.compSize.w;
          tx = 0;
          ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
          sx = elementHeight / this.globalData.compSize.h;
          sy = elementHeight / this.globalData.compSize.h;
          tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
          ty = 0;
        }
        var style = this.resizerElem.style;
        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
        style.transform = style.webkitTransform;
      };
      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
      HybridRendererBase.prototype.hide = function() {
        this.resizerElem.style.display = "none";
      };
      HybridRendererBase.prototype.show = function() {
        this.resizerElem.style.display = "block";
      };
      HybridRendererBase.prototype.initItems = function() {
        this.buildAllItems();
        if (this.camera) {
          this.camera.setup();
        } else {
          var cWidth = this.globalData.compSize.w;
          var cHeight = this.globalData.compSize.h;
          var i2;
          var len = this.threeDElements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            var style = this.threeDElements[i2].perspectiveElem.style;
            style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
            style.perspective = style.webkitPerspective;
          }
        }
      };
      HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
        var i2;
        var len = assets.length;
        var floatingContainer = createTag("div");
        for (i2 = 0; i2 < len; i2 += 1) {
          if (assets[i2].xt) {
            var comp2 = this.createComp(assets[i2], floatingContainer, this.globalData.comp, null);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      function HCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = !data2.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
      HCompElement.prototype.createContainerElements = function() {
        this._createBaseContainerElements();
        if (this.data.hasMask) {
          this.svgElement.setAttribute("width", this.data.w);
          this.svgElement.setAttribute("height", this.data.h);
          this.transformedElement = this.baseElement;
        } else {
          this.transformedElement = this.layerElement;
        }
      };
      HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
        var j = 0;
        var nextElement;
        while (j < pos) {
          if (this.elements[j] && this.elements[j].getBaseElement) {
            nextElement = this.elements[j].getBaseElement();
          }
          j += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(elem2, nextElement);
        } else {
          this.layerElement.appendChild(elem2);
        }
      };
      HCompElement.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      function HybridRenderer(animationItem, config2) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config2 && config2.className || "",
          imagePreserveAspectRatio: config2 && config2.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config2 && config2.hideOnTransparent === false),
          filterSize: {
            width: config2 && config2.filterSize && config2.filterSize.width || "400%",
            height: config2 && config2.filterSize && config2.filterSize.height || "400%",
            x: config2 && config2.filterSize && config2.filterSize.x || "-100%",
            y: config2 && config2.filterSize && config2.filterSize.y || "-100%"
          },
          runExpressions: !config2 || config2.runExpressions === void 0 || config2.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([HybridRendererBase], HybridRenderer);
      HybridRenderer.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      var CompExpressionInterface = /* @__PURE__ */ function() {
        return function(comp2) {
          function _thisLayerFunction(name2) {
            var i2 = 0;
            var len = comp2.layers.length;
            while (i2 < len) {
              if (comp2.layers[i2].nm === name2 || comp2.layers[i2].ind === name2) {
                return comp2.elements[i2].layerInterface;
              }
              i2 += 1;
            }
            return null;
          }
          Object.defineProperty(_thisLayerFunction, "_name", {
            value: comp2.data.nm
          });
          _thisLayerFunction.layer = _thisLayerFunction;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
          _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
          _thisLayerFunction.displayStartTime = 0;
          _thisLayerFunction.numLayers = comp2.layers.length;
          return _thisLayerFunction;
        };
      }();
      function _typeof$2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$2 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$2 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$2(obj);
      }
      function seedRandom(pool, math) {
        var global2 = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
        function seedrandom(seed, options2, callback) {
          var key2 = [];
          options2 = options2 === true ? {
            entropy: true
          } : options2 || {};
          var shortseed = mixkey(flatten(options2.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
          var arc4 = new ARC4(key2);
          var prng = function prng2() {
            var n2 = arc4.g(chunks), d2 = startdenom, x = 0;
            while (n2 < significance) {
              n2 = (n2 + x) * width2;
              d2 *= width2;
              x = arc4.g(1);
            }
            while (n2 >= overflow) {
              n2 /= 2;
              d2 /= 2;
              x >>>= 1;
            }
            return (n2 + x) / d2;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng["double"] = prng;
          mixkey(tostring(arc4.S), pool);
          return (options2.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else return prng2;
          })(prng, shortseed, "global" in options2 ? options2.global : this == math, options2.state);
        }
        math["seed" + rngname] = seedrandom;
        function ARC4(key2) {
          var t, keylen = key2.length, me = this, i2 = 0, j = me.i = me.j = 0, s2 = me.S = [];
          if (!keylen) {
            key2 = [keylen++];
          }
          while (i2 < width2) {
            s2[i2] = i2++;
          }
          for (i2 = 0; i2 < width2; i2++) {
            s2[i2] = s2[j = mask2 & j + key2[i2 % keylen] + (t = s2[i2])];
            s2[j] = t;
          }
          me.g = function(count) {
            var t2, r = 0, i3 = me.i, j2 = me.j, s3 = me.S;
            while (count--) {
              t2 = s3[i3 = mask2 & i3 + 1];
              r = r * width2 + s3[mask2 & (s3[i3] = s3[j2 = mask2 & j2 + t2]) + (s3[j2] = t2)];
            }
            me.i = i3;
            me.j = j2;
            return r;
          };
        }
        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        function flatten(obj, depth) {
          var result = [], typ = _typeof$2(obj), prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten(obj[prop], depth - 1));
              } catch (e2) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key2) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key2[mask2 & j] = mask2 & (smear ^= key2[mask2 & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key2);
        }
        function autoseed() {
          try {
            if (nodecrypto) ;
            var out = new Uint8Array(width2);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
            return tostring(out);
          } catch (e2) {
            var browser = global2.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool);
      }
      function initialize$2(BMMath2) {
        seedRandom([], BMMath2);
      }
      var propTypes = {
        SHAPE: "shape"
      };
      function _typeof$1(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof$1 = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof$1 = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof$1(obj);
      }
      var ExpressionManager = function() {
        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        var _lottieGlobal = {};
        initialize$2(BMMath);
        function resetFrame() {
          _lottieGlobal = {};
        }
        function $bm_isInstanceOfArray(arr) {
          return arr.constructor === Array || arr.constructor === Float32Array;
        }
        function isNumerable(tOfV, v) {
          return tOfV === "number" || v instanceof Number || tOfV === "boolean" || tOfV === "string";
        }
        function $bm_neg(a) {
          var tOfA = _typeof$1(a);
          if (tOfA === "number" || a instanceof Number || tOfA === "boolean") {
            return -a;
          }
          if ($bm_isInstanceOfArray(a)) {
            var i2;
            var lenA = a.length;
            var retArr = [];
            for (i2 = 0; i2 < lenA; i2 += 1) {
              retArr[i2] = -a[i2];
            }
            return retArr;
          }
          if (a.propType) {
            return a.v;
          }
          return -a;
        }
        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
        function sum(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === "string" || tOfB === "string") {
            return a + b;
          }
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] += b;
            return a;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a + b[0];
            return b;
          }
          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i2 = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];
            while (i2 < lenA || i2 < lenB) {
              if ((typeof a[i2] === "number" || a[i2] instanceof Number) && (typeof b[i2] === "number" || b[i2] instanceof Number)) {
                retArr[i2] = a[i2] + b[i2];
              } else {
                retArr[i2] = b[i2] === void 0 ? a[i2] : a[i2] || b[i2];
              }
              i2 += 1;
            }
            return retArr;
          }
          return 0;
        }
        var add = sum;
        function sub(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            if (tOfA === "string") {
              a = parseInt(a, 10);
            }
            if (tOfB === "string") {
              b = parseInt(b, 10);
            }
            return a - b;
          }
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] -= b;
            return a;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a - b[0];
            return b;
          }
          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i2 = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];
            while (i2 < lenA || i2 < lenB) {
              if ((typeof a[i2] === "number" || a[i2] instanceof Number) && (typeof b[i2] === "number" || b[i2] instanceof Number)) {
                retArr[i2] = a[i2] - b[i2];
              } else {
                retArr[i2] = b[i2] === void 0 ? a[i2] : a[i2] || b[i2];
              }
              i2 += 1;
            }
            return retArr;
          }
          return 0;
        }
        function mul(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          var arr;
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a * b;
          }
          var i2;
          var len;
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a[i2] * b;
            }
            return arr;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a * b[i2];
            }
            return arr;
          }
          return 0;
        }
        function div(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          var arr;
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a / b;
          }
          var i2;
          var len;
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a[i2] / b;
            }
            return arr;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = a / b[i2];
            }
            return arr;
          }
          return 0;
        }
        function mod(a, b) {
          if (typeof a === "string") {
            a = parseInt(a, 10);
          }
          if (typeof b === "string") {
            b = parseInt(b, 10);
          }
          return a % b;
        }
        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;
        function clamp(num, min, max) {
          if (min > max) {
            var mm = max;
            max = min;
            min = mm;
          }
          return Math.min(Math.max(num, min), max);
        }
        function radiansToDegrees(val2) {
          return val2 / degToRads;
        }
        var radians_to_degrees = radiansToDegrees;
        function degreesToRadians(val2) {
          return val2 * degToRads;
        }
        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [0, 0, 0, 0, 0, 0];
        function length(arr1, arr2) {
          if (typeof arr1 === "number" || arr1 instanceof Number) {
            arr2 = arr2 || 0;
            return Math.abs(arr1 - arr2);
          }
          if (!arr2) {
            arr2 = helperLengthArray;
          }
          var i2;
          var len = Math.min(arr1.length, arr2.length);
          var addedLength = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            addedLength += Math.pow(arr2[i2] - arr1[i2], 2);
          }
          return Math.sqrt(addedLength);
        }
        function normalize(vec) {
          return div(vec, length(vec));
        }
        function rgbToHsl(val2) {
          var r = val2[0];
          var g = val2[1];
          var b = val2[2];
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h;
          var s2;
          var l2 = (max + min) / 2;
          if (max === min) {
            h = 0;
            s2 = 0;
          } else {
            var d2 = max - min;
            s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d2 + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d2 + 2;
                break;
              case b:
                h = (r - g) / d2 + 4;
                break;
            }
            h /= 6;
          }
          return [h, s2, l2, val2[3]];
        }
        function hue2rgb(p2, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p2 + (q - p2) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p2 + (q - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        function hslToRgb(val2) {
          var h = val2[0];
          var s2 = val2[1];
          var l2 = val2[2];
          var r;
          var g;
          var b;
          if (s2 === 0) {
            r = l2;
            b = l2;
            g = l2;
          } else {
            var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
            var p2 = 2 * l2 - q;
            r = hue2rgb(p2, q, h + 1 / 3);
            g = hue2rgb(p2, q, h);
            b = hue2rgb(p2, q, h - 1 / 3);
          }
          return [r, g, b, val2[3]];
        }
        function linear(t, tMin, tMax, value1, value2) {
          if (value1 === void 0 || value2 === void 0) {
            value1 = tMin;
            value2 = tMax;
            tMin = 0;
            tMax = 1;
          }
          if (tMax < tMin) {
            var _tMin = tMax;
            tMax = tMin;
            tMin = _tMin;
          }
          if (t <= tMin) {
            return value1;
          }
          if (t >= tMax) {
            return value2;
          }
          var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
          if (!value1.length) {
            return value1 + (value2 - value1) * perc;
          }
          var i2;
          var len = value1.length;
          var arr = createTypedArray("float32", len);
          for (i2 = 0; i2 < len; i2 += 1) {
            arr[i2] = value1[i2] + (value2[i2] - value1[i2]) * perc;
          }
          return arr;
        }
        function random(min, max) {
          if (max === void 0) {
            if (min === void 0) {
              min = 0;
              max = 1;
            } else {
              max = min;
              min = void 0;
            }
          }
          if (max.length) {
            var i2;
            var len = max.length;
            if (!min) {
              min = createTypedArray("float32", len);
            }
            var arr = createTypedArray("float32", len);
            var rnd = BMMath.random();
            for (i2 = 0; i2 < len; i2 += 1) {
              arr[i2] = min[i2] + rnd * (max[i2] - min[i2]);
            }
            return arr;
          }
          if (min === void 0) {
            min = 0;
          }
          var rndm = BMMath.random();
          return min + rndm * (max - min);
        }
        function createPath(points, inTangents, outTangents, closed) {
          var i2;
          var len = points.length;
          var path = shapePool.newElement();
          path.setPathData(!!closed, len);
          var arrPlaceholder = [0, 0];
          var inVertexPoint;
          var outVertexPoint;
          for (i2 = 0; i2 < len; i2 += 1) {
            inVertexPoint = inTangents && inTangents[i2] ? inTangents[i2] : arrPlaceholder;
            outVertexPoint = outTangents && outTangents[i2] ? outTangents[i2] : arrPlaceholder;
            path.setTripleAt(points[i2][0], points[i2][1], outVertexPoint[0] + points[i2][0], outVertexPoint[1] + points[i2][1], inVertexPoint[0] + points[i2][0], inVertexPoint[1] + points[i2][1], i2, true);
          }
          return path;
        }
        function initiateExpression(elem, data, property) {
          function noOp(_value) {
            return _value;
          }
          if (!elem.globalData.renderConfig.runExpressions) {
            return noOp;
          }
          var val = data.x;
          var needsVelocity = /velocity(?![\w\d])/.test(val);
          var _needsRandom = val.indexOf("random") !== -1;
          var elemType = elem.data.ty;
          var transform;
          var $bm_transform;
          var content;
          var effect;
          var thisProperty = property;
          thisProperty.valueAtTime = thisProperty.getValueAtTime;
          Object.defineProperty(thisProperty, "value", {
            get: function get() {
              return thisProperty.v;
            }
          });
          elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
          elem.comp.displayStartTime = 0;
          var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          var outPoint = elem.data.op / elem.comp.globalData.frameRate;
          var width = elem.data.sw ? elem.data.sw : 0;
          var height = elem.data.sh ? elem.data.sh : 0;
          var name = elem.data.nm;
          var loopIn;
          var loop_in;
          var loopOut;
          var loop_out;
          var smooth;
          var toWorld;
          var fromWorld;
          var fromComp;
          var toComp;
          var fromCompToSurface;
          var position;
          var rotation;
          var anchorPoint;
          var scale;
          var thisLayer;
          var thisComp;
          var mask;
          var valueAtTime;
          var velocityAtTime;
          var scoped_bm_rt;
          var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
          var numKeys = property.kf ? data.k.length : 0;
          var active = !this.data || this.data.hd !== true;
          var wiggle = (function wiggle2(freq, amp) {
            var iWiggle;
            var j;
            var lenWiggle = this.pv.length ? this.pv.length : 1;
            var addedAmps = createTypedArray("float32", lenWiggle);
            freq = 5;
            var iterations = Math.floor(time * freq);
            iWiggle = 0;
            j = 0;
            while (iWiggle < iterations) {
              for (j = 0; j < lenWiggle; j += 1) {
                addedAmps[j] += -amp + amp * 2 * BMMath.random();
              }
              iWiggle += 1;
            }
            var periods = time * freq;
            var perc = periods - Math.floor(periods);
            var arr = createTypedArray("float32", lenWiggle);
            if (lenWiggle > 1) {
              for (j = 0; j < lenWiggle; j += 1) {
                arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
              }
              return arr;
            }
            return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
          }).bind(this);
          if (thisProperty.loopIn) {
            loopIn = thisProperty.loopIn.bind(thisProperty);
            loop_in = loopIn;
          }
          if (thisProperty.loopOut) {
            loopOut = thisProperty.loopOut.bind(thisProperty);
            loop_out = loopOut;
          }
          if (thisProperty.smooth) {
            smooth = thisProperty.smooth.bind(thisProperty);
          }
          function loopInDuration(type2, duration) {
            return loopIn(type2, duration, true);
          }
          function loopOutDuration(type2, duration) {
            return loopOut(type2, duration, true);
          }
          if (this.getValueAtTime) {
            valueAtTime = this.getValueAtTime.bind(this);
          }
          if (this.getVelocityAtTime) {
            velocityAtTime = this.getVelocityAtTime.bind(this);
          }
          var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
          function lookAt(elem1, elem2) {
            var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
            var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
            var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
            return [yaw, pitch, 0];
          }
          function easeOut(t, tMin, tMax, val1, val2) {
            return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
          }
          function easeIn(t, tMin, tMax, val1, val2) {
            return applyEase(easeInBez, t, tMin, tMax, val1, val2);
          }
          function ease(t, tMin, tMax, val1, val2) {
            return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
          }
          function applyEase(fn, t, tMin, tMax, val1, val2) {
            if (val1 === void 0) {
              val1 = tMin;
              val2 = tMax;
            } else {
              t = (t - tMin) / (tMax - tMin);
            }
            if (t > 1) {
              t = 1;
            } else if (t < 0) {
              t = 0;
            }
            var mult = fn(t);
            if ($bm_isInstanceOfArray(val1)) {
              var iKey;
              var lenKey = val1.length;
              var arr = createTypedArray("float32", lenKey);
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
              }
              return arr;
            }
            return (val2 - val1) * mult + val1;
          }
          function nearestKey(time2) {
            var iKey;
            var lenKey = data.k.length;
            var index2;
            var keyTime;
            if (!data.k.length || typeof data.k[0] === "number") {
              index2 = 0;
              keyTime = 0;
            } else {
              index2 = -1;
              time2 *= elem.comp.globalData.frameRate;
              if (time2 < data.k[0].t) {
                index2 = 1;
                keyTime = data.k[0].t;
              } else {
                for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                  if (time2 === data.k[iKey].t) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                    break;
                  } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                    if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                      index2 = iKey + 2;
                      keyTime = data.k[iKey + 1].t;
                    } else {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }
                    break;
                  }
                }
                if (index2 === -1) {
                  index2 = iKey + 1;
                  keyTime = data.k[iKey].t;
                }
              }
            }
            var obKey = {};
            obKey.index = index2;
            obKey.time = keyTime / elem.comp.globalData.frameRate;
            return obKey;
          }
          function key(ind) {
            var obKey;
            var iKey;
            var lenKey;
            if (!data.k.length || typeof data.k[0] === "number") {
              throw new Error("The property has no keyframe at index " + ind);
            }
            ind -= 1;
            obKey = {
              time: data.k[ind].t / elem.comp.globalData.frameRate,
              value: []
            };
            var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
            lenKey = arr.length;
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              obKey[iKey] = arr[iKey];
              obKey.value[iKey] = arr[iKey];
            }
            return obKey;
          }
          function framesToTime(fr2, fps) {
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return fr2 / fps;
          }
          function timeToFrames(t, fps) {
            if (!t && t !== 0) {
              t = time;
            }
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return t * fps;
          }
          function seedRandom(seed) {
            BMMath.seedrandom(randSeed + seed);
          }
          function sourceRectAtTime() {
            return elem.sourceRectAtTime();
          }
          function substring(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substring(init);
              }
              return value.substring(init, end);
            }
            return "";
          }
          function substr(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substr(init);
              }
              return value.substr(init, end);
            }
            return "";
          }
          function posterizeTime(framesPerSecond) {
            time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
            value = valueAtTime(time);
          }
          var time;
          var velocity;
          var value;
          var text;
          var textIndex;
          var textTotal;
          var selectorValue;
          var index = elem.data.ind;
          var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          var parent;
          var randSeed = Math.floor(Math.random() * 1e6);
          var globalData = elem.globalData;
          function executeExpression(_value) {
            value = _value;
            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
              return value;
            }
            if (this.propType === "textSelector") {
              textIndex = this.textIndex;
              textTotal = this.textTotal;
              selectorValue = this.selectorValue;
            }
            if (!thisLayer) {
              text = elem.layerInterface.text;
              thisLayer = elem.layerInterface;
              thisComp = elem.comp.compInterface;
              toWorld = thisLayer.toWorld.bind(thisLayer);
              fromWorld = thisLayer.fromWorld.bind(thisLayer);
              fromComp = thisLayer.fromComp.bind(thisLayer);
              toComp = thisLayer.toComp.bind(thisLayer);
              mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
              fromCompToSurface = fromComp;
            }
            if (!transform) {
              transform = elem.layerInterface("ADBE Transform Group");
              $bm_transform = transform;
              if (transform) {
                anchorPoint = transform.anchorPoint;
              }
            }
            if (elemType === 4 && !content) {
              content = thisLayer("ADBE Root Vectors Group");
            }
            if (!effect) {
              effect = thisLayer(4);
            }
            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            if (hasParent && !parent) {
              parent = elem.hierarchy[0].layerInterface;
            }
            time = this.comp.renderedFrame / this.comp.globalData.frameRate;
            if (_needsRandom) {
              seedRandom(randSeed + time);
            }
            if (needsVelocity) {
              velocity = velocityAtTime(time);
            }
            expression_function();
            this.frameExpressionId = elem.globalData.frameId;
            scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
            return scoped_bm_rt;
          }
          executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
          return executeExpression;
        }
        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
        ob.resetFrame = resetFrame;
        return ob;
      }();
      var Expressions = function() {
        var ob2 = {};
        ob2.initExpressions = initExpressions;
        ob2.resetFrame = ExpressionManager.resetFrame;
        function initExpressions(animation) {
          var stackCount = 0;
          var registers = [];
          function pushExpression() {
            stackCount += 1;
          }
          function popExpression() {
            stackCount -= 1;
            if (stackCount === 0) {
              releaseInstances();
            }
          }
          function registerExpressionProperty(expression) {
            if (registers.indexOf(expression) === -1) {
              registers.push(expression);
            }
          }
          function releaseInstances() {
            var i2;
            var len = registers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              registers[i2].release();
            }
            registers.length = 0;
          }
          animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
          animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
          animation.renderer.globalData.pushExpression = pushExpression;
          animation.renderer.globalData.popExpression = popExpression;
          animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
        return ob2;
      }();
      var MaskManagerInterface = function() {
        function MaskInterface(mask2, data2) {
          this._mask = mask2;
          this._data = data2;
        }
        Object.defineProperty(MaskInterface.prototype, "maskPath", {
          get: function get() {
            if (this._mask.prop.k) {
              this._mask.prop.getValue();
            }
            return this._mask.prop;
          }
        });
        Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
          get: function get() {
            if (this._mask.op.k) {
              this._mask.op.getValue();
            }
            return this._mask.op.v * 100;
          }
        });
        var MaskManager = function MaskManager2(maskManager) {
          var _masksInterfaces = createSizedArray(maskManager.viewData.length);
          var i2;
          var len = maskManager.viewData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            _masksInterfaces[i2] = new MaskInterface(maskManager.viewData[i2], maskManager.masksProperties[i2]);
          }
          var maskFunction = function maskFunction2(name2) {
            i2 = 0;
            while (i2 < len) {
              if (maskManager.masksProperties[i2].nm === name2) {
                return _masksInterfaces[i2];
              }
              i2 += 1;
            }
            return null;
          };
          return maskFunction;
        };
        return MaskManager;
      }();
      var ExpressionPropertyInterface = /* @__PURE__ */ function() {
        var defaultUnidimensionalValue = {
          pv: 0,
          v: 0,
          mult: 1
        };
        var defaultMultidimensionalValue = {
          pv: [0, 0, 0],
          v: [0, 0, 0],
          mult: 1
        };
        function completeProperty(expressionValue, property2, type2) {
          Object.defineProperty(expressionValue, "velocity", {
            get: function get() {
              return property2.getVelocityAtTime(property2.comp.currentFrame);
            }
          });
          expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
          expressionValue.key = function(pos) {
            if (!expressionValue.numKeys) {
              return 0;
            }
            var value2 = "";
            if ("s" in property2.keyframes[pos - 1]) {
              value2 = property2.keyframes[pos - 1].s;
            } else if ("e" in property2.keyframes[pos - 2]) {
              value2 = property2.keyframes[pos - 2].e;
            } else {
              value2 = property2.keyframes[pos - 2].s;
            }
            var valueProp = type2 === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
            valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
            valueProp.value = type2 === "unidimensional" ? value2[0] : value2;
            return valueProp;
          };
          expressionValue.valueAtTime = property2.getValueAtTime;
          expressionValue.speedAtTime = property2.getSpeedAtTime;
          expressionValue.velocityAtTime = property2.getVelocityAtTime;
          expressionValue.propertyGroup = property2.propertyGroup;
        }
        function UnidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultUnidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var val2 = property2.pv * mult;
          var expressionValue = new Number(val2);
          expressionValue.value = val2;
          completeProperty(expressionValue, property2, "unidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            val2 = property2.v * mult;
            if (expressionValue.value !== val2) {
              expressionValue = new Number(val2);
              expressionValue.value = val2;
              completeProperty(expressionValue, property2, "unidimensional");
            }
            return expressionValue;
          };
        }
        function MultidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultMultidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var len = property2.data && property2.data.l || property2.pv.length;
          var expressionValue = createTypedArray("float32", len);
          var arrValue = createTypedArray("float32", len);
          expressionValue.value = arrValue;
          completeProperty(expressionValue, property2, "multidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            for (var i2 = 0; i2 < len; i2 += 1) {
              arrValue[i2] = property2.v[i2] * mult;
              expressionValue[i2] = arrValue[i2];
            }
            return expressionValue;
          };
        }
        function defaultGetter() {
          return defaultUnidimensionalValue;
        }
        return function(property2) {
          if (!property2) {
            return defaultGetter;
          }
          if (property2.propType === "unidimensional") {
            return UnidimensionalPropertyInterface(property2);
          }
          return MultidimensionalPropertyInterface(property2);
        };
      }();
      var TransformExpressionInterface = /* @__PURE__ */ function() {
        return function(transform2) {
          function _thisFunction(name2) {
            switch (name2) {
              case "scale":
              case "Scale":
              case "ADBE Scale":
              case 6:
                return _thisFunction.scale;
              case "rotation":
              case "Rotation":
              case "ADBE Rotation":
              case "ADBE Rotate Z":
              case 10:
                return _thisFunction.rotation;
              case "ADBE Rotate X":
                return _thisFunction.xRotation;
              case "ADBE Rotate Y":
                return _thisFunction.yRotation;
              case "position":
              case "Position":
              case "ADBE Position":
              case 2:
                return _thisFunction.position;
              case "ADBE Position_0":
                return _thisFunction.xPosition;
              case "ADBE Position_1":
                return _thisFunction.yPosition;
              case "ADBE Position_2":
                return _thisFunction.zPosition;
              case "anchorPoint":
              case "AnchorPoint":
              case "Anchor Point":
              case "ADBE AnchorPoint":
              case 1:
                return _thisFunction.anchorPoint;
              case "opacity":
              case "Opacity":
              case 11:
                return _thisFunction.opacity;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisFunction, "rotation", {
            get: ExpressionPropertyInterface(transform2.r || transform2.rz)
          });
          Object.defineProperty(_thisFunction, "zRotation", {
            get: ExpressionPropertyInterface(transform2.rz || transform2.r)
          });
          Object.defineProperty(_thisFunction, "xRotation", {
            get: ExpressionPropertyInterface(transform2.rx)
          });
          Object.defineProperty(_thisFunction, "yRotation", {
            get: ExpressionPropertyInterface(transform2.ry)
          });
          Object.defineProperty(_thisFunction, "scale", {
            get: ExpressionPropertyInterface(transform2.s)
          });
          var _px;
          var _py;
          var _pz;
          var _transformFactory;
          if (transform2.p) {
            _transformFactory = ExpressionPropertyInterface(transform2.p);
          } else {
            _px = ExpressionPropertyInterface(transform2.px);
            _py = ExpressionPropertyInterface(transform2.py);
            if (transform2.pz) {
              _pz = ExpressionPropertyInterface(transform2.pz);
            }
          }
          Object.defineProperty(_thisFunction, "position", {
            get: function get() {
              if (transform2.p) {
                return _transformFactory();
              }
              return [_px(), _py(), _pz ? _pz() : 0];
            }
          });
          Object.defineProperty(_thisFunction, "xPosition", {
            get: ExpressionPropertyInterface(transform2.px)
          });
          Object.defineProperty(_thisFunction, "yPosition", {
            get: ExpressionPropertyInterface(transform2.py)
          });
          Object.defineProperty(_thisFunction, "zPosition", {
            get: ExpressionPropertyInterface(transform2.pz)
          });
          Object.defineProperty(_thisFunction, "anchorPoint", {
            get: ExpressionPropertyInterface(transform2.a)
          });
          Object.defineProperty(_thisFunction, "opacity", {
            get: ExpressionPropertyInterface(transform2.o)
          });
          Object.defineProperty(_thisFunction, "skew", {
            get: ExpressionPropertyInterface(transform2.sk)
          });
          Object.defineProperty(_thisFunction, "skewAxis", {
            get: ExpressionPropertyInterface(transform2.sa)
          });
          Object.defineProperty(_thisFunction, "orientation", {
            get: ExpressionPropertyInterface(transform2.or)
          });
          return _thisFunction;
        };
      }();
      var LayerExpressionInterface = /* @__PURE__ */ function() {
        function getMatrix(time2) {
          var toWorldMat = new Matrix();
          if (time2 !== void 0) {
            var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
            propMatrix.clone(toWorldMat);
          } else {
            var transformMat = this._elem.finalTransform.mProp;
            transformMat.applyToMatrix(toWorldMat);
          }
          return toWorldMat;
        }
        function toWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.applyPoint(toWorldMat, arr);
        }
        function toWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.applyPoint(toWorldMat, arr);
        }
        function fromWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.invertPoint(toWorldMat, arr);
        }
        function fromWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.invertPoint(toWorldMat, arr);
        }
        function applyPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }
        function invertPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.inversePoint(arr);
        }
        function fromComp2(arr) {
          var toWorldMat = new Matrix();
          toWorldMat.reset();
          this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i2;
            var len = this._elem.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(toWorldMat);
            }
            return toWorldMat.inversePoint(arr);
          }
          return toWorldMat.inversePoint(arr);
        }
        function sampleImage() {
          return [1, 1, 1, 1];
        }
        return function(elem2) {
          var transformInterface;
          function _registerMaskInterface(maskManager) {
            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
          }
          function _registerEffectsInterface(effects) {
            _thisLayerFunction.effect = effects;
          }
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Root Vectors Group":
              case "Contents":
              case 2:
                return _thisLayerFunction.shapeInterface;
              case 1:
              case 6:
              case "Transform":
              case "transform":
              case "ADBE Transform Group":
                return transformInterface;
              case 4:
              case "ADBE Effect Parade":
              case "effects":
              case "Effects":
                return _thisLayerFunction.effect;
              case "ADBE Text Properties":
                return _thisLayerFunction.textInterface;
              default:
                return null;
            }
          }
          _thisLayerFunction.getMatrix = getMatrix;
          _thisLayerFunction.invertPoint = invertPoint;
          _thisLayerFunction.applyPoint = applyPoint;
          _thisLayerFunction.toWorld = toWorld2;
          _thisLayerFunction.toWorldVec = toWorldVec;
          _thisLayerFunction.fromWorld = fromWorld2;
          _thisLayerFunction.fromWorldVec = fromWorldVec;
          _thisLayerFunction.toComp = toWorld2;
          _thisLayerFunction.fromComp = fromComp2;
          _thisLayerFunction.sampleImage = sampleImage;
          _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
          _thisLayerFunction._elem = elem2;
          transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
          var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
          Object.defineProperties(_thisLayerFunction, {
            hasParent: {
              get: function get() {
                return elem2.hierarchy.length;
              }
            },
            parent: {
              get: function get() {
                return elem2.hierarchy[0].layerInterface;
              }
            },
            rotation: getDescriptor(transformInterface, "rotation"),
            scale: getDescriptor(transformInterface, "scale"),
            position: getDescriptor(transformInterface, "position"),
            opacity: getDescriptor(transformInterface, "opacity"),
            anchorPoint: anchorPointDescriptor,
            anchor_point: anchorPointDescriptor,
            transform: {
              get: function get() {
                return transformInterface;
              }
            },
            active: {
              get: function get() {
                return elem2.isInRange;
              }
            }
          });
          _thisLayerFunction.startTime = elem2.data.st;
          _thisLayerFunction.index = elem2.data.ind;
          _thisLayerFunction.source = elem2.data.refId;
          _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
          _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
          _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
          _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
          _thisLayerFunction._name = elem2.data.nm;
          _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
          _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
          return _thisLayerFunction;
        };
      }();
      var propertyGroupFactory = /* @__PURE__ */ function() {
        return function(interfaceFunction, parentPropertyGroup) {
          return function(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return parentPropertyGroup(val2 - 1);
          };
        };
      }();
      var PropertyInterface = /* @__PURE__ */ function() {
        return function(propertyName, propertyGroup) {
          var interfaceFunction = {
            _name: propertyName
          };
          function _propertyGroup(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return propertyGroup(val2 - 1);
          }
          return _propertyGroup;
        };
      }();
      var EffectsExpressionInterface = /* @__PURE__ */ function() {
        var ob2 = {
          createEffectsInterface
        };
        function createEffectsInterface(elem2, propertyGroup) {
          if (elem2.effectsManager) {
            var effectElements = [];
            var effectsData = elem2.data.ef;
            var i2;
            var len = elem2.effectsManager.effectElements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              effectElements.push(createGroupInterface(effectsData[i2], elem2.effectsManager.effectElements[i2], propertyGroup, elem2));
            }
            var effects = elem2.data.ef || [];
            var groupInterface = function groupInterface2(name2) {
              i2 = 0;
              len = effects.length;
              while (i2 < len) {
                if (name2 === effects[i2].nm || name2 === effects[i2].mn || name2 === effects[i2].ix) {
                  return effectElements[i2];
                }
                i2 += 1;
              }
              return null;
            };
            Object.defineProperty(groupInterface, "numProperties", {
              get: function get() {
                return effects.length;
              }
            });
            return groupInterface;
          }
          return null;
        }
        function createGroupInterface(data2, elements, propertyGroup, elem2) {
          function groupInterface(name2) {
            var effects = data2.ef;
            var i3 = 0;
            var len2 = effects.length;
            while (i3 < len2) {
              if (name2 === effects[i3].nm || name2 === effects[i3].mn || name2 === effects[i3].ix) {
                if (effects[i3].ty === 5) {
                  return effectElements[i3];
                }
                return effectElements[i3]();
              }
              i3 += 1;
            }
            throw new Error();
          }
          var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
          var effectElements = [];
          var i2;
          var len = data2.ef.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (data2.ef[i2].ty === 5) {
              effectElements.push(createGroupInterface(data2.ef[i2], elements.effectElements[i2], elements.effectElements[i2].propertyGroup, elem2));
            } else {
              effectElements.push(createValueInterface(elements.effectElements[i2], data2.ef[i2].ty, elem2, _propertyGroup));
            }
          }
          if (data2.mn === "ADBE Color Control") {
            Object.defineProperty(groupInterface, "color", {
              get: function get() {
                return effectElements[0]();
              }
            });
          }
          Object.defineProperties(groupInterface, {
            numProperties: {
              get: function get() {
                return data2.np;
              }
            },
            _name: {
              value: data2.nm
            },
            propertyGroup: {
              value: _propertyGroup
            }
          });
          groupInterface.enabled = data2.en !== 0;
          groupInterface.active = groupInterface.enabled;
          return groupInterface;
        }
        function createValueInterface(element, type2, elem2, propertyGroup) {
          var expressionProperty = ExpressionPropertyInterface(element.p);
          function interfaceFunction() {
            if (type2 === 10) {
              return elem2.comp.compInterface(element.p.v);
            }
            return expressionProperty();
          }
          if (element.p.setGroupProperty) {
            element.p.setGroupProperty(PropertyInterface("", propertyGroup));
          }
          return interfaceFunction;
        }
        return ob2;
      }();
      var ShapePathInterface = /* @__PURE__ */ function() {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;
          function interfaceFunction(val2) {
            if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
              return interfaceFunction.path;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            shape: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            _name: {
              value: shape.nm
            },
            ix: {
              value: shape.ix
            },
            propertyIndex: {
              value: shape.ix
            },
            mn: {
              value: shape.mn
            },
            propertyGroup: {
              value: propertyGroup
            }
          });
          return interfaceFunction;
        };
      }();
      var ShapeExpressionInterface = /* @__PURE__ */ function() {
        function iterateElements(shapes, view, propertyGroup) {
          var arr = [];
          var i2;
          var len = shapes ? shapes.length : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (shapes[i2].ty === "gr") {
              arr.push(groupInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "fl") {
              arr.push(fillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "st") {
              arr.push(strokeInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "tm") {
              arr.push(trimInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "tr") ;
            else if (shapes[i2].ty === "el") {
              arr.push(ellipseInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "sr") {
              arr.push(starInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "sh") {
              arr.push(ShapePathInterface(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rc") {
              arr.push(rectInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rd") {
              arr.push(roundedInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "rp") {
              arr.push(repeaterInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else if (shapes[i2].ty === "gf") {
              arr.push(gradientFillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
            } else {
              arr.push(defaultInterfaceFactory(shapes[i2], view[i2]));
            }
          }
          return arr;
        }
        function contentsInterfaceFactory(shape, view, propertyGroup) {
          var interfaces2;
          var interfaceFunction = function _interfaceFunction(value2) {
            var i2 = 0;
            var len = interfaces2.length;
            while (i2 < len) {
              if (interfaces2[i2]._name === value2 || interfaces2[i2].mn === value2 || interfaces2[i2].propertyIndex === value2 || interfaces2[i2].ix === value2 || interfaces2[i2].ind === value2) {
                return interfaces2[i2];
              }
              i2 += 1;
            }
            if (typeof value2 === "number") {
              return interfaces2[value2 - 1];
            }
            return null;
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
          interfaceFunction.numProperties = interfaces2.length;
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.transform = transformInterface;
          interfaceFunction.propertyIndex = shape.cix;
          interfaceFunction._name = shape.nm;
          return interfaceFunction;
        }
        function groupInterfaceFactory(shape, view, propertyGroup) {
          var interfaceFunction = function _interfaceFunction(value2) {
            switch (value2) {
              case "ADBE Vectors Group":
              case "Contents":
              case 2:
                return interfaceFunction.content;
              default:
                return interfaceFunction.transform;
            }
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.content = content2;
          interfaceFunction.transform = transformInterface;
          Object.defineProperty(interfaceFunction, "_name", {
            get: function get() {
              return shape.nm;
            }
          });
          interfaceFunction.numProperties = shape.np;
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.nm = shape.nm;
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function fillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Start Point" || val2 === "start point") {
              return interfaceFunction.startPoint;
            }
            if (val2 === "End Point" || val2 === "end point") {
              return interfaceFunction.endPoint;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            startPoint: {
              get: ExpressionPropertyInterface(view.s)
            },
            endPoint: {
              get: ExpressionPropertyInterface(view.e)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            type: {
              get: function get() {
                return "a";
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function defaultInterfaceFactory() {
          function interfaceFunction() {
            return null;
          }
          return interfaceFunction;
        }
        function strokeInterfaceFactory(shape, view, propertyGroup) {
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
          function addPropertyToDashOb(i3) {
            Object.defineProperty(dashOb, shape.d[i3].nm, {
              get: ExpressionPropertyInterface(view.d.dataProps[i3].p)
            });
          }
          var i2;
          var len = shape.d ? shape.d.length : 0;
          var dashOb = {};
          for (i2 = 0; i2 < len; i2 += 1) {
            addPropertyToDashOb(i2);
            view.d.dataProps[i2].p.setGroupProperty(_dashPropertyGroup);
          }
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            if (val2 === "Stroke Width" || val2 === "stroke width") {
              return interfaceFunction.strokeWidth;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            strokeWidth: {
              get: ExpressionPropertyInterface(view.w)
            },
            dash: {
              get: function get() {
                return dashOb;
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
          return interfaceFunction;
        }
        function trimInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
              return interfaceFunction.end;
            }
            if (val2 === shape.s.ix) {
              return interfaceFunction.start;
            }
            if (val2 === shape.o.ix) {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.propertyGroup = propertyGroup;
          Object.defineProperties(interfaceFunction, {
            start: {
              get: ExpressionPropertyInterface(view.s)
            },
            end: {
              get: ExpressionPropertyInterface(view.e)
            },
            offset: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function transformInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.a.ix === value2 || value2 === "Anchor Point") {
              return interfaceFunction.anchorPoint;
            }
            if (shape.o.ix === value2 || value2 === "Opacity") {
              return interfaceFunction.opacity;
            }
            if (shape.p.ix === value2 || value2 === "Position") {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
              return interfaceFunction.rotation;
            }
            if (shape.s.ix === value2 || value2 === "Scale") {
              return interfaceFunction.scale;
            }
            if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
              return interfaceFunction.skew;
            }
            if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
              return interfaceFunction.skewAxis;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
          view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
          view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (view.transform.mProps.sk) {
            view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
            view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
          }
          view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            opacity: {
              get: ExpressionPropertyInterface(view.transform.mProps.o)
            },
            position: {
              get: ExpressionPropertyInterface(view.transform.mProps.p)
            },
            anchorPoint: {
              get: ExpressionPropertyInterface(view.transform.mProps.a)
            },
            scale: {
              get: ExpressionPropertyInterface(view.transform.mProps.s)
            },
            rotation: {
              get: ExpressionPropertyInterface(view.transform.mProps.r)
            },
            skew: {
              get: ExpressionPropertyInterface(view.transform.mProps.sk)
            },
            skewAxis: {
              get: ExpressionPropertyInterface(view.transform.mProps.sa)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.ty = "tr";
          interfaceFunction.mn = shape.mn;
          interfaceFunction.propertyGroup = propertyGroup;
          return interfaceFunction;
        }
        function ellipseInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.s.ix === value2) {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function starInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.rotation;
            }
            if (shape.pt.ix === value2) {
              return interfaceFunction.points;
            }
            if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
              return interfaceFunction.outerRadius;
            }
            if (shape.os.ix === value2) {
              return interfaceFunction.outerRoundness;
            }
            if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
              return interfaceFunction.innerRadius;
            }
            if (shape.is && shape.is.ix === value2) {
              return interfaceFunction.innerRoundness;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
          prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
          prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (shape.ir) {
            prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
            prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
          }
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            rotation: {
              get: ExpressionPropertyInterface(prop.r)
            },
            points: {
              get: ExpressionPropertyInterface(prop.pt)
            },
            outerRadius: {
              get: ExpressionPropertyInterface(prop.or)
            },
            outerRoundness: {
              get: ExpressionPropertyInterface(prop.os)
            },
            innerRadius: {
              get: ExpressionPropertyInterface(prop.ir)
            },
            innerRoundness: {
              get: ExpressionPropertyInterface(prop.is)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function rectInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.p.ix === value2) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value2) {
              return interfaceFunction.roundness;
            }
            if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            roundness: {
              get: ExpressionPropertyInterface(prop.r)
            },
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function roundedInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.r.ix === value2 || value2 === "Round Corners 1") {
              return interfaceFunction.radius;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            radius: {
              get: ExpressionPropertyInterface(prop.rd)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function repeaterInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value2) {
            if (shape.c.ix === value2 || value2 === "Copies") {
              return interfaceFunction.copies;
            }
            if (shape.o.ix === value2 || value2 === "Offset") {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
          prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            copies: {
              get: ExpressionPropertyInterface(prop.c)
            },
            offset: {
              get: ExpressionPropertyInterface(prop.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        return function(shapes, view, propertyGroup) {
          var interfaces2;
          function _interfaceFunction(value2) {
            if (typeof value2 === "number") {
              value2 = value2 === void 0 ? 1 : value2;
              if (value2 === 0) {
                return propertyGroup;
              }
              return interfaces2[value2 - 1];
            }
            var i2 = 0;
            var len = interfaces2.length;
            while (i2 < len) {
              if (interfaces2[i2]._name === value2) {
                return interfaces2[i2];
              }
              i2 += 1;
            }
            return null;
          }
          function parentGroupWrapper() {
            return propertyGroup;
          }
          _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
          interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
          _interfaceFunction.numProperties = interfaces2.length;
          _interfaceFunction._name = "Contents";
          return _interfaceFunction;
        };
      }();
      var TextExpressionInterface = /* @__PURE__ */ function() {
        return function(elem2) {
          var _sourceText;
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Text Document":
                return _thisLayerFunction.sourceText;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisLayerFunction, "sourceText", {
            get: function get() {
              elem2.textProperty.getValue();
              var stringValue = elem2.textProperty.currentData.t;
              if (!_sourceText || stringValue !== _sourceText.value) {
                _sourceText = new String(stringValue);
                _sourceText.value = stringValue || new String(stringValue);
                Object.defineProperty(_sourceText, "style", {
                  get: function get2() {
                    return {
                      fillColor: elem2.textProperty.currentData.fc
                    };
                  }
                });
              }
              return _sourceText;
            }
          });
          return _thisLayerFunction;
        };
      }();
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var FootageInterface = /* @__PURE__ */ function() {
        var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
          var currentPropertyName = "";
          var currentProperty = elem2.getFootageData();
          function init() {
            currentPropertyName = "";
            currentProperty = elem2.getFootageData();
            return searchProperty;
          }
          function searchProperty(value2) {
            if (currentProperty[value2]) {
              currentPropertyName = value2;
              currentProperty = currentProperty[value2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            var propertyNameIndex = value2.indexOf(currentPropertyName);
            if (propertyNameIndex !== -1) {
              var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
              currentProperty = currentProperty[index2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            return "";
          }
          return init;
        };
        var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
          function interfaceFunction(value2) {
            if (value2 === "Outline") {
              return interfaceFunction.outlineInterface();
            }
            return null;
          }
          interfaceFunction._name = "Outline";
          interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
          return interfaceFunction;
        };
        return function(elem2) {
          function _interfaceFunction(value2) {
            if (value2 === "Data") {
              return _interfaceFunction.dataInterface;
            }
            return null;
          }
          _interfaceFunction._name = "Data";
          _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
          return _interfaceFunction;
        };
      }();
      var interfaces = {
        layer: LayerExpressionInterface,
        effects: EffectsExpressionInterface,
        comp: CompExpressionInterface,
        shape: ShapeExpressionInterface,
        text: TextExpressionInterface,
        footage: FootageInterface
      };
      function getInterface(type2) {
        return interfaces[type2] || null;
      }
      var expressionHelpers = /* @__PURE__ */ function() {
        function searchExpressions(elem2, data2, prop) {
          if (data2.x) {
            prop.k = true;
            prop.x = true;
            prop.initiateExpression = ExpressionManager.initiateExpression;
            prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
          }
        }
        function getValueAtTime(frameNum) {
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastFrame) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
            this._cachingAtTime.lastFrame = frameNum;
          }
          return this._cachingAtTime.value;
        }
        function getSpeedAtTime(frameNum) {
          var delta = -0.01;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var speed = 0;
          if (v1.length) {
            var i2;
            for (i2 = 0; i2 < v1.length; i2 += 1) {
              speed += Math.pow(v2[i2] - v1[i2], 2);
            }
            speed = Math.sqrt(speed) * 100;
          } else {
            speed = 0;
          }
          return speed;
        }
        function getVelocityAtTime(frameNum) {
          if (this.vel !== void 0) {
            return this.vel;
          }
          var delta = -1e-3;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var velocity2;
          if (v1.length) {
            velocity2 = createTypedArray("float32", v1.length);
            var i2;
            for (i2 = 0; i2 < v1.length; i2 += 1) {
              velocity2[i2] = (v2[i2] - v1[i2]) / delta;
            }
          } else {
            velocity2 = (v2 - v1) / delta;
          }
          return velocity2;
        }
        function getStaticValueAtTime() {
          return this.pv;
        }
        function setGroupProperty(propertyGroup) {
          this.propertyGroup = propertyGroup;
        }
        return {
          searchExpressions,
          getSpeedAtTime,
          getVelocityAtTime,
          getValueAtTime,
          getStaticValueAtTime,
          setGroupProperty
        };
      }();
      function addPropertyDecorator() {
        function loopOut2(type2, duration, durationFlag) {
          if (!this.k || !this.keyframes) {
            return this.pv;
          }
          type2 = type2 ? type2.toLowerCase() : "";
          var currentFrame2 = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var lastKeyFrame = keyframes[keyframes.length - 1].t;
          if (currentFrame2 <= lastKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var firstKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
            } else {
              cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
            }
            firstKeyFrame = lastKeyFrame - cycleDuration;
          }
          var i2;
          var len;
          var ret;
          if (type2 === "pingpong") {
            var iterations = Math.floor((currentFrame2 - firstKeyFrame) / cycleDuration);
            if (iterations % 2 !== 0) {
              return this.getValueAtTime((cycleDuration - (currentFrame2 - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type2 === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame2 - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((currentFrame2 - firstKeyFrame) / cycleDuration);
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = (endV[i2] - initV[i2]) * repeats + current[i2];
              }
              return ret;
            }
            return (endV - initV) * repeats + current;
          } else if (type2 === "continue") {
            var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(lastValue.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = lastValue[i2] + (lastValue[i2] - nextLastValue[i2]) * ((currentFrame2 - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
              }
              return ret;
            }
            return lastValue + (lastValue - nextLastValue) * ((currentFrame2 - lastKeyFrame) / 1e-3);
          }
          return this.getValueAtTime(((currentFrame2 - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
        }
        function loopIn2(type2, duration, durationFlag) {
          if (!this.k) {
            return this.pv;
          }
          type2 = type2 ? type2.toLowerCase() : "";
          var currentFrame2 = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var firstKeyFrame = keyframes[0].t;
          if (currentFrame2 >= firstKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var lastKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            lastKeyFrame = keyframes[duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
            } else {
              cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
            }
            lastKeyFrame = firstKeyFrame + cycleDuration;
          }
          var i2;
          var len;
          var ret;
          if (type2 === "pingpong") {
            var iterations = Math.floor((firstKeyFrame - currentFrame2) / cycleDuration);
            if (iterations % 2 === 0) {
              return this.getValueAtTime(((firstKeyFrame - currentFrame2) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type2 === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame2) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((firstKeyFrame - currentFrame2) / cycleDuration) + 1;
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = current[i2] - (endV[i2] - initV[i2]) * repeats;
              }
              return ret;
            }
            return current - (endV - initV) * repeats;
          } else if (type2 === "continue") {
            var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(firstValue.length);
              len = ret.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                ret[i2] = firstValue[i2] + (firstValue[i2] - nextFirstValue[i2]) * (firstKeyFrame - currentFrame2) / 1e-3;
              }
              return ret;
            }
            return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame2) / 1e-3;
          }
          return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame2) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
        }
        function smooth2(width2, samples) {
          if (!this.k) {
            return this.pv;
          }
          width2 = (width2 || 0.4) * 0.5;
          samples = Math.floor(samples || 5);
          if (samples <= 1) {
            return this.pv;
          }
          var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
          var initFrame2 = currentTime - width2;
          var endFrame = currentTime + width2;
          var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
          var i2 = 0;
          var j = 0;
          var value2;
          if (this.pv.length) {
            value2 = createTypedArray("float32", this.pv.length);
          } else {
            value2 = 0;
          }
          var sampleValue;
          while (i2 < samples) {
            sampleValue = this.getValueAtTime(initFrame2 + i2 * sampleFrequency);
            if (this.pv.length) {
              for (j = 0; j < this.pv.length; j += 1) {
                value2[j] += sampleValue[j];
              }
            } else {
              value2 += sampleValue;
            }
            i2 += 1;
          }
          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value2[j] /= samples;
            }
          } else {
            value2 /= samples;
          }
          return value2;
        }
        function getTransformValueAtTime(time2) {
          if (!this._transformCachingAtTime) {
            this._transformCachingAtTime = {
              v: new Matrix()
            };
          }
          var matrix = this._transformCachingAtTime.v;
          matrix.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            var anchor = this.a.getValueAtTime(time2);
            matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
          }
          if (this.appliedTransformations < 2) {
            var scale2 = this.s.getValueAtTime(time2);
            matrix.scale(scale2[0] * this.s.mult, scale2[1] * this.s.mult, scale2[2] * this.s.mult);
          }
          if (this.sk && this.appliedTransformations < 3) {
            var skew = this.sk.getValueAtTime(time2);
            var skewAxis = this.sa.getValueAtTime(time2);
            matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var rotation2 = this.r.getValueAtTime(time2);
            matrix.rotate(-rotation2 * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var rotationZ = this.rz.getValueAtTime(time2);
            var rotationY = this.ry.getValueAtTime(time2);
            var rotationX = this.rx.getValueAtTime(time2);
            var orientation = this.or.getValueAtTime(time2);
            matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var positionX = this.px.getValueAtTime(time2);
            var positionY = this.py.getValueAtTime(time2);
            if (this.data.p.z) {
              var positionZ = this.pz.getValueAtTime(time2);
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
            } else {
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            }
          } else {
            var position2 = this.p.getValueAtTime(time2);
            matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
          }
          return matrix;
        }
        function getTransformStaticValueAtTime() {
          return this.v.clone(new Matrix());
        }
        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
          var prop = getTransformProperty(elem2, data2, container);
          if (prop.dynamicProperties.length) {
            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          return prop;
        };
        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem2, data2, type2, mult, container) {
          var prop = propertyGetProp(elem2, data2, type2, mult, container);
          if (prop.kf) {
            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          prop.loopOut = loopOut2;
          prop.loopIn = loopIn2;
          prop.smooth = smooth2;
          prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
          prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
          prop.numKeys = data2.a === 1 ? data2.k.length : 0;
          prop.propertyIndex = data2.ix;
          var value2 = 0;
          if (type2 !== 0) {
            value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
          }
          prop._cachingAtTime = {
            lastFrame: initialDefaultFrame,
            lastIndex: 0,
            value: value2
          };
          expressionHelpers.searchExpressions(elem2, data2, prop);
          if (prop.k) {
            container.addDynamicProperty(prop);
          }
          return prop;
        };
        function getShapeValueAtTime(frameNum) {
          if (!this._cachingAtTime) {
            this._cachingAtTime = {
              shapeValue: shapePool.clone(this.pv),
              lastIndex: 0,
              lastTime: initialDefaultFrame
            };
          }
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastTime) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
            this._cachingAtTime.lastTime = frameNum;
            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
          }
          return this._cachingAtTime.shapeValue;
        }
        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ShapeExpressions() {
        }
        ShapeExpressions.prototype = {
          vertices: function vertices(prop, time2) {
            if (this.k) {
              this.getValue();
            }
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            var i2;
            var len = shapePath._length;
            var vertices2 = shapePath[prop];
            var points = shapePath.v;
            var arr = createSizedArray(len);
            for (i2 = 0; i2 < len; i2 += 1) {
              if (prop === "i" || prop === "o") {
                arr[i2] = [vertices2[i2][0] - points[i2][0], vertices2[i2][1] - points[i2][1]];
              } else {
                arr[i2] = [vertices2[i2][0], vertices2[i2][1]];
              }
            }
            return arr;
          },
          points: function points(time2) {
            return this.vertices("v", time2);
          },
          inTangents: function inTangents(time2) {
            return this.vertices("i", time2);
          },
          outTangents: function outTangents(time2) {
            return this.vertices("o", time2);
          },
          isClosed: function isClosed() {
            return this.v.c;
          },
          pointOnPath: function pointOnPath(perc, time2) {
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            if (!this._segmentsLength) {
              this._segmentsLength = bez.getSegmentsLength(shapePath);
            }
            var segmentsLength = this._segmentsLength;
            var lengths = segmentsLength.lengths;
            var lengthPos = segmentsLength.totalLength * perc;
            var i2 = 0;
            var len = lengths.length;
            var accumulatedLength = 0;
            var pt;
            while (i2 < len) {
              if (accumulatedLength + lengths[i2].addedLength > lengthPos) {
                var initIndex = i2;
                var endIndex = shapePath.c && i2 === len - 1 ? 0 : i2 + 1;
                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i2].addedLength;
                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i2]);
                break;
              } else {
                accumulatedLength += lengths[i2].addedLength;
              }
              i2 += 1;
            }
            if (!pt) {
              pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
            }
            return pt;
          },
          vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
            if (perc == 1) {
              perc = this.v.c;
            } else if (perc == 0) {
              perc = 0.999;
            }
            var pt1 = this.pointOnPath(perc, time2);
            var pt2 = this.pointOnPath(perc + 1e-3, time2);
            var xLength = pt2[0] - pt1[0];
            var yLength = pt2[1] - pt1[1];
            var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
            if (magnitude === 0) {
              return [0, 0];
            }
            var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
            return unitVector;
          },
          tangentOnPath: function tangentOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "tangent");
          },
          normalOnPath: function normalOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem2, data2, type2, arr, trims) {
          var prop = propertyGetShapeProp(elem2, data2, type2, arr, trims);
          prop.propertyIndex = data2.ix;
          prop.lock = false;
          if (type2 === 3) {
            expressionHelpers.searchExpressions(elem2, data2.pt, prop);
          } else if (type2 === 4) {
            expressionHelpers.searchExpressions(elem2, data2.ks, prop);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function searchExpressions() {
          if (this.data.d.x) {
            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
            this.addEffect(this.getExpressionValue.bind(this));
            return true;
          }
          return null;
        }
        TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
          var newValue = this.calculateExpression(text2);
          if (currentValue.t !== newValue) {
            var newData = {};
            this.copyData(newData, currentValue);
            newData.t = newValue.toString();
            newData.__complete = false;
            return newData;
          }
          return currentValue;
        };
        TextProperty.prototype.searchProperty = function() {
          var isKeyframed = this.searchKeyframes();
          var hasExpressions = this.searchExpressions();
          this.kf = isKeyframed || hasExpressions;
          return this.kf;
        };
        TextProperty.prototype.searchExpressions = searchExpressions;
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {
      }
      SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
          var feMerge = createNS("feMerge");
          feMerge.setAttribute("result", resultId);
          var feMergeNode;
          var i2;
          for (i2 = 0; i2 < ins.length; i2 += 1) {
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", ins[i2]);
            feMerge.appendChild(feMergeNode);
            feMerge.appendChild(feMergeNode);
          }
          return feMerge;
        }
      };
      var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(filter, filterManager, elem2, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
        this.linearFilter = feColorMatrix;
        feColorMatrix.setAttribute("result", id + "_tint_1");
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_2");
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter);
      SVGTintFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var colorBlack = this.filterManager.effectElements[0].p.v;
          var colorWhite = this.filterManager.effectElements[1].p.v;
          var opacity = this.filterManager.effectElements[2].p.v / 100;
          this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
          this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
        }
      };
      function SVGFillFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
      }
      SVGFillFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color = this.filterManager.effectElements[2].p.v;
          var opacity = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
        }
      };
      function SVGStrokeEffect(fil, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem2;
        this.paths = [];
      }
      SVGStrokeEffect.prototype.initialize = function() {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i2;
        var len;
        if (this.filterManager.effectElements[1].p.v === 1) {
          len = this.elem.maskManager.masksProperties.length;
          i2 = 0;
        } else {
          i2 = this.filterManager.effectElements[0].p.v - 1;
          len = i2 + 1;
        }
        groupPath = createNS("g");
        groupPath.setAttribute("fill", "none");
        groupPath.setAttribute("stroke-linecap", "round");
        groupPath.setAttribute("stroke-dashoffset", 1);
        for (i2; i2 < len; i2 += 1) {
          path = createNS("path");
          groupPath.appendChild(path);
          this.paths.push({
            p: path,
            m: i2
          });
        }
        if (this.filterManager.effectElements[10].p.v === 3) {
          var mask2 = createNS("mask");
          var id = createElementID();
          mask2.setAttribute("id", id);
          mask2.setAttribute("mask-type", "alpha");
          mask2.appendChild(groupPath);
          this.elem.globalData.defs.appendChild(mask2);
          var g = createNS("g");
          g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
          while (elemChildren[0]) {
            g.appendChild(elemChildren[0]);
          }
          this.elem.layerElement.appendChild(g);
          this.masker = mask2;
          groupPath.setAttribute("stroke", "#fff");
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (this.filterManager.effectElements[10].p.v === 2) {
            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            while (elemChildren.length) {
              this.elem.layerElement.removeChild(elemChildren[0]);
            }
          }
          this.elem.layerElement.appendChild(groupPath);
          this.elem.layerElement.removeAttribute("mask");
          groupPath.setAttribute("stroke", "#fff");
        }
        this.initialized = true;
        this.pathMasker = groupPath;
      };
      SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
        if (!this.initialized) {
          this.initialize();
        }
        var i2;
        var len = this.paths.length;
        var mask2;
        var path;
        for (i2 = 0; i2 < len; i2 += 1) {
          if (this.paths[i2].m !== -1) {
            mask2 = this.elem.maskManager.viewData[this.paths[i2].m];
            path = this.paths[i2].p;
            if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
              path.setAttribute("d", mask2.lastPath);
            }
            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
              var dasharrayValue;
              if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                var s2 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var e2 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var l2 = path.getTotalLength();
                dasharrayValue = "0 0 0 " + l2 * s2 + " ";
                var lineLength = l2 * (e2 - s2);
                var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                var units = Math.floor(lineLength / segment);
                var j;
                for (j = 0; j < units; j += 1) {
                  dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                }
                dasharrayValue += "0 " + l2 * 10 + " 0 0";
              } else {
                dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              }
              path.setAttribute("stroke-dasharray", dasharrayValue);
            }
          }
        }
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
        }
        if (forceRender || this.filterManager.effectElements[6].p._mdf) {
          this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
        }
        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (forceRender || this.filterManager.effectElements[3].p._mdf) {
            var color = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
          }
        }
      };
      function SVGTritoneFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS("feFuncR");
        feFuncR.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS("feFuncG");
        feFuncG.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS("feFuncB");
        feFuncB.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
      }
      SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color1 = this.filterManager.effectElements[0].p.v;
          var color2 = this.filterManager.effectElements[1].p.v;
          var color3 = this.filterManager.effectElements[2].p.v;
          var tableR = color3[0] + " " + color2[0] + " " + color1[0];
          var tableG = color3[1] + " " + color2[1] + " " + color1[1];
          var tableB = color3[2] + " " + color2[2] + " " + color1[2];
          this.feFuncR.setAttribute("tableValues", tableR);
          this.feFuncG.setAttribute("tableValues", tableG);
          this.feFuncB.setAttribute("tableValues", tableB);
        }
      };
      function SVGProLevelsFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS("feComponentTransfer");
        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
          this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
        }
        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
          this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
        }
        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
          this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
        }
        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
          this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
        }
        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          filter.appendChild(feComponentTransfer);
        }
        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
          feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id);
          filter.appendChild(feComponentTransfer);
          this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
          this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
          this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
        }
      }
      SVGProLevelsFilter.prototype.createFeFunc = function(type2, feComponentTransfer) {
        var feFunc = createNS(type2);
        feFunc.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
      };
      SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
          length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;
        while (cnt <= 256) {
          perc = cnt / 256;
          if (perc <= min) {
            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
          } else if (perc >= max) {
            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
          } else {
            colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
          }
          table[pos] = colorValue;
          pos += 1;
          cnt += 256 / (segments - 1);
        }
        return table.join(" ");
      };
      SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var val2;
          var effectElements = this.filterManager.effectElements;
          if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
            val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
            this.feFuncRComposed.setAttribute("tableValues", val2);
            this.feFuncGComposed.setAttribute("tableValues", val2);
            this.feFuncBComposed.setAttribute("tableValues", val2);
          }
          if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
            val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
            this.feFuncR.setAttribute("tableValues", val2);
          }
          if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
            val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
            this.feFuncG.setAttribute("tableValues", val2);
          }
          if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
            val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
            this.feFuncB.setAttribute("tableValues", val2);
          }
          if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
            val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
            this.feFuncA.setAttribute("tableValues", val2);
          }
        }
      };
      function SVGDropShadowEffect(filter, filterManager, elem2, id, source) {
        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
        var filterSize = filterManager.data.fs || globalFilterSize;
        filter.setAttribute("x", filterSize.x || globalFilterSize.x);
        filter.setAttribute("y", filterSize.y || globalFilterSize.y);
        filter.setAttribute("width", filterSize.width || globalFilterSize.width);
        filter.setAttribute("height", filterSize.height || globalFilterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("in", "SourceAlpha");
        feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
        feGaussianBlur.setAttribute("stdDeviation", "0");
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS("feOffset");
        feOffset.setAttribute("dx", "25");
        feOffset.setAttribute("dy", "0");
        feOffset.setAttribute("in", id + "_drop_shadow_1");
        feOffset.setAttribute("result", id + "_drop_shadow_2");
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS("feFlood");
        feFlood.setAttribute("flood-color", "#00ff00");
        feFlood.setAttribute("flood-opacity", "1");
        feFlood.setAttribute("result", id + "_drop_shadow_3");
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS("feComposite");
        feComposite.setAttribute("in", id + "_drop_shadow_3");
        feComposite.setAttribute("in2", id + "_drop_shadow_2");
        feComposite.setAttribute("operator", "in");
        feComposite.setAttribute("result", id + "_drop_shadow_4");
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
      SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
          }
          if (forceRender || this.filterManager.effectElements[0].p._mdf) {
            var col = this.filterManager.effectElements[0].p.v;
            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
          }
          if (forceRender || this.filterManager.effectElements[1].p._mdf) {
            this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
          }
          if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
            var distance = this.filterManager.effectElements[3].p.v;
            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
            var x = distance * Math.cos(angle);
            var y = distance * Math.sin(angle);
            this.feOffset.setAttribute("dx", x);
            this.feOffset.setAttribute("dy", y);
          }
        }
      };
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(filterElem, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem2;
        elem2.matteElement = createNS("g");
        elem2.matteElement.appendChild(elem2.layerElement);
        elem2.matteElement.appendChild(elem2.transformedElement);
        elem2.baseElement = elem2.matteElement;
      }
      SVGMatte3Effect.prototype.findSymbol = function(mask2) {
        var i2 = 0;
        var len = _svgMatteSymbols.length;
        while (i2 < len) {
          if (_svgMatteSymbols[i2] === mask2) {
            return _svgMatteSymbols[i2];
          }
          i2 += 1;
        }
        return null;
      };
      SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
        var parentNode = mask2.layerElement.parentNode;
        if (!parentNode) {
          return;
        }
        var children = parentNode.children;
        var i2 = 0;
        var len = children.length;
        while (i2 < len) {
          if (children[i2] === mask2.layerElement) {
            break;
          }
          i2 += 1;
        }
        var nextChild;
        if (i2 <= len - 2) {
          nextChild = children[i2 + 1];
        }
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        if (nextChild) {
          parentNode.insertBefore(useElem, nextChild);
        } else {
          parentNode.appendChild(useElem);
        }
      };
      SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
        if (!this.findSymbol(mask2)) {
          var symbolId = createElementID();
          var masker = createNS("mask");
          masker.setAttribute("id", mask2.layerId);
          masker.setAttribute("mask-type", "alpha");
          _svgMatteSymbols.push(mask2);
          var defs = elem2.globalData.defs;
          defs.appendChild(masker);
          var symbol = createNS("symbol");
          symbol.setAttribute("id", symbolId);
          this.replaceInParent(mask2, symbolId);
          symbol.appendChild(mask2.layerElement);
          defs.appendChild(symbol);
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          masker.appendChild(useElem);
          mask2.data.hd = false;
          mask2.show();
        }
        elem2.setMatte(mask2.layerId);
      };
      SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i2 = 0;
        var len = elements.length;
        while (i2 < len) {
          if (elements[i2] && elements[i2].data.ind === ind) {
            this.setElementAsMask(this.elem, elements[i2]);
          }
          i2 += 1;
        }
        this.initialized = true;
      };
      SVGMatte3Effect.prototype.renderFrame = function() {
        if (!this.initialized) {
          this.initialize();
        }
      };
      function SVGGaussianBlurEffect(filter, filterManager, elem2, id) {
        filter.setAttribute("x", "-100%");
        filter.setAttribute("y", "-100%");
        filter.setAttribute("width", "300%");
        filter.setAttribute("height", "300%");
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("result", id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var kBlurrinessToSigma = 0.3;
          var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
          var dimensions = this.filterManager.effectElements[1].p.v;
          var sigmaX = dimensions == 3 ? 0 : sigma;
          var sigmaY = dimensions == 2 ? 0 : sigma;
          this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
          var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
        }
      };
      function TransformEffect() {
      }
      TransformEffect.prototype.init = function(effectsManager) {
        this.effectsManager = effectsManager;
        this.type = effectTypes.TRANSFORM_EFFECT;
        this.matrix = new Matrix();
        this.opacity = -1;
        this._mdf = false;
        this._opMdf = false;
      };
      TransformEffect.prototype.renderFrame = function(forceFrame) {
        this._opMdf = false;
        this._mdf = false;
        if (forceFrame || this.effectsManager._mdf) {
          var effectElements = this.effectsManager.effectElements;
          var anchor = effectElements[0].p.v;
          var position2 = effectElements[1].p.v;
          var isUniformScale = effectElements[2].p.v === 1;
          var scaleHeight = effectElements[3].p.v;
          var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
          var skew = effectElements[5].p.v;
          var skewAxis = effectElements[6].p.v;
          var rotation2 = effectElements[7].p.v;
          this.matrix.reset();
          this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
          this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
          this.matrix.rotate(-rotation2 * degToRads);
          this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
          this.matrix.translate(position2[0], position2[1], 0);
          this._mdf = true;
          if (this.opacity !== effectElements[8].p.v) {
            this.opacity = effectElements[8].p.v;
            this._opMdf = true;
          }
        }
      };
      function SVGTransformEffect(_, filterManager) {
        this.init(filterManager);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(effectsManager) {
        this.init(effectsManager);
      }
      extendPrototype([TransformEffect], CVTransformEffect);
      registerRenderer("canvas", CanvasRenderer);
      registerRenderer("html", HybridRenderer);
      registerRenderer("svg", SVGRenderer);
      ShapeModifiers.registerModifier("tm", TrimModifier);
      ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
      ShapeModifiers.registerModifier("rp", RepeaterModifier);
      ShapeModifiers.registerModifier("rd", RoundCornersModifier);
      ShapeModifiers.registerModifier("zz", ZigZagModifier);
      ShapeModifiers.registerModifier("op", OffsetPathModifier);
      setExpressionsPlugin(Expressions);
      setExpressionInterfaces(getInterface);
      initialize$1();
      initialize();
      registerEffect$1(20, SVGTintFilter, true);
      registerEffect$1(21, SVGFillFilter, true);
      registerEffect$1(22, SVGStrokeEffect, false);
      registerEffect$1(23, SVGTritoneFilter, true);
      registerEffect$1(24, SVGProLevelsFilter, true);
      registerEffect$1(25, SVGDropShadowEffect, true);
      registerEffect$1(28, SVGMatte3Effect, false);
      registerEffect$1(29, SVGGaussianBlurEffect, true);
      registerEffect$1(35, SVGTransformEffect, false);
      registerEffect(35, CVTransformEffect);
      return lottie;
    });
  })(lottie$1, lottie$1.exports);
  var lottieExports = lottie$1.exports;
  const lottie = /* @__PURE__ */ getDefaultExportFromCjs(lottieExports);
  function _iterableToArrayLimit(arr, i2) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i2) ;
        else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true) ;
      } catch (err) {
        _d = true, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value2) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value2;
    }
    return obj;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0) continue;
      target[key2] = source[key2];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2)) continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  var _excluded$1 = ["animationData", "loop", "autoplay", "initialSegment", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart", "onConfigReady", "onDataReady", "onDataFailed", "onLoadedImages", "onDOMLoaded", "onDestroy", "lottieRef", "renderer", "name", "assetsPath", "rendererSettings"];
  var useLottie = function useLottie2(props, style) {
    var animationData = props.animationData, loop2 = props.loop, autoplay = props.autoplay, initialSegment = props.initialSegment, onComplete = props.onComplete, onLoopComplete = props.onLoopComplete, onEnterFrame = props.onEnterFrame, onSegmentStart = props.onSegmentStart, onConfigReady = props.onConfigReady, onDataReady = props.onDataReady, onDataFailed = props.onDataFailed, onLoadedImages = props.onLoadedImages, onDOMLoaded = props.onDOMLoaded, onDestroy = props.onDestroy;
    props.lottieRef;
    props.renderer;
    props.name;
    props.assetsPath;
    props.rendererSettings;
    var rest = _objectWithoutProperties(props, _excluded$1);
    var _useState = React.useState(false), _useState2 = _slicedToArray(_useState, 2), animationLoaded = _useState2[0], setAnimationLoaded = _useState2[1];
    var animationInstanceRef = React.useRef();
    var animationContainer = React.useRef(null);
    var play = function play2() {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();
    };
    var stop2 = function stop3() {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();
    };
    var pause = function pause2() {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();
    };
    var setSpeed = function setSpeed2(speed) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);
    };
    var goToAndPlay = function goToAndPlay2(value2, isFrame) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value2, isFrame);
    };
    var goToAndStop = function goToAndStop2(value2, isFrame) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value2, isFrame);
    };
    var setDirection = function setDirection2(direction) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);
    };
    var playSegments = function playSegments2(segments, forceFlag) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);
    };
    var setSubframe = function setSubframe2(useSubFrames) {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);
    };
    var getDuration = function getDuration2(inFrames) {
      var _a;
      return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);
    };
    var destroy = function destroy2() {
      var _a;
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
      animationInstanceRef.current = void 0;
    };
    var loadAnimation2 = function loadAnimation3() {
      var forcedConfigs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _a;
      if (!animationContainer.current) {
        return;
      }
      (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
      var config2 = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {
        container: animationContainer.current
      });
      animationInstanceRef.current = lottie.loadAnimation(config2);
      setAnimationLoaded(!!animationInstanceRef.current);
      return function() {
        var _a2;
        (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        animationInstanceRef.current = void 0;
      };
    };
    React.useEffect(function() {
      var onUnmount = loadAnimation2();
      return function() {
        return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
      };
    }, [animationData, loop2]);
    React.useEffect(function() {
      if (!animationInstanceRef.current) {
        return;
      }
      animationInstanceRef.current.autoplay = !!autoplay;
    }, [autoplay]);
    React.useEffect(function() {
      if (!animationInstanceRef.current) {
        return;
      }
      if (!initialSegment) {
        animationInstanceRef.current.resetSegments(true);
        return;
      }
      if (!Array.isArray(initialSegment) || !initialSegment.length) {
        return;
      }
      if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {
        animationInstanceRef.current.currentRawFrame = initialSegment[0];
      }
      animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);
    }, [initialSegment]);
    React.useEffect(function() {
      var partialListeners = [{
        name: "complete",
        handler: onComplete
      }, {
        name: "loopComplete",
        handler: onLoopComplete
      }, {
        name: "enterFrame",
        handler: onEnterFrame
      }, {
        name: "segmentStart",
        handler: onSegmentStart
      }, {
        name: "config_ready",
        handler: onConfigReady
      }, {
        name: "data_ready",
        handler: onDataReady
      }, {
        name: "data_failed",
        handler: onDataFailed
      }, {
        name: "loaded_images",
        handler: onLoadedImages
      }, {
        name: "DOMLoaded",
        handler: onDOMLoaded
      }, {
        name: "destroy",
        handler: onDestroy
      }];
      var listeners = partialListeners.filter(function(listener) {
        return listener.handler != null;
      });
      if (!listeners.length) {
        return;
      }
      var deregisterList = listeners.map(
        /**
         * Handle the process of adding an event listener
         * @param {Listener} listener
         * @return {Function} Function that deregister the listener
         */
        function(listener) {
          var _a;
          (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);
          return function() {
            var _a2;
            (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(listener.name, listener.handler);
          };
        }
      );
      return function() {
        deregisterList.forEach(function(deregister) {
          return deregister();
        });
      };
    }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);
    var View = /* @__PURE__ */ React.createElement("div", _objectSpread2({
      style,
      ref: animationContainer
    }, rest));
    return {
      View,
      play,
      stop: stop2,
      pause,
      setSpeed,
      goToAndStop,
      goToAndPlay,
      setDirection,
      playSegments,
      setSubframe,
      getDuration,
      destroy,
      animationContainerRef: animationContainer,
      animationLoaded,
      animationItem: animationInstanceRef.current
    };
  };
  function getContainerVisibility(container) {
    var _container$getBoundin = container.getBoundingClientRect(), top = _container$getBoundin.top, height2 = _container$getBoundin.height;
    var current = window.innerHeight - top;
    var max = window.innerHeight + height2;
    return current / max;
  }
  function getContainerCursorPosition(container, cursorX, cursorY) {
    var _container$getBoundin2 = container.getBoundingClientRect(), top = _container$getBoundin2.top, left = _container$getBoundin2.left, width2 = _container$getBoundin2.width, height2 = _container$getBoundin2.height;
    var x = (cursorX - left) / width2;
    var y = (cursorY - top) / height2;
    return {
      x,
      y
    };
  }
  var useInitInteractivity = function useInitInteractivity2(_ref) {
    var wrapperRef = _ref.wrapperRef, animationItem = _ref.animationItem, mode = _ref.mode, actions = _ref.actions;
    React.useEffect(function() {
      var wrapper = wrapperRef.current;
      if (!wrapper || !animationItem || !actions.length) {
        return;
      }
      animationItem.stop();
      var scrollModeHandler = function scrollModeHandler2() {
        var assignedSegment = null;
        var scrollHandler = function scrollHandler2() {
          var currentPercent = getContainerVisibility(wrapper);
          var action = actions.find(function(_ref2) {
            var visibility = _ref2.visibility;
            return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];
          });
          if (!action) {
            return;
          }
          if (action.type === "seek" && action.visibility && action.frames.length === 2) {
            var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);
            //! goToAndStop must be relative to the start of the current segment
            animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);
          }
          if (action.type === "loop") {
            if (assignedSegment === null) {
              animationItem.playSegments(action.frames, true);
              assignedSegment = action.frames;
            } else {
              if (assignedSegment !== action.frames) {
                animationItem.playSegments(action.frames, true);
                assignedSegment = action.frames;
              } else if (animationItem.isPaused) {
                animationItem.playSegments(action.frames, true);
                assignedSegment = action.frames;
              }
            }
          }
          if (action.type === "play" && animationItem.isPaused) {
            animationItem.resetSegments(true);
            animationItem.play();
          }
          if (action.type === "stop") {
            animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);
          }
        };
        document.addEventListener("scroll", scrollHandler);
        return function() {
          document.removeEventListener("scroll", scrollHandler);
        };
      };
      var cursorModeHandler = function cursorModeHandler2() {
        var handleCursor = function handleCursor2(_x, _y) {
          var x = _x;
          var y = _y;
          if (x !== -1 && y !== -1) {
            var pos = getContainerCursorPosition(wrapper, x, y);
            x = pos.x;
            y = pos.y;
          }
          var action = actions.find(function(_ref3) {
            var position2 = _ref3.position;
            if (position2 && Array.isArray(position2.x) && Array.isArray(position2.y)) {
              return x >= position2.x[0] && x <= position2.x[1] && y >= position2.y[0] && y <= position2.y[1];
            }
            if (position2 && !Number.isNaN(position2.x) && !Number.isNaN(position2.y)) {
              return x === position2.x && y === position2.y;
            }
            return false;
          });
          if (!action) {
            return;
          }
          if (action.type === "seek" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {
            var xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);
            var yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);
            animationItem.playSegments(action.frames, true);
            animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);
          }
          if (action.type === "loop") {
            animationItem.playSegments(action.frames, true);
          }
          if (action.type === "play") {
            if (animationItem.isPaused) {
              animationItem.resetSegments(false);
            }
            animationItem.playSegments(action.frames);
          }
          if (action.type === "stop") {
            animationItem.goToAndStop(action.frames[0], true);
          }
        };
        var mouseMoveHandler = function mouseMoveHandler2(ev) {
          handleCursor(ev.clientX, ev.clientY);
        };
        var mouseOutHandler = function mouseOutHandler2() {
          handleCursor(-1, -1);
        };
        wrapper.addEventListener("mousemove", mouseMoveHandler);
        wrapper.addEventListener("mouseout", mouseOutHandler);
        return function() {
          wrapper.removeEventListener("mousemove", mouseMoveHandler);
          wrapper.removeEventListener("mouseout", mouseOutHandler);
        };
      };
      switch (mode) {
        case "scroll":
          return scrollModeHandler();
        case "cursor":
          return cursorModeHandler();
      }
    }, [mode, animationItem]);
  };
  var useLottieInteractivity = function useLottieInteractivity2(_ref4) {
    var actions = _ref4.actions, mode = _ref4.mode, lottieObj = _ref4.lottieObj;
    var animationItem = lottieObj.animationItem, View = lottieObj.View, animationContainerRef = lottieObj.animationContainerRef;
    useInitInteractivity({
      actions,
      animationItem,
      mode,
      wrapperRef: animationContainerRef
    });
    return View;
  };
  var _excluded = ["style", "interactivity"];
  var Lottie$1 = function Lottie2(props) {
    var _a, _b, _c;
    var style = props.style, interactivity = props.interactivity, lottieProps = _objectWithoutProperties(props, _excluded);
    var _useLottie = useLottie(lottieProps, style), View = _useLottie.View, play = _useLottie.play, stop2 = _useLottie.stop, pause = _useLottie.pause, setSpeed = _useLottie.setSpeed, goToAndStop = _useLottie.goToAndStop, goToAndPlay = _useLottie.goToAndPlay, setDirection = _useLottie.setDirection, playSegments = _useLottie.playSegments, setSubframe = _useLottie.setSubframe, getDuration = _useLottie.getDuration, destroy = _useLottie.destroy, animationContainerRef = _useLottie.animationContainerRef, animationLoaded = _useLottie.animationLoaded, animationItem = _useLottie.animationItem;
    React.useEffect(function() {
      if (props.lottieRef) {
        props.lottieRef.current = {
          play,
          stop: stop2,
          pause,
          setSpeed,
          goToAndPlay,
          goToAndStop,
          setDirection,
          playSegments,
          setSubframe,
          getDuration,
          destroy,
          animationContainerRef,
          animationLoaded,
          animationItem
        };
      }
    }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);
    return useLottieInteractivity({
      lottieObj: {
        View,
        play,
        stop: stop2,
        pause,
        setSpeed,
        goToAndStop,
        goToAndPlay,
        setDirection,
        playSegments,
        setSubframe,
        getDuration,
        destroy,
        animationContainerRef,
        animationLoaded,
        animationItem
      },
      actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],
      mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : "scroll"
    });
  };
  var Lottie = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var loadingLottieRef = React.useRef(null);
    var style = props.style, source = props.source;
    props.autoPlay;
    var rest = _object_without_properties(props, [
      "style",
      "source",
      "autoPlay"
    ]);
    React.useImperativeHandle(ref, function() {
      return loadingLottieRef.current;
    });
    return /* @__PURE__ */ React.createElement(Lottie$1, _object_spread_props(_object_spread({}, rest), {
      lottieRef: loadingLottieRef,
      animationData: source,
      style
    }));
  });
  Lottie.displayName = "NutLottie";
  var defaultPaginationOptions = {
    current: 0,
    itemsPerPage: 10,
    displayCount: 5,
    ellipse: false
  };
  function human2Machine(number2) {
    return --number2;
  }
  function calculateNodes(options2, nodesCount) {
    var halfIndex = Math.floor(options2.displayCount / 2);
    var buttonsCountIndex = human2Machine(nodesCount);
    var displayCountIndex = human2Machine(options2.displayCount);
    var currentIndex = human2Machine(options2.current);
    var start2;
    var end;
    if (buttonsCountIndex <= displayCountIndex) {
      start2 = 0;
      end = buttonsCountIndex;
    } else {
      start2 = Math.max(0, currentIndex - halfIndex);
      end = Math.min(buttonsCountIndex, currentIndex + halfIndex);
      if (end - start2 < displayCountIndex) {
        if (start2 === 0) {
          end = Math.min(start2 + displayCountIndex, buttonsCountIndex);
        } else if (end === buttonsCountIndex) {
          start2 = Math.max(end - displayCountIndex, 1);
        }
      } else if (end - start2 > displayCountIndex) {
        end = start2 + displayCountIndex;
      }
    }
    var buttons = [];
    for (var i2 = start2; i2 <= end; i2++) {
      var humanPageNumber = i2 + 1;
      buttons.push({
        number: humanPageNumber,
        text: humanPageNumber.toString(),
        selected: options2.current === humanPageNumber
      });
    }
    return addEllipses(buttons, {
      nodesCount,
      ellipse: options2.ellipse,
      displayCount: options2.displayCount
    });
  }
  function addEllipses(nodes, param) {
    var displayCount = param.displayCount, nodesCount = param.nodesCount, ellipse = param.ellipse;
    if (nodesCount <= displayCount || !ellipse) return nodes;
    var start2 = nodes[0];
    var end = nodes[nodes.length - 1];
    var leftEllipse = start2.number > 1;
    var rightEllipse = end.number < nodesCount;
    if (leftEllipse) {
      nodes.unshift({
        number: start2.number - 1,
        text: "..."
      });
    }
    if (rightEllipse) {
      nodes.push({
        number: end.number + 1,
        text: "..."
      });
    }
    return nodes;
  }
  var usePagination = function(options2) {
    var mergedOptions = _object_spread({}, defaultPaginationOptions, options2);
    var total = mergedOptions.total, itemsPerPage = mergedOptions.itemsPerPage;
    var nodesCount = Math.ceil((total || 0) / itemsPerPage) || 1;
    return [
      calculateNodes(mergedOptions, nodesCount),
      nodesCount
    ];
  };
  var defaultProps$f = _object_spread_props(_object_spread({}, ComponentDefaults), {
    defaultValue: 1,
    mode: "multi",
    prev: null,
    next: null,
    total: 50,
    pageSize: 10,
    itemSize: 5,
    ellipse: false
  });
  var Pagination = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$f, props), value2 = _ref.value, mode = _ref.mode, prev = _ref.prev, next = _ref.next, total = _ref.total, pageSize = _ref.pageSize, itemSize = _ref.itemSize, onChange = _ref.onChange, ellipse = _ref.ellipse, itemRender = _ref.itemRender, defaultValue = _ref.defaultValue, className = _ref.className;
    _ref.style;
    var rest = _object_without_properties(_ref, [
      "value",
      "mode",
      "prev",
      "next",
      "total",
      "pageSize",
      "itemSize",
      "onChange",
      "ellipse",
      "itemRender",
      "defaultValue",
      "className",
      "style"
    ]);
    var classPrefix2 = "nut-pagination";
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: value2,
      defaultValue,
      finalValue: 1,
      onChange
    }), 2), current = _usePropsValue[0], setCurrent = _usePropsValue[1];
    var _usePagination = _sliced_to_array(usePagination({
      total,
      ellipse,
      current,
      displayCount: itemSize,
      itemsPerPage: pageSize
    }), 2), pages = _usePagination[0], pageCount = _usePagination[1];
    var handleClick = function(item) {
      if (item.selected) return;
      if (item.number > pageCount || item.number < 1) return;
      setCurrent(item.number);
    };
    var prevPage = function() {
      var prev2 = current - 1;
      prev2 >= 1 && setCurrent(prev2);
    };
    var nextPage = function() {
      var next2 = current + 1;
      next2 <= pageCount && setCurrent(next2);
    };
    var _obj, _obj1;
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix2, className)
    }, rest), (mode === "multi" || mode === "simple") && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-prev"), true), _define_property(_obj, "".concat(classPrefix2, "-simple-border"), mode !== "multi"), _define_property(_obj, "".concat(classPrefix2, "-prev-disabled"), current === 1), _obj)),
      onClick: function() {
        return prevPage();
      }
    }, prev || locale.pagination.prev), mode === "multi" && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-contain")
    }, pages.map(function(item, index2) {
      var _obj2;
      return /* @__PURE__ */ React.createElement("div", {
        key: "".concat(index2, "pagination"),
        className: classNames((_obj2 = {}, _define_property(_obj2, "".concat(classPrefix2, "-item"), true), _define_property(_obj2, "".concat(classPrefix2, "-item-active"), item.selected), _obj2)),
        onClick: function() {
          handleClick(item);
        }
      }, itemRender ? itemRender(item, current) : item.text);
    })), mode === "simple" && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-contain")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-simple")
    }, current, "/", pageCount)), /* @__PURE__ */ React.createElement("div", {
      className: classNames((_obj1 = {}, _define_property(_obj1, "".concat(classPrefix2, "-next"), true), _define_property(_obj1, "".concat(classPrefix2, "-next-disabled"), current >= pageCount), _obj1)),
      onClick: function() {
        return nextPage();
      }
    }, next || locale.pagination.next)), mode === "lite" && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-lite")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-lite-active")
    }, current), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-lite-spliterator")
    }, "/"), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-lite-default")
    }, pageCount)));
  };
  Pagination.displayName = "NutPagination";
  var defaultProps$e = _object_spread_props(_object_spread({}, ComponentDefaults), {
    color: "primary",
    price: 0,
    symbol: "&yen;",
    digits: 2,
    thousands: false,
    position: "before",
    size: "normal",
    line: false
  });
  var Price = function(props) {
    var _ref = _object_spread({}, defaultProps$e, props), color = _ref.color, price = _ref.price, symbol = _ref.symbol, digits = _ref.digits, thousands = _ref.thousands, position2 = _ref.position, size = _ref.size, line = _ref.line, className = _ref.className, style = _ref.style, rest = _object_without_properties(_ref, [
      "color",
      "price",
      "symbol",
      "digits",
      "thousands",
      "position",
      "size",
      "line",
      "className",
      "style"
    ]);
    var classPrefix2 = "nut-price";
    var rtl = useRtl();
    var checkPoint = function(price2) {
      return String(price2).indexOf(".") > 0;
    };
    var formatThousands = function(num) {
      if (Number(num) === 0) {
        num = 0;
      }
      if (checkPoint(num)) {
        num = num.toString();
        num = typeof num.split(".") === "string" ? num.split(".") : num.split(".")[0];
      }
      if (thousands) {
        return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
      }
      return num;
    };
    var formatDecimal = function(decimalNum) {
      if (Number(decimalNum) === 0) {
        decimalNum = 0;
      }
      if (checkPoint(decimalNum)) {
        decimalNum = Number(decimalNum).toFixed(digits);
        decimalNum = typeof decimalNum.split(".") === "string" ? 0 : decimalNum.split(".")[1] || 0;
      } else {
        decimalNum = 0;
      }
      var result = "0.".concat(decimalNum);
      var resultFixed = Number(result).toFixed(digits);
      return String(resultFixed).substring(2, resultFixed.length);
    };
    var renderSymbol = function() {
      var _obj;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames([
          "".concat(classPrefix2, "-symbol"),
          "".concat(classPrefix2, "-symbol-").concat(size),
          (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-line"), line), _define_property(_obj, "".concat(classPrefix2, "-rtl"), rtl), _obj)
        ]),
        dangerouslySetInnerHTML: {
          __html: symbol || ""
        }
      });
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classPrefix2, " ").concat(classPrefix2, "-").concat(color, " ").concat(className),
      style
    }, rest), symbol && position2 === "before" ? renderSymbol() : null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-integer ").concat(classPrefix2, "-integer-").concat(size, " ").concat(line ? "".concat(classPrefix2, "-line") : "")
    }, formatThousands(price)), digits ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-decimal ").concat(classPrefix2, "-decimal-").concat(size, " ").concat(line ? "".concat(classPrefix2, "-line") : "")
    }, "."), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-decimal ").concat(classPrefix2, "-decimal-").concat(size, " ").concat(line ? "".concat(classPrefix2, "-line") : "")
    }, formatDecimal(price))) : null, symbol && position2 === "after" ? renderSymbol() : null);
  };
  Price.displayName = "NutPrice";
  var defaultProps$d = {
    options: [],
    onChange: function(value2) {
    }
  };
  var Segmented = function(props) {
    var classPrefix2 = "nut-segmented";
    var itemClassPrefix = "nut-segmented-item";
    var mergedProps = mergeProps(defaultProps$d, props);
    var options2 = mergedProps.options;
    mergedProps.onChange;
    var _usePropsValue = _sliced_to_array(usePropsValue({
      value: mergedProps.value,
      defaultValue: mergedProps.defaultValue,
      finalValue: 0,
      onChange: mergedProps.onChange
    }), 2), value2 = _usePropsValue[0], setValue = _usePropsValue[1];
    var renderItems = React.useCallback(function(options3, value3) {
      return options3.map(function(option, index2) {
        var optionType = typeof option === "undefined" ? "undefined" : _type_of(option);
        switch (optionType) {
          case "object":
            var opt = option;
            var _obj;
            return /* @__PURE__ */ React.createElement("div", {
              className: classNames(itemClassPrefix, (_obj = {}, _define_property(_obj, "".concat(itemClassPrefix, "-active"), opt.value === value3), _define_property(_obj, "".concat(opt.className), !!opt.className), _obj)),
              key: opt.value,
              onClick: function() {
                if (opt.disabled) return;
                setValue(opt.value);
              }
            }, opt.icon ? /* @__PURE__ */ React.createElement("span", {
              className: "nut-segmented-icon"
            }, opt.icon) : null, opt.label);
          default: {
            if (typeof option !== "string" && typeof option !== "number") {
              console.warn("Unsupported option type:", optionType);
            }
            return /* @__PURE__ */ React.createElement("div", {
              className: classNames(itemClassPrefix, _define_property({}, "".concat(itemClassPrefix, "-active"), index2 === value3)),
              key: option.toString(),
              onClick: function() {
                setValue(index2);
              }
            }, option);
          }
        }
      });
    }, [
      value2
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2),
      style: mergedProps.style
    }, renderItems(options2, value2));
  };
  var DataContext = React.createContext({});
  var defaultProps$c = _object_spread_props(_object_spread({}, ComponentDefaults), {
    title: "",
    description: "",
    value: 0,
    icon: null
  });
  var Step = function(props) {
    var _ref = _object_spread({}, defaultProps$c, props), type2 = _ref.type;
    _ref.children;
    var title = _ref.title, description = _ref.description, value2 = _ref.value, icon = _ref.icon, className = _ref.className, restProps = _object_without_properties(_ref, [
      "type",
      "children",
      "title",
      "description",
      "value",
      "icon",
      "className"
    ]);
    var parent2 = React.useContext(DataContext);
    var _parent_propSteps = parent2.propSteps, parentType = _parent_propSteps.type, parentValue = _parent_propSteps.value, status = _parent_propSteps.status, parentIcon = _parent_propSteps.icon, onStepClick = _parent_propSteps.onStepClick;
    var currentStatus = React.useMemo(function() {
      if ([
        "default",
        "business"
      ].includes(status)) {
        return status;
      }
      if (value2 < +parentValue) return "finish";
      return value2 === +parentValue ? "process" : "wait";
    }, [
      value2,
      parentValue
    ]);
    var handleClickStep = React.useCallback(function() {
      onStepClick === null || onStepClick === void 0 ? void 0 : onStepClick(value2);
    }, [
      onStepClick,
      value2
    ]);
    var classPrefix2 = "nut-step";
    var classes = React.useMemo(function() {
      var _obj;
      return classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-").concat(currentStatus), true), _define_property(_obj, "".concat(classPrefix2, "-").concat(type2 || parentType), true), _define_property(_obj, "".concat(classPrefix2, "-special"), description), _obj), className);
    }, [
      currentStatus,
      type2,
      className
    ]);
    var renderHeadType = React.useMemo(function() {
      switch (type2 || parentType) {
        case "text":
          return /* @__PURE__ */ React.createElement("span", {
            className: "".concat(classPrefix2, "-head-text")
          }, value2);
        case "dot":
          return /* @__PURE__ */ React.createElement("span", {
            className: "".concat(classPrefix2, "-head-dot")
          });
        case "icon":
          return /* @__PURE__ */ React.createElement("span", {
            className: "".concat(classPrefix2, "-head-icon")
          }, icon || parentIcon);
        default:
          return null;
      }
    }, [
      type2,
      value2,
      icon
    ]);
    var renderContent = React.useMemo(function() {
      if (!title && !description) return null;
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix2, "-main")
      }, title && /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-title")
      }, title), description && /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-description")
      }, description));
    }, [
      title,
      description
    ]);
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: classes
    }, restProps), {
      onClick: handleClickStep
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-head")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-head-").concat(type2 || parentType, "-wrap")
    }, renderHeadType)), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-line")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-line-inner")
    })), renderContent);
  };
  Step.displayName = "NutStep";
  var defaultProps$b = _object_spread_props(_object_spread({}, ComponentDefaults), {
    direction: "horizontal",
    layout: "single",
    type: "text",
    status: "default",
    value: 0,
    icon: null
  });
  var Steps = function(props) {
    var propSteps = _object_spread({}, defaultProps$b, props);
    var direction = propSteps.direction;
    propSteps.value;
    var layout = propSteps.layout, status = propSteps.status, type2 = propSteps.type, className = propSteps.className, children = propSteps.children;
    propSteps.onStepClick;
    var restProps = _object_without_properties(propSteps, [
      "direction",
      "value",
      "layout",
      "status",
      "type",
      "className",
      "children",
      "onStepClick"
    ]);
    var parentSteps = {
      propSteps
    };
    var classPrefix2 = "nut-steps";
    var _obj;
    var classes = classNames(classPrefix2, (_obj = {}, _define_property(_obj, "".concat(classPrefix2, "-").concat(direction), true), _define_property(_obj, "".concat(classPrefix2, "-").concat(direction, "-count-").concat(React.Children.count(children)), true), _define_property(_obj, "".concat(classPrefix2, "-").concat(direction, "-").concat(layout), true), _define_property(_obj, "".concat(classPrefix2, "-").concat(direction, "-").concat(type2), true), _define_property(_obj, "".concat(classPrefix2, "-").concat(direction, "-").concat(status), true), _obj), className);
    return /* @__PURE__ */ React.createElement(DataContext.Provider, {
      value: parentSteps
    }, /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, restProps), React.Children.map(children, function(child, index2) {
      if (/* @__PURE__ */ React.isValidElement(child)) {
        return /* @__PURE__ */ React.cloneElement(child, {
          // @ts-ignore
          className: classNames(child.props.className, {
            "nut-step-last": index2 === React.Children.count(children) - 1
          })
        });
      }
      return child;
    })));
  };
  Steps.displayName = "NutSteps";
  function useTableSticky(columns) {
    var rtl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var _useState = _sliced_to_array(React.useState(false), 2), isSticky = _useState[0], setIsSticky = _useState[1];
    var _useState1 = _sliced_to_array(React.useState({}), 2), stickyColumnStyleMap = _useState1[0], setStickyColumnStyleMap = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState({}), 2), stickyColumnClassMap = _useState2[0], setStickyColumnClassMap = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(0), 2), stickyLeftWidth = _useState3[0], setStickyLeftWidth = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState(0), 2), stickyRightWidth = _useState4[0], setStickyRightWidth = _useState4[1];
    React.useEffect(function() {
      var leftColumns = columns.filter(function(item) {
        return item.fixed === "left";
      }) || [];
      var rightColumns = columns.filter(function(item) {
        return item.fixed === "right";
      }) || [];
      var middleColumns = columns.filter(function(item) {
        return !item.fixed;
      }) || [];
      var _columnStyleMap = {};
      var _columnClassMap = {};
      var _stickyLeftWidth = 0;
      var _stickyRightWidth = 0;
      leftColumns.forEach(function(curr2, index2) {
        var dir2 = rtl ? "right" : "left";
        var _obj2;
        _columnStyleMap[curr2.key] = (_obj2 = {}, _define_property(_obj2, dir2, _stickyLeftWidth || 0), _define_property(_obj2, "width", curr2.width || "auto"), _obj2);
        _columnClassMap[curr2.key] = {
          "nut-table-fixed-left": true,
          "nut-table-fixed-left-last": index2 === leftColumns.length - 1
        };
        _stickyLeftWidth += curr2.width || 0;
      });
      middleColumns.forEach(function(curr2) {
        _columnStyleMap[curr2.key] = {
          width: curr2.width || "auto"
        };
      });
      for (var i2 = rightColumns.length - 1; i2 >= 0; i2--) {
        var curr = rightColumns[i2];
        var dir = rtl ? "left" : "right";
        var _obj;
        _columnStyleMap[curr.key] = (_obj = {}, _define_property(_obj, dir, _stickyRightWidth || 0), _define_property(_obj, "width", curr.width || "auto"), _obj);
        _columnClassMap[curr.key] = {
          "nut-table-fixed-right": true,
          "nut-table-fixed-right-first": i2 === 0
        };
        _stickyRightWidth += curr.width || 0;
      }
      setIsSticky(leftColumns.length > 0 || rightColumns.length > 0);
      setStickyColumnStyleMap(_columnStyleMap);
      setStickyColumnClassMap(_columnClassMap);
      setStickyLeftWidth(_stickyLeftWidth);
      setStickyRightWidth(_stickyRightWidth);
    }, [
      columns
    ]);
    var getStickyStyle = React.useCallback(function(key2) {
      return stickyColumnStyleMap[key2];
    }, [
      stickyColumnStyleMap
    ]);
    var getStickyClass = React.useCallback(function(key2) {
      return stickyColumnClassMap[key2];
    }, [
      stickyColumnClassMap
    ]);
    return {
      isSticky,
      stickyLeftWidth,
      stickyRightWidth,
      getStickyClass,
      getStickyStyle
    };
  }
  var defaultProps$a = _object_spread_props(_object_spread({}, ComponentDefaults), {
    columns: [],
    data: [],
    bordered: true,
    striped: false,
    noData: "",
    sorterIcon: null,
    showHeader: true
  });
  var Table = function(props) {
    var locale = useConfig().locale;
    var rtl = useRtl();
    defaultProps$a.noData = locale.noData;
    var _ref = _object_spread({}, defaultProps$a, props);
    _ref.children;
    var className = _ref.className, style = _ref.style, columns = _ref.columns, data2 = _ref.data, bordered = _ref.bordered, summary = _ref.summary, striped = _ref.striped, noData = _ref.noData, sorterIcon = _ref.sorterIcon, showHeader = _ref.showHeader, onSort = _ref.onSort, rest = _object_without_properties(_ref, [
      "children",
      "className",
      "style",
      "columns",
      "data",
      "bordered",
      "summary",
      "striped",
      "noData",
      "sorterIcon",
      "showHeader",
      "onSort"
    ]);
    var sortedMapping = React.useRef({});
    var _usePropsValue = _sliced_to_array(usePropsValue({
      defaultValue: data2,
      finalValue: []
    }), 2), innerValue = _usePropsValue[0], setValue = _usePropsValue[1];
    var _useTableSticky = useTableSticky(columns, rtl), isSticky = _useTableSticky.isSticky, stickyLeftWidth = _useTableSticky.stickyLeftWidth, stickyRightWidth = _useTableSticky.stickyRightWidth, getStickyClass = _useTableSticky.getStickyClass, getStickyStyle = _useTableSticky.getStickyStyle;
    React.useEffect(function() {
      setValue(data2);
    }, [
      data2
    ]);
    var classPrefix2 = "nut-table";
    var headerClassPrefix = "".concat(classPrefix2, "-main-head-tr");
    var bodyClassPrefix = "".concat(classPrefix2, "-main-body-tr");
    var cls = classNames(classPrefix2, className);
    var handleSorterClick = function(item) {
      if (item.sorter && !sortedMapping.current[item.key]) {
        var copied = _to_consumable_array(innerValue);
        if (typeof item.sorter === "function") {
          copied.sort(item.sorter);
        } else if (item.sorter === "default") {
          copied.sort();
        }
        sortedMapping.current[item.key] = true;
        setValue(copied, true);
        onSort && onSort(item, copied);
      } else {
        sortedMapping.current[item.key] = false;
        setValue(data2);
      }
    };
    var cellClasses = function(item) {
      var _obj;
      return _obj = {}, _define_property(_obj, "".concat(headerClassPrefix, "-border"), bordered), _define_property(_obj, "".concat(headerClassPrefix, "-align").concat(item.align ? item.align : ""), true), _obj;
    };
    var getColumnItem = function(value2) {
      return columns.filter(function(item) {
        return item.key === value2;
      })[0];
    };
    var renderHeadCells = function() {
      return columns.map(function(item, index2) {
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("".concat(headerClassPrefix, "-th"), cellClasses(item), getStickyClass(item.key)),
          key: item.key,
          onClick: function() {
            return handleSorterClick(item);
          },
          style: getStickyStyle(item.key)
        }, item.title, "", item.sorter && (sorterIcon || /* @__PURE__ */ React.createElement(l$1, {
          width: "12px",
          height: "12px"
        })));
      });
    };
    var sortDataItem = function() {
      return columns.map(function(columns2) {
        return [
          columns2.key,
          columns2.render
        ];
      });
    };
    var renderBodyTds = function(item, rowIndex) {
      return sortDataItem().map(function(param) {
        var _param = _sliced_to_array(param, 2), value2 = _param[0], render2 = _param[1];
        return /* @__PURE__ */ React.createElement("div", {
          className: classNames("".concat(bodyClassPrefix, "-td"), cellClasses(getColumnItem(value2)), getStickyClass(value2)),
          key: value2,
          style: getStickyStyle(value2)
        }, typeof item[value2] === "function" || typeof render2 === "function" ? /* @__PURE__ */ React.createElement("div", null, render2 ? render2(item, rowIndex) : item[value2](item)) : item[value2]);
      });
    };
    var renderBodyTrs = function() {
      return innerValue.map(function(item, index2) {
        var inner = renderBodyTds(item, index2);
        var rowRender = item.rowRender;
        if (rowRender && typeof rowRender === "function") {
          return rowRender(item, index2, {
            inner
          });
        }
        return /* @__PURE__ */ React.createElement("div", {
          className: bodyClassPrefix,
          key: index2
        }, inner);
      });
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: cls
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-wrapper ").concat(isSticky ? "".concat(classPrefix2, "-wrapper-sticky") : "")),
      style
    }, /* @__PURE__ */ React.createElement("div", {
      className: classNames("".concat(classPrefix2, "-main"), _define_property({}, "".concat(classPrefix2, "-main-striped"), striped))
    }, showHeader && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-main-head")
    }, /* @__PURE__ */ React.createElement("div", {
      className: headerClassPrefix
    }, renderHeadCells())), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-main-body")
    }, renderBodyTrs()))), isSticky ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-sticky-left"),
      style: {
        width: stickyLeftWidth
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-sticky-right"),
      style: {
        width: stickyRightWidth
      }
    })) : null, (summary || innerValue.length === 0) && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-summary")
    }, summary || noData));
  };
  Table.displayName = "NutTable";
  var defaultProps$9 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    type: "default",
    background: "",
    color: "",
    plain: false,
    round: false,
    mark: false,
    closeable: false,
    closeIcon: null,
    onClose: function(e2) {
    },
    onClick: function(e2) {
    }
  });
  var Tag = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$9, props), className = _$_object_spread.className, style = _$_object_spread.style, background = _$_object_spread.background, plain = _$_object_spread.plain, type2 = _$_object_spread.type, round = _$_object_spread.round, children = _$_object_spread.children, mark = _$_object_spread.mark, closeable = _$_object_spread.closeable, closeIcon = _$_object_spread.closeIcon, color = _$_object_spread.color, onClick = _$_object_spread.onClick, onClose = _$_object_spread.onClose;
    var _useState = _sliced_to_array(React.useState(true), 2), visible = _useState[0], setVisible = _useState[1];
    var classPrefix2 = "nut-tag";
    var _obj;
    var classes = classNames((_obj = {}, _define_property(_obj, classPrefix2, true), _define_property(_obj, "".concat(classPrefix2, "-").concat(type2), type2), _define_property(_obj, "".concat(classPrefix2, "-plain"), plain), _define_property(_obj, "".concat(classPrefix2, "-round"), round), _define_property(_obj, "".concat(classPrefix2, "-mark"), mark), _define_property(_obj, "".concat(classPrefix2, "-close"), closeable), _define_property(_obj, "".concat(className), className), _obj));
    var handleClick = function(e2) {
      onClick && onClick(e2);
    };
    var getStyle = function() {
      var style2 = {};
      if (plain) {
        style2.borderColor = background;
      } else if (background) {
        style2.backgroundColor = background;
      }
      return style2;
    };
    var getTextStyle = function() {
      var style2 = {};
      if (color) {
        style2.color = color;
      } else if (background && plain) {
        style2.color = background;
      }
      return style2;
    };
    var textClasses = classNames("".concat(classPrefix2, "-text"), _define_property({}, "".concat(classPrefix2, "-text-plain"), plain));
    return /* @__PURE__ */ React.createElement(React.Fragment, null, closeable ? visible && /* @__PURE__ */ React.createElement("div", {
      className: classes,
      style: _object_spread({}, style, getStyle()),
      onClick: function(e2) {
        return handleClick(e2);
      }
    }, children && /* @__PURE__ */ React.createElement("span", {
      className: textClasses,
      style: getTextStyle()
    }, children), /* @__PURE__ */ React.isValidElement(closeIcon) ? /* @__PURE__ */ React.createElement("i", {
      className: "".concat(classPrefix2, "-custom-icon"),
      onClick: function(e2) {
        setVisible(false);
        onClose && onClose(e2);
      }
    }, closeIcon) : /* @__PURE__ */ React.createElement(n$6, {
      width: 8,
      height: 8,
      onClick: function(e2) {
        setVisible(false);
        onClose && onClose(e2);
      }
    })) : /* @__PURE__ */ React.createElement("div", {
      className: classes,
      style: _object_spread({}, style, getStyle()),
      onClick: function(e2) {
        return handleClick(e2);
      }
    }, children && /* @__PURE__ */ React.createElement("span", {
      className: textClasses,
      style: getTextStyle()
    }, children)));
  };
  Tag.displayName = "NutTag";
  var defaultProps$8 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    type: "step",
    location: "bottom",
    mask: true,
    maskWidth: "",
    maskHeight: "",
    offset: [
      8,
      10
    ],
    title: "",
    next: "",
    prev: "",
    complete: "",
    showPrev: true,
    closeOnOverlayClick: true
  });
  var classPrefix$2 = "nut-tour";
  var Tour = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$8, props), children = _ref.children, className = _ref.className, title = _ref.title, closeOnOverlayClick = _ref.closeOnOverlayClick, showPrev = _ref.showPrev, list = _ref.list, type2 = _ref.type, location = _ref.location, visible = _ref.visible, mask2 = _ref.mask, maskWidth = _ref.maskWidth, maskHeight = _ref.maskHeight, offset = _ref.offset, next = _ref.next, prev = _ref.prev, complete = _ref.complete, onClose = _ref.onClose, onChange = _ref.onChange, rest = _object_without_properties(_ref, [
      "children",
      "className",
      "title",
      "closeOnOverlayClick",
      "showPrev",
      "list",
      "type",
      "location",
      "visible",
      "mask",
      "maskWidth",
      "maskHeight",
      "offset",
      "next",
      "prev",
      "complete",
      "onClose",
      "onChange"
    ]);
    var _useState = _sliced_to_array(React.useState(false), 2), showTour = _useState[0], setShowTour = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(false), 2), showPopup = _useState1[0], setShowPopup = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(0), 2), active2 = _useState2[0], setActive = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState({
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    }), 2), maskRect = _useState3[0], setMaskRect = _useState3[1];
    var classes = classNames(classPrefix$2, className);
    React.useEffect(function() {
      if (visible) {
        getRootPosition();
      }
      setActive(0);
      setShowTour(visible);
      setShowPopup(visible);
    }, [
      visible
    ]);
    React.useEffect(function() {
      if (visible) {
        setShowPopup(true);
        getRootPosition();
      }
    }, [
      active2
    ]);
    var getRootPosition = function() {
      var el = document.querySelector("#".concat(list[active2].target));
      var rect = getRect(el);
      setMaskRect(rect);
    };
    var maskStyle = function() {
      var width2 = maskRect.width, height2 = maskRect.height, left = maskRect.left, top = maskRect.top;
      var center = [
        left + width2 / 2,
        top + height2 / 2
      ];
      var w = Number(maskWidth || width2);
      var h = Number(maskHeight || height2);
      var styles = {
        width: "".concat(w + +offset[1] * 2, "px"),
        height: "".concat(h + +offset[0] * 2, "px"),
        top: "".concat(center[1] - h / 2 - +offset[0], "px"),
        left: "".concat(center[0] - w / 2 - +offset[1], "px")
      };
      return styles;
    };
    var maskClose = function(e2) {
      setShowTour(false);
      setShowPopup(false);
      onClose && onClose(e2);
    };
    var handleClickMask = function(e2) {
      closeOnOverlayClick && maskClose(e2);
    };
    var changeStep = function(type3) {
      if (type3 === "next") {
        setActive(active2 + 1);
        onChange && onChange(active2 + 1);
      } else {
        setActive(active2 - 1);
        onChange && onChange(active2 - 1);
      }
      setShowPopup(false);
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "nut-tour-masked",
      style: {
        display: showTour ? "block" : "none"
      },
      onClick: handleClickMask
    }), list.map(function(item, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: index2,
        style: {
          height: 0
        }
      }, index2 === active2 && /* @__PURE__ */ React.createElement(React.Fragment, null, showTour && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(mask2 ? "nut-tour-mask" : "nut-tour-mask nut-tour-mask-none"),
        id: "nut-tour-popid",
        style: maskStyle()
      }), /* @__PURE__ */ React.createElement(Popover, {
        visible: showPopup,
        location: item.location || location,
        targetId: "nut-tour-popid",
        closeOnOutsideClick: false,
        offset: item.popoverOffset || [
          0,
          12
        ],
        arrowOffset: item.arrowOffset || 0
      }, /* @__PURE__ */ React.createElement(React.Fragment, null), /* @__PURE__ */ React.createElement(React.Fragment, null, children || /* @__PURE__ */ React.createElement(React.Fragment, null, type2 === "step" && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content"
      }, title && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-top"
      }, /* @__PURE__ */ React.createElement("div", {
        onClick: function(e2) {
          return maskClose(e2);
        }
      }, /* @__PURE__ */ React.createElement(n$6, {
        className: "nut-tour-content-top-close"
      }))), /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-inner"
      }, item.content), /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom-init"
      }, active2 + 1, "/", list.length), /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom-operate"
      }, active2 !== 0 && showPrev && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom-operate-btn",
        onClick: function() {
          return changeStep("prev");
        }
      }, prev || locale.tour.prevStepText), list.length - 1 === active2 && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom-operate-btn active",
        onClick: function(e2) {
          return maskClose(e2);
        }
      }, complete || locale.tour.completeText), list.length - 1 !== active2 && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-bottom-operate-btn active",
        onClick: function() {
          return changeStep("next");
        }
      }, next || locale.tour.nextStepText)))), type2 === "tile" && /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content nut-tour-content-tile"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "nut-tour-content-inner"
      }, item.content)))))));
    }));
  };
  Tour.displayName = "NutTour";
  var initPositinoCache = function(reaItemSize) {
    var length2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var index2 = 0;
    var positions = Array(length2);
    while (index2 < length2) {
      positions[index2] = {
        index: index2,
        height: reaItemSize,
        width: reaItemSize,
        top: index2 * reaItemSize,
        bottom: (index2 + 1) * reaItemSize,
        left: index2 * reaItemSize,
        right: (index2 + 1) * reaItemSize
      };
      index2++;
    }
    return positions;
  };
  var getListTotalSize = function(positions, horizontal) {
    var index2 = positions.length - 1;
    var size = 0;
    if (index2 < 0) {
      size = 0;
    } else {
      size = horizontal ? positions[index2].right : positions[index2].bottom;
    }
    return size;
  };
  var binarySearch = function(positionsList, horizontal) {
    var value2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var start2 = 0;
    var end = positionsList.length - 1;
    var tempIndex = null;
    var key2 = horizontal ? "right" : "bottom";
    while (start2 <= end) {
      var midIndex = Math.floor((start2 + end) / 2);
      var midValue = positionsList[midIndex][key2];
      if (midValue === value2) {
        return midIndex + 1;
      }
      if (midValue < value2) {
        start2 = midIndex + 1;
      } else if (midValue > value2) {
        if (tempIndex === null || tempIndex > midIndex) {
          tempIndex = midIndex;
        }
        end = midIndex - 1;
      }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
  };
  var getEndIndex = function(param) {
    var list = param.list, startIndex = param.startIndex, visibleCount = param.visibleCount, _param_itemEqual = param.itemEqual, itemEqual = _param_itemEqual === void 0 ? true : _param_itemEqual, positions = param.positions, offSetSize = param.offSetSize, overscan = param.overscan, _param_sizeKey = param.sizeKey, sizeKey = _param_sizeKey === void 0 ? "width" : _param_sizeKey;
    var dataLength = list.length;
    var tempIndex = null;
    if (itemEqual) {
      var endIndex = startIndex + visibleCount;
      tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex) : endIndex;
    } else {
      var sizeNum = 0;
      for (var i2 = startIndex; i2 < dataLength; i2++) {
        sizeNum += positions[i2][sizeKey] || 0;
        if (sizeNum > offSetSize) {
          var endIndex1 = i2 + overscan;
          tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex1) : endIndex1;
          break;
        }
      }
      if (sizeNum < offSetSize) {
        tempIndex = dataLength;
      }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
  };
  var updateItemSize = function(positions, items, sizeKey, margin) {
    var newPos = positions.concat();
    Array.from(items).forEach(function(item) {
      var index2 = Number(item.getAttribute("data-index"));
      var styleVal = item.getAttribute("style");
      if (styleVal && styleVal.includes("none")) return;
      var nowSize = item.getBoundingClientRect()[sizeKey];
      var oldSize = positions[index2][sizeKey];
      var dValue = oldSize - nowSize;
      if (dValue) {
        if (sizeKey === "width") {
          newPos[index2].right -= dValue;
          newPos[index2][sizeKey] = nowSize;
          for (var k = index2 + 1; k < positions.length; k++) {
            newPos[k].left = positions[k - 1].right;
            newPos[k].right -= dValue;
          }
        } else if (sizeKey === "height") {
          newPos[index2].bottom -= dValue;
          newPos[index2][sizeKey] = nowSize;
          for (var k1 = index2 + 1; k1 < positions.length; k1++) {
            newPos[k1].top = positions[k1 - 1].bottom;
            newPos[k1].bottom -= dValue;
          }
        }
      }
    });
  };
  var defaultProps$7 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    list: [],
    itemHeight: 66,
    itemEqual: true,
    direction: "vertical",
    overscan: 2
  });
  var VirtualList = function(props) {
    var _ref = _object_spread({}, defaultProps$7, props), list = _ref.list, itemRender = _ref.itemRender, itemEqual = _ref.itemEqual, itemHeight = _ref.itemHeight, direction = _ref.direction, overscan = _ref.overscan, key2 = _ref.key, onScroll = _ref.onScroll, className = _ref.className, containerHeight = _ref.containerHeight, rest = _object_without_properties(_ref, [
      "list",
      "itemRender",
      "itemEqual",
      "itemHeight",
      "direction",
      "overscan",
      "key",
      "onScroll",
      "className",
      "containerHeight"
    ]);
    var horizontal = direction === "horizontal";
    var sizeKey = horizontal ? "width" : "height";
    var scrollKey = horizontal ? "scrollLeft" : "scrollTop";
    var offsetKey = horizontal ? "left" : "top";
    var scrollRef = React.useRef(null);
    var itemsRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState([
      {
        index: 0,
        left: 0,
        top: 0,
        bottom: 0,
        width: 0,
        height: 0,
        right: 0
      }
    ]), 2), positions = _useState[0], setPositions = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(99999999), 2), listTotalSize = _useState1[0], setListTotalSize = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(0), 2), visibleCount = _useState2[0], setVisibleCount = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState(containerHeight || 0), 2), offSetSize = _useState3[0], setOffSetSize = _useState3[1];
    var _useState4 = _sliced_to_array(React.useState({
      startOffset: 0,
      startIndex: 0,
      overStart: 0,
      endIndex: 10
    }), 2), options2 = _useState4[0], setOptions = _useState4[1];
    React.useEffect(function() {
      var pos = initPositinoCache(itemHeight, list.length);
      setPositions(pos);
      var totalSize = getListTotalSize(pos, horizontal);
      setListTotalSize(totalSize);
    }, [
      list,
      itemHeight,
      horizontal
    ]);
    var getElement = React.useCallback(function() {
      var _scrollRef_current;
      return ((_scrollRef_current = scrollRef.current) === null || _scrollRef_current === void 0 ? void 0 : _scrollRef_current.parentElement) || document.body;
    }, []);
    React.useEffect(function() {
      if (containerHeight) return;
      var size = horizontal ? getElement().offsetWidth : getElement().offsetHeight;
      setOffSetSize(size);
    }, [
      getElement,
      horizontal,
      containerHeight
    ]);
    React.useEffect(function() {
      if (offSetSize === 0) return;
      var count = Math.ceil(offSetSize / itemHeight) + overscan;
      setVisibleCount(count);
      setOptions(function(options3) {
        return _object_spread_props(_object_spread({}, options3), {
          endIndex: count
        });
      });
    }, [
      getElement,
      horizontal,
      itemHeight,
      overscan,
      offSetSize
    ]);
    var updateTotalSize = React.useCallback(function() {
      if (!itemsRef.current) return;
      var items = itemsRef.current.children;
      if (!items.length) return;
      updateItemSize(positions, items, sizeKey);
      var totalSize = getListTotalSize(positions, horizontal);
      setListTotalSize(totalSize);
    }, [
      positions,
      sizeKey,
      horizontal
    ]);
    var scroll = React.useCallback(function() {
      requestAnimationFrame(function(e2) {
        var scrollSize = getElement()[scrollKey];
        var startIndex = binarySearch(positions, horizontal, scrollSize);
        var overStart = startIndex - overscan > -1 ? startIndex - overscan : 0;
        if (!itemEqual) {
          updateTotalSize();
        }
        var endIndex = getEndIndex({
          list,
          startIndex,
          visibleCount,
          itemEqual,
          positions,
          offSetSize,
          sizeKey,
          overscan
        });
        var startOffset = positions[startIndex][offsetKey];
        setOptions({
          startOffset,
          startIndex,
          overStart,
          endIndex
        });
        if (endIndex > list.length - 1) {
          if (onScroll) {
            onScroll();
          }
        }
      });
    }, [
      positions,
      getElement,
      list,
      visibleCount,
      itemEqual,
      updateTotalSize,
      offsetKey,
      sizeKey,
      scrollKey,
      horizontal,
      overscan,
      offSetSize
    ]);
    React.useEffect(function() {
      var element = getElement();
      element.addEventListener("scroll", scroll, false);
      return function() {
        element.removeEventListener("scroll", scroll, false);
      };
    }, [
      getElement,
      scroll
    ]);
    return /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: classNames("nut-virtualList-box", className)
    }, rest), {
      style: _define_property({}, sizeKey, containerHeight ? "".concat(offSetSize, "px") : "")
    }), /* @__PURE__ */ React.createElement("div", {
      ref: scrollRef,
      className: classNames({
        "nut-horizontal-box": horizontal,
        "nut-vertical-box": !horizontal
      }),
      style: _define_property({
        position: "relative"
      }, sizeKey, "".concat(listTotalSize, "px"))
    }, /* @__PURE__ */ React.createElement("ul", {
      className: classNames("nut-virtuallist-items", {
        "nut-horizontal-items": horizontal,
        "nut-vertical-items": !horizontal
      }),
      ref: itemsRef,
      style: {
        transform: horizontal ? "translate3d(".concat(options2.startOffset, "px,0,0)") : "translate3d(0,".concat(options2.startOffset, "px,0)")
      }
    }, list.slice(options2.overStart, options2.endIndex).map(function(data2, index2) {
      var startIndex = options2.startIndex, overStart = options2.overStart;
      var dataIndex = overStart + index2;
      var styleVal = dataIndex < startIndex ? "none" : "block";
      var keyVal = key2 && data2[key2] ? data2[key2] : dataIndex;
      return /* @__PURE__ */ React.createElement("li", {
        "data-index": "".concat(dataIndex),
        className: "nut-virtuallist-item",
        key: "".concat(keyVal),
        style: {
          display: styleVal
        }
      }, itemRender ? itemRender(data2, dataIndex, index2) : data2);
    }))));
  };
  VirtualList.displayName = "NutVirtualList";
  var defaultProps$6 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    maxZoom: 3,
    space: 10,
    toolbar: [
      /* @__PURE__ */ React.createElement(Button, {
        type: "danger",
        key: "cancel"
      }, "Cancel"),
      /* @__PURE__ */ React.createElement(Button, {
        key: "reset"
      }, "Reset"),
      /* @__PURE__ */ React.createElement(Button, {
        key: "rotate"
      }, "Rotate"),
      /* @__PURE__ */ React.createElement(Button, {
        type: "success",
        key: "confirm"
      }, "Confirm")
    ],
    toolbarPosition: "bottom",
    editText: "Edit",
    shape: "square"
  });
  var classPrefix$1 = "nut-avatar-cropper";
  var AvatarCropper = function(props) {
    var locale = useConfig().locale;
    defaultProps$6.toolbar = [
      /* @__PURE__ */ React.createElement(Button, {
        type: "danger",
        key: "cancel"
      }, locale.cancel),
      /* @__PURE__ */ React.createElement(Button, {
        key: "reset"
      }, locale.reset),
      /* @__PURE__ */ React.createElement(Button, {
        key: "rotate"
      }, locale.avatarCropper.rotate),
      /* @__PURE__ */ React.createElement(Button, {
        type: "success",
        key: "confirm"
      }, locale.confirm)
    ];
    var _ref = _object_spread({}, defaultProps$6, props), children = _ref.children, maxZoom = _ref.maxZoom, space = _ref.space, toolbar = _ref.toolbar, toolbarPosition = _ref.toolbarPosition, editText = _ref.editText, shape = _ref.shape, className = _ref.className, style = _ref.style, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, rest = _object_without_properties(_ref, [
      "children",
      "maxZoom",
      "space",
      "toolbar",
      "toolbarPosition",
      "editText",
      "shape",
      "className",
      "style",
      "onConfirm",
      "onCancel"
    ]);
    var cls = classNames(classPrefix$1, className, shape === "round" && "round");
    var toolbarPositionCls = classNames("".concat(classPrefix$1, "-popup-toolbar"), toolbarPosition);
    var inputImageRef = React.useRef(null);
    var cropperPopupRef = React.useRef(null);
    var canvasRef = React.useRef(null);
    var _useState = _sliced_to_array(React.useState(false), 2), visible = _useState[0], setVisible = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(false), 2), moving = _useState1[0], setMoving = _useState1[1];
    var _useState2 = _sliced_to_array(React.useState(false), 2), zooming = _useState2[0], setZooming = _useState2[1];
    var _useState3 = _sliced_to_array(React.useState({
      defScale: 1,
      scale: 1,
      angle: 0,
      moveX: 0,
      moveY: 0,
      displayWidth: 0,
      displayHeight: 0
    }), 2), state = _useState3[0], setState = _useState3[1];
    var defDrawImage = {
      img: new Image(),
      sx: 0,
      sy: 0,
      swidth: 0,
      sheight: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var _useState4 = _sliced_to_array(React.useState(_object_spread({}, defDrawImage)), 2), drawImage = _useState4[0], setDrawImg = _useState4[1];
    var devicePixelRatio = window.devicePixelRatio || 1;
    var touch = useTouch();
    var highlightStyle = React.useMemo(function() {
      var width2 = "".concat(drawImage.swidth / devicePixelRatio, "px");
      var height2 = width2;
      return {
        width: width2,
        height: height2,
        borderRadius: shape === "round" ? "50%" : ""
      };
    }, [
      devicePixelRatio,
      drawImage.swidth
    ]);
    var isAngle = React.useMemo(function() {
      return state.angle === 90 || state.angle === 270;
    }, [
      state.angle
    ]);
    var maxMoveX = React.useMemo(function() {
      var swidth = drawImage.swidth, height2 = drawImage.height;
      if (isAngle) {
        return Math.max(0, (height2 * state.scale - swidth) / 2);
      }
      return Math.max(0, (state.displayWidth * state.scale - swidth) / 2);
    }, [
      state.scale,
      state.displayWidth,
      drawImage,
      isAngle
    ]);
    var maxMoveY = React.useMemo(function() {
      var swidth = drawImage.swidth, height2 = drawImage.height;
      if (isAngle) {
        return Math.max(0, (state.displayWidth * state.scale - swidth) / 2);
      }
      return Math.max(0, (height2 * state.scale - swidth) / 2);
    }, [
      state.scale,
      state.displayWidth,
      drawImage,
      isAngle
    ]);
    var fileToDataURL = function(file) {
      return new Promise(function(resolve) {
        var reader = new FileReader();
        reader.onloadend = function(e2) {
          return resolve(e2.target.result);
        };
        reader.readAsDataURL(file);
      });
    };
    var dataURLToImage = function(dataURL) {
      return new Promise(function(resolve) {
        var img = new Image();
        img.onload = function() {
          return resolve(img);
        };
        img.src = dataURL;
      });
    };
    var draw = React.useCallback(function() {
      var img = drawImage.img, width2 = drawImage.width, height2 = drawImage.height, x = drawImage.x, y = drawImage.y, swidth = drawImage.swidth;
      var moveX = state.moveX, moveY = state.moveY, scale2 = state.scale, angle = state.angle, displayWidth = state.displayWidth, displayHeight = state.displayHeight;
      var canvas = canvasRef.current;
      if (!canvas) return;
      var ctx2 = canvas.getContext("2d");
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      ctx2.clearRect(0, 0, canvas.width, canvas.height);
      ctx2.fillStyle = "#666";
      ctx2.fillRect(0, 0, canvas.width, canvas.height);
      ctx2.fillStyle = "#000";
      ctx2.fillRect(space * devicePixelRatio, (canvas.height - swidth) / 2, swidth, swidth);
      ctx2.translate(canvas.width / 2 + moveX, canvas.height / 2 + moveY);
      ctx2.rotate(Math.PI / 180 * angle);
      ctx2.scale(scale2, scale2);
      ctx2.drawImage(img, x, y, width2, height2);
    }, [
      drawImage,
      state,
      devicePixelRatio,
      space
    ]);
    React.useEffect(function() {
      if (Math.abs(state.moveX) > maxMoveX) {
        setState(_object_spread_props(_object_spread({}, state), {
          moveX: maxMoveX
        }));
      }
      if (Math.abs(state.moveY) > maxMoveY) {
        setState(_object_spread_props(_object_spread({}, state), {
          moveY: maxMoveY
        }));
      }
      draw();
    }, [
      state,
      maxMoveX,
      maxMoveY,
      draw
    ]);
    var setDrawImgs = function(image) {
      var rect = getRect(cropperPopupRef.current);
      if (!rect) return;
      var clientWidth = rect.width, clientHeight = rect.height;
      var canvasWidth = state.displayWidth = clientWidth * devicePixelRatio;
      var canvasHeight = state.displayHeight = clientHeight * devicePixelRatio;
      var copyDrawImg = _object_spread({}, defDrawImage);
      var imgWidth = image.width, imgHeight = image.height;
      copyDrawImg.img = image;
      var isPortrait = imgHeight > imgWidth;
      var rate = isPortrait ? imgWidth / imgHeight : imgHeight / imgWidth;
      copyDrawImg.width = canvasWidth;
      copyDrawImg.height = isPortrait ? canvasWidth / rate : canvasWidth * rate;
      copyDrawImg.x = -copyDrawImg.width / 2;
      copyDrawImg.y = -copyDrawImg.height / 2;
      copyDrawImg.swidth = canvasWidth - space * 2 * devicePixelRatio;
      copyDrawImg.sheight = isPortrait ? copyDrawImg.swidth / rate : copyDrawImg.swidth * rate;
      copyDrawImg.sx = space * devicePixelRatio;
      copyDrawImg.sy = (canvasHeight - copyDrawImg.swidth) / 2;
      setDrawImg(copyDrawImg);
      var scale2 = copyDrawImg.swidth / (isPortrait ? copyDrawImg.width : copyDrawImg.height);
      setState(_object_spread_props(_object_spread({}, state), {
        defScale: scale2
      }));
      resetScale(scale2);
    };
    var inputImageChange = /* @__PURE__ */ function() {
      var _ref2 = _async_to_generator(function(event) {
        var $el, files, base64, image;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              setVisible(true);
              $el = event.target;
              files = $el.files;
              if (!(files === null || files === void 0 ? void 0 : files.length)) return [
                2
              ];
              return [
                4,
                fileToDataURL(files[0])
              ];
            case 1:
              base64 = _state.sent();
              return [
                4,
                dataURLToImage(base64)
              ];
            case 2:
              image = _state.sent();
              setDrawImgs(image);
              return [
                2
              ];
          }
        });
      });
      return function inputImageChange2(event) {
        return _ref2.apply(this, arguments);
      };
    }();
    var resetScale = function(scale2) {
      setState(_object_spread_props(_object_spread({}, state), {
        moveX: 0,
        moveY: 0,
        angle: 0,
        scale: scale2 || state.defScale,
        defScale: scale2 || state.defScale
      }));
    };
    var setScale = function(scale2) {
      scale2 = clamp$2(scale2, 0.3, +maxZoom + 1);
      if (scale2 !== state.scale) {
        setState(_object_spread_props(_object_spread({}, state), {
          scale: scale2
        }));
      }
    };
    var getDistance = function(touches) {
      return Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));
    };
    var _useState5 = _sliced_to_array(React.useState({
      startMoveX: 0,
      startMoveY: 0,
      startScale: 0,
      startDistance: 0
    }), 2), startMove = _useState5[0], setStartMove = _useState5[1];
    var startMoveX = startMove.startMoveX, startMoveY = startMove.startMoveY, startScale = startMove.startScale, startDistance = startMove.startDistance;
    var onTouchStart = function(event) {
      var touches = event.touches;
      var offsetX = touch.offsetX;
      touch.start(event);
      var fingerNum = touches === null || touches === void 0 ? void 0 : touches.length;
      setStartMove(_object_spread_props(_object_spread({}, startMove), {
        startMoveX: state.moveX,
        startMoveY: state.moveY
      }));
      setMoving(fingerNum === 1);
      setZooming(fingerNum === 2 && !offsetX.current);
      if (fingerNum === 2 && !offsetX.current) {
        setStartMove(_object_spread_props(_object_spread({}, startMove), {
          startScale: state.scale,
          startDistance: getDistance(event.touches)
        }));
      }
    };
    var onTouchMove = function(event) {
      var touches = event.touches;
      touch.move(event);
      if (moving || zooming) {
        preventDefault$1(event, true);
      }
      if (moving) {
        var deltaX = touch.deltaX, deltaY = touch.deltaY;
        var moveX = deltaX.current * state.scale + startMoveX;
        var moveY = deltaY.current * state.scale + startMoveY;
        setState(_object_spread_props(_object_spread({}, state), {
          moveX: clamp$2(moveX, -maxMoveX, maxMoveX),
          moveY: clamp$2(moveY, -maxMoveY, maxMoveY)
        }));
      }
      if (zooming && touches.length === 2) {
        var distance = getDistance(touches);
        var scale2 = startScale * distance / startDistance;
        setScale(scale2);
      }
    };
    var onTouchEnd = function(event) {
      var stopPropagation = false;
      if (moving || zooming) {
        stopPropagation = !(moving && startMoveX === state.moveX && startMoveY === state.moveY);
        if (!event.touches.length) {
          if (zooming) {
            setState(_object_spread_props(_object_spread({}, state), {
              moveX: clamp$2(state.moveX, -maxMoveX, maxMoveX),
              moveY: clamp$2(state.moveY, -maxMoveY, maxMoveY)
            }));
            setZooming(false);
          }
          setMoving(false);
          setStartMove(_object_spread_props(_object_spread({}, startMove), {
            startMoveX: 0,
            startMoveY: 0,
            startScale: state.defScale
          }));
          if (state.scale < state.defScale) {
            resetScale();
          }
          if (state.scale > maxZoom) {
            setState(_object_spread_props(_object_spread({}, state), {
              scale: +maxZoom
            }));
          }
        }
      }
      preventDefault$1(event, stopPropagation);
      touch.reset();
    };
    var reset = function() {
      setState(_object_spread_props(_object_spread({}, state), {
        angle: 0
      }));
    };
    var rotate = function() {
      if (state.angle === 270) {
        setState(_object_spread_props(_object_spread({}, state), {
          angle: 0
        }));
        return;
      }
      setState(_object_spread_props(_object_spread({}, state), {
        angle: state.angle + 90
      }));
    };
    var cancel = function() {
      var isEmit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      setVisible(false);
      resetScale();
      inputImageRef.current && (inputImageRef.current.value = "");
      isEmit && onCancel && onCancel();
    };
    var confirm2 = function() {
      var canvas = canvasRef.current;
      var sx = drawImage.sx, sy = drawImage.sy, swidth = drawImage.swidth;
      var width2 = swidth;
      var height2 = swidth;
      var croppedCanvas = document.createElement("canvas");
      var croppedCtx = croppedCanvas.getContext("2d");
      croppedCanvas.width = width2;
      croppedCanvas.height = height2;
      canvas && croppedCtx.drawImage(canvas, sx, sy, width2, height2, 0, 0, width2, height2);
      var imageDataURL = croppedCanvas.toDataURL("image/png");
      onConfirm && onConfirm(imageDataURL);
      cancel(false);
    };
    var ToolBar = function() {
      var actions = [
        cancel,
        reset,
        rotate,
        confirm2
      ];
      return /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$1, "-popup-toolbar-flex")
      }, actions.map(function(action, index2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: index2,
          className: "".concat(classPrefix$1, "-popup-toolbar-item"),
          onClick: function(_e) {
            return action();
          }
        }, toolbar[index2]);
      }));
    };
    var CropperPopup = function() {
      return /* @__PURE__ */ React.createElement("div", {
        ref: cropperPopupRef,
        className: "".concat(classPrefix$1, "-popup"),
        style: {
          display: visible ? "block" : "none"
        }
      }, /* @__PURE__ */ React.createElement("canvas", {
        ref: canvasRef,
        className: "".concat(classPrefix$1, "-popup-canvas")
      }), /* @__PURE__ */ React.createElement("div", {
        className: "".concat(classPrefix$1, "-popup-highlight"),
        onTouchStart,
        onTouchMove,
        onTouchEnd
      }, /* @__PURE__ */ React.createElement("div", {
        className: "highlight",
        style: highlightStyle
      })), /* @__PURE__ */ React.createElement("div", {
        className: toolbarPositionCls
      }, /* @__PURE__ */ React.createElement(ToolBar, null)));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", _object_spread_props(_object_spread({
      className: cls
    }, rest), {
      style
    }), children, /* @__PURE__ */ React.createElement("input", {
      ref: inputImageRef,
      type: "file",
      accept: "image/*",
      className: "".concat(classPrefix$1, "-input"),
      onChange: function(e2) {
        return inputImageChange(e2);
      },
      "aria-label": locale.avatarCropper.selectImage
    }), /* @__PURE__ */ React.createElement("div", {
      className: "nut-avatar-cropper-edit-text"
    }, editText)), CropperPopup());
  };
  AvatarCropper.displayName = "NutAvatarCropper";
  var defaultProps$5 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    list: [],
    interval: 500,
    loop: true,
    duration: 3e3,
    rows: 3,
    gapY: 10
  });
  var classPrefix = "nut-barrage";
  var InternalBarrage = function(props, ref) {
    var _ref = _object_spread({}, defaultProps$5, props), className = _ref.className, interval = _ref.interval, loop2 = _ref.loop, list = _ref.list, duration = _ref.duration, rows = _ref.rows, gapY = _ref.gapY, restProps = _object_without_properties(_ref, [
      "className",
      "interval",
      "loop",
      "list",
      "duration",
      "rows",
      "gapY"
    ]);
    var barrageBody = React.useRef(null);
    var barrageContainer = React.useRef(null);
    var barrageCWidth = React.useRef(0);
    var timer = React.useRef(0);
    var index2 = React.useRef(0);
    var times = React.useRef([]);
    var historyIndex = React.useRef(-1);
    var classes = classNames(classPrefix, className);
    React.useImperativeHandle(ref, function() {
      return {
        add: function(word) {
          var _index = index2.current % list.length;
          if (!loop2 && index2.current === list.length) {
            list.splice(list.length, 0, word);
          } else {
            list.splice(_index, 0, word);
          }
        }
      };
    });
    React.useEffect(function() {
      if (barrageBody.current) {
        barrageCWidth.current = barrageBody.current.offsetWidth;
      }
      setTimeout(function() {
        var _barrageBody_current;
        (_barrageBody_current = barrageBody.current) === null || _barrageBody_current === void 0 ? void 0 : _barrageBody_current.style.setProperty("--move-distance", "-".concat(barrageCWidth.current, "px"));
        index2.current = 0;
        run();
      }, 300);
      return function() {
        clearInterval(timer.current);
      };
    }, [
      list
    ]);
    var run = function() {
      clearInterval(timer.current);
      var intervalCache = interval;
      var _index = (loop2 ? index2.current % list.length : index2.current) % rows;
      var result = times.current[_index] - rows * interval;
      if (result > 0) {
        intervalCache += result;
      }
      timer.current = window.setTimeout(function() {
        play();
      }, intervalCache);
    };
    var play = function() {
      if (!loop2 && index2.current >= list.length) {
        return;
      }
      var _index = loop2 ? index2.current % list.length : index2.current;
      var el = document.createElement("div");
      var currentIndex = _index % rows;
      if (currentIndex <= historyIndex.current || historyIndex.current === 3 && currentIndex !== 0 || Math.abs(currentIndex - historyIndex.current) !== 1) {
        currentIndex = historyIndex.current + 1 >= rows ? 0 : historyIndex.current + 1;
      }
      historyIndex.current = currentIndex;
      el.innerHTML = list[_index];
      el.classList.add("barrage-item");
      barrageContainer.current.appendChild(el);
      var width2 = el.offsetWidth;
      var height2 = el.offsetHeight;
      el.classList.add("move");
      var elScrollDuration = Math.ceil(width2 / barrageCWidth.current * duration);
      times.current[currentIndex] = elScrollDuration;
      el.style.animationDuration = "".concat(duration + elScrollDuration, "ms");
      el.style.top = "".concat(currentIndex * (height2 + gapY) + 20, "px");
      el.style.width = "".concat(width2, "px");
      el.addEventListener("animationend", function() {
        barrageContainer.current.removeChild(el);
      });
      index2.current++;
      run();
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classes,
      ref: barrageBody
    }, restProps), /* @__PURE__ */ React.createElement("div", {
      ref: barrageContainer,
      className: "bContainer"
    }));
  };
  var Barrage = /* @__PURE__ */ React.forwardRef(InternalBarrage);
  Barrage.displayName = "NutBarrage";
  var defaultProps$4 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    src: "",
    title: "",
    price: "",
    vipPrice: "",
    shopDescription: "",
    delivery: "",
    shopName: "",
    description: "",
    tag: "",
    priceTag: "",
    extra: ""
  });
  var Card = function(props) {
    var _ref = _object_spread({}, defaultProps$4, props), className = _ref.className, style = _ref.style, src = _ref.src, title = _ref.title, price = _ref.price, vipPrice = _ref.vipPrice, shopDescription = _ref.shopDescription, delivery = _ref.delivery, shopName = _ref.shopName, tag = _ref.tag, priceTag = _ref.priceTag, description = _ref.description, extra = _ref.extra, rest = _object_without_properties(_ref, [
      "className",
      "style",
      "src",
      "title",
      "price",
      "vipPrice",
      "shopDescription",
      "delivery",
      "shopName",
      "tag",
      "priceTag",
      "description",
      "extra"
    ]);
    var classPrefix2 = "nut-card";
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: classNames(classPrefix2, className),
      style
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-left")
    }, /* @__PURE__ */ React.createElement("img", {
      src,
      alt: ""
    })), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right-title")
    }, title), description, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right-price")
    }, price && /* @__PURE__ */ React.createElement(Price, {
      size: "normal",
      price
    }), priceTag || vipPrice && /* @__PURE__ */ React.createElement(Price, {
      size: "normal",
      className: "".concat(classPrefix2, "-right-price-origin"),
      price: vipPrice
    })), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right-other")
    }, tag || /* @__PURE__ */ React.createElement(React.Fragment, null, shopDescription && /* @__PURE__ */ React.createElement(Tag, {
      type: "danger"
    }, shopDescription), delivery && /* @__PURE__ */ React.createElement(Tag, {
      plain: true
    }, delivery))), /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right-shop")
    }, shopName && /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-right-shop-name")
    }, shopName), extra)));
  };
  Card.displayName = "NutCard";
  var defaultProps$3 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    activeDate: "",
    activeTime: [],
    options: [],
    optionKey: {
      valueKey: "value",
      textKey: "text",
      childrenKey: "children"
    },
    onSelect: function() {
    }
  });
  var TimeDetail = function(props) {
    var _$_object_spread = _object_spread({}, defaultProps$3, props), options2 = _$_object_spread.options, optionKey = _$_object_spread.optionKey, className = _$_object_spread.className, activeDate = _$_object_spread.activeDate, activeTime = _$_object_spread.activeTime, onSelect = _$_object_spread.onSelect;
    var classPrefix2 = "nut-timedetail";
    var timeList = React.useMemo(function() {
      return (options2 === null || options2 === void 0 ? void 0 : options2.find(function(item) {
        return item[optionKey.valueKey] === activeDate;
      })) || _define_property({}, optionKey.childrenKey, []);
    }, [
      options2,
      optionKey,
      activeDate
    ]);
    var isActive = React.useCallback(function(timeKey) {
      var date2 = activeTime.find(function(item) {
        return item[optionKey.valueKey] === activeDate;
      });
      if (date2 === null || date2 === void 0 ? void 0 : date2[optionKey.childrenKey]) {
        var time2 = date2 === null || date2 === void 0 ? void 0 : date2[optionKey.childrenKey].find(function(time3) {
          return time3[optionKey.valueKey] === timeKey;
        });
        return time2;
      }
      return false;
    }, [
      activeTime,
      optionKey,
      activeDate
    ]);
    return /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className)
    }, timeList[optionKey.childrenKey].map(function(item) {
      return /* @__PURE__ */ React.createElement("span", {
        className: classNames("".concat(classPrefix2, "-item"), {
          active: isActive(item[optionKey.valueKey])
        }),
        key: item[optionKey.valueKey],
        onClick: function() {
          return onSelect(item);
        }
      }, item[optionKey.textKey]);
    }));
  };
  TimeDetail.displayName = "NutTimeDetail";
  var defaultProps$2 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    visible: false,
    multiple: false,
    defaultValue: [],
    options: [],
    optionKey: {
      valueKey: "value",
      textKey: "text",
      childrenKey: "children"
    }
  });
  var TimeSelect = function(props) {
    var locale = useConfig().locale;
    var _ref = _object_spread({}, defaultProps$2, props), visible = _ref.visible, className = _ref.className, style = _ref.style, title = _ref.title, defaultValue = _ref.defaultValue, options2 = _ref.options, optionKey = _ref.optionKey, multiple = _ref.multiple, onSelect = _ref.onSelect, onDateChange = _ref.onDateChange, onTimeChange = _ref.onTimeChange, rest = _object_without_properties(_ref, [
      "visible",
      "className",
      "style",
      "title",
      "defaultValue",
      "options",
      "optionKey",
      "multiple",
      "onSelect",
      "onDateChange",
      "onTimeChange"
    ]);
    var _useState = _sliced_to_array(React.useState(function() {
      if (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.length) {
        return defaultValue[0][optionKey.valueKey];
      }
      if (options2 === null || options2 === void 0 ? void 0 : options2.length) {
        return options2[0][optionKey.valueKey];
      }
      return "";
    }), 2), activeDate = _useState[0], setActiveDate = _useState[1];
    var _useState1 = _sliced_to_array(React.useState(function() {
      return defaultValue || [];
    }), 2), activeTime = _useState1[0], setActiveTime = _useState1[1];
    var classPrefix2 = "nut-timeselect";
    var closeFun = function() {
      onSelect && onSelect(activeTime);
    };
    var handleSelectTime = function(selectTime) {
      var newActiveTime = _to_consumable_array(activeTime);
      var date2 = newActiveTime.find(function(item) {
        return item[optionKey.valueKey] === activeDate;
      });
      if (date2) {
        var timeIndex = date2[optionKey.childrenKey].findIndex(function(time2) {
          return time2[optionKey.valueKey] === selectTime[optionKey.valueKey];
        });
        if (timeIndex > -1) {
          if (multiple) {
            date2[optionKey.childrenKey].splice(timeIndex, 1);
          } else {
            newActiveTime = [];
          }
        } else if (multiple) {
          date2[optionKey.childrenKey].push(_object_spread({}, selectTime));
        } else {
          var _obj;
          newActiveTime = [
            (_obj = {}, _define_property(_obj, optionKey.valueKey, activeDate), _define_property(_obj, optionKey.childrenKey, [
              _object_spread({}, selectTime)
            ]), _obj)
          ];
        }
      } else if (multiple) {
        var _obj1;
        newActiveTime.push((_obj1 = {}, _define_property(_obj1, optionKey.valueKey, activeDate), _define_property(_obj1, optionKey.childrenKey, [
          _object_spread({}, selectTime)
        ]), _obj1));
      } else {
        var _obj2;
        newActiveTime = [
          (_obj2 = {}, _define_property(_obj2, optionKey.valueKey, activeDate), _define_property(_obj2, optionKey.childrenKey, [
            _object_spread({}, selectTime)
          ]), _obj2)
        ];
      }
      newActiveTime = newActiveTime.filter(function(item) {
        var _item_optionKey_childrenKey;
        return ((_item_optionKey_childrenKey = item[optionKey.childrenKey]) === null || _item_optionKey_childrenKey === void 0 ? void 0 : _item_optionKey_childrenKey.length) > 0;
      });
      setActiveTime(newActiveTime);
      onTimeChange && onTimeChange(selectTime, newActiveTime);
    };
    var handleChange = function(date2) {
      setActiveDate(date2[optionKey.valueKey]);
      onDateChange && onDateChange(date2, activeTime);
    };
    return /* @__PURE__ */ React.createElement(Popup, _object_spread({
      closeable: true,
      round: true,
      visible,
      position: "bottom",
      title: title || locale.timeselect.pickupTime,
      style: _object_spread({}, style),
      onClose: closeFun
    }, rest), /* @__PURE__ */ React.createElement("div", {
      className: classNames(classPrefix2, className)
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-content")
    }, /* @__PURE__ */ React.createElement("div", {
      className: "".concat(classPrefix2, "-content-left")
    }, options2.map(function(item) {
      return /* @__PURE__ */ React.createElement("div", {
        key: item[optionKey.valueKey],
        className: classNames("nut-timepannel", {
          active: item[optionKey.valueKey] === activeDate
        }),
        onClick: function() {
          return handleChange(item);
        }
      }, item[optionKey.textKey]);
    })), /* @__PURE__ */ React.createElement(TimeDetail, {
      options: options2,
      optionKey,
      activeDate,
      activeTime,
      onSelect: handleSelectTime
    }))));
  };
  TimeSelect.displayName = "NutTimeSelect";
  var defaultProps$1 = _object_spread_props(_object_spread({}, ComponentDefaults), {
    value: 0,
    digits: 2,
    symbol: false,
    zero: false,
    left: false,
    sync: true,
    color: "",
    riseColor: "var(--nutui-brand-6)",
    dropColor: "var(--nutui-secondary-1)",
    riseIcon: null,
    dropIcon: null
  });
  var TrendArrow = function(props) {
    var _ref = _object_spread({}, defaultProps$1, props), value2 = _ref.value, digits = _ref.digits, symbol = _ref.symbol, zero = _ref.zero, left = _ref.left, sync2 = _ref.sync, color = _ref.color, riseColor = _ref.riseColor, dropColor = _ref.dropColor, riseIcon = _ref.riseIcon, dropIcon = _ref.dropIcon, className = _ref.className, style = _ref.style;
    _ref.children;
    var rest = _object_without_properties(_ref, [
      "value",
      "digits",
      "symbol",
      "zero",
      "left",
      "sync",
      "color",
      "riseColor",
      "dropColor",
      "riseIcon",
      "dropIcon",
      "className",
      "style",
      "children"
    ]);
    var classPrefix2 = "nut-trendarrow";
    var rateTrend = React.useRef(value2 > 0);
    var myFixed = function(num) {
      var digit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      if (Object.is(parseFloat(num), NaN)) {
        return console.warn("".concat(num, ""));
      }
      num = parseFloat(num);
      var numPow = Math.pow(10, digit);
      return (Math.round((num + Number.EPSILON) * numPow) / numPow).toFixed(digit);
    };
    var calcStyle = function() {
      var arrowColor = rateTrend.current ? riseColor : dropColor;
      var textEquArrowColor = sync2 ? arrowColor : color;
      var style2 = {
        color: value2 === 0 ? color : textEquArrowColor
      };
      return style2;
    }();
    var calcRate = function() {
      rateTrend.current = value2 > 0;
      var absRate = Math.abs(value2);
      if (!zero && value2 === 0) {
        return "--";
      }
      var resultRate = "".concat(
        // eslint-disable-next-line no-nested-ternary
        symbol && value2 !== 0 ? rateTrend.current ? "+" : "-" : ""
      ).concat(myFixed(Number(absRate), digits), "%");
      return resultRate;
    }();
    var calcIconProps = function() {
      var iconProps = {
        color: rateTrend.current ? riseColor : dropColor
      };
      return iconProps;
    }();
    var renderContent = function(left2) {
      var classNameSuffix = !left2 ? "icon-after" : "icon-before";
      return /* @__PURE__ */ React.createElement("span", {
        className: "".concat(classPrefix2, "-").concat(classNameSuffix, " ").concat(classPrefix2, "-value"),
        style: calcStyle
      }, calcRate);
    };
    return /* @__PURE__ */ React.createElement("div", _object_spread({
      className: "".concat(classPrefix2, " ").concat(className),
      style
    }, rest), !left && renderContent(!left), Number(value2) !== 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, rateTrend.current ? /* @__PURE__ */ React.createElement(React.Fragment, null, riseIcon || /* @__PURE__ */ React.createElement(p, {
      color: calcIconProps.color
    })) : /* @__PURE__ */ React.createElement(React.Fragment, null, dropIcon || /* @__PURE__ */ React.createElement(d, {
      color: calcIconProps.color
    }))), left && renderContent(!left));
  };
  TrendArrow.displayName = "NutTrendArrow";
  var defaultProps = _object_spread_props(_object_spread({}, ComponentDefaults), {
    content: "",
    fullPage: true,
    zIndex: 2e3,
    gapX: 24,
    gapY: 48,
    width: 120,
    height: 64,
    startX: 0,
    startY: 0,
    image: "",
    imageWidth: 120,
    imageHeight: 64,
    rotate: -22,
    color: "rgba(0,0,0,.15)",
    fontStyle: "normal",
    fontWeight: "normal",
    fontSize: 14
  });
  var WaterMark = function(props) {
    var locale = useConfig().locale;
    var _$_object_spread = _object_spread({}, defaultProps, props), content2 = _$_object_spread.content, fullPage = _$_object_spread.fullPage, zIndex = _$_object_spread.zIndex, className = _$_object_spread.className, gapX = _$_object_spread.gapX, gapY = _$_object_spread.gapY, startX = _$_object_spread.startX, startY = _$_object_spread.startY, width2 = _$_object_spread.width, height2 = _$_object_spread.height, image = _$_object_spread.image, imageWidth = _$_object_spread.imageWidth, imageHeight = _$_object_spread.imageHeight, rotate = _$_object_spread.rotate, color = _$_object_spread.color, fontStyle = _$_object_spread.fontStyle, fontFamily = _$_object_spread.fontFamily, fontWeight = _$_object_spread.fontWeight, fontSize = _$_object_spread.fontSize, style = _$_object_spread.style;
    var _useState = _sliced_to_array(React.useState(""), 2), base64Url = _useState[0], setBase64Url = _useState[1];
    var classPrefix2 = "nut-watermark";
    var classes = classNames(classPrefix2, _define_property({}, "".concat(classPrefix2, "-full-page"), fullPage));
    var cls = classNames(classes, className);
    React.useEffect(function() {
      init();
    }, []);
    var init = function() {
      var canvas = document.createElement("canvas");
      var ratio = window.devicePixelRatio;
      var ctx2 = canvas.getContext("2d");
      var canvasWidth = "".concat((gapX + width2) * ratio, "px");
      var canvasHeight = "".concat((gapY + height2) * ratio, "px");
      var markWidth = width2 * ratio;
      var markHeight = height2 * ratio;
      canvas.setAttribute("width", canvasWidth);
      canvas.setAttribute("height", canvasHeight);
      if (ctx2) {
        if (image) {
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          var img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = image;
          img.onload = function() {
            ctx2.drawImage(img, -imageWidth * ratio / 2, -imageHeight * ratio / 2, imageWidth * ratio, imageHeight * ratio);
            ctx2.restore();
            setBase64Url(canvas.toDataURL());
          };
        } else if (content2) {
          ctx2.textBaseline = "middle";
          ctx2.textAlign = "center";
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          var markSize = Number(fontSize) * ratio;
          ctx2.font = "".concat(fontStyle, " normal ").concat(fontWeight, " ").concat(markSize, "px/").concat(markHeight, "px ").concat(fontFamily);
          ctx2.fillStyle = color;
          ctx2.fillText(content2, startX, startY);
          ctx2.restore();
          setBase64Url(canvas.toDataURL());
        }
      } else {
        throw new Error(locale.watermark.errorCanvasTips);
      }
    };
    return /* @__PURE__ */ React.createElement("div", {
      className: cls,
      style: _object_spread({
        zIndex,
        backgroundSize: "".concat(gapX + width2, "px"),
        backgroundImage: "url('".concat(base64Url, "')")
      }, style)
    });
  };
  WaterMark.displayName = "NutWaterMark";
  var idCounter = {};
  function uniqueId() {
    var prefix2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$nut$";
    if (!idCounter[prefix2]) {
      idCounter[prefix2] = 0;
    }
    var id = ++idCounter[prefix2];
    if (prefix2 === "$nut$") {
      return "".concat(id);
    }
    return "".concat(prefix2).concat(id);
  }
  function useUuid() {
    var idRef = React.useRef(uniqueId());
    return idRef.current;
  }
  exports.ActionSheet = ActionSheet;
  exports.Address = Address;
  exports.Animate = Animate;
  exports.AnimatingNumbers = AnimatingNumbers;
  exports.Audio = Audio;
  exports.Avatar = Avatar;
  exports.AvatarCropper = AvatarCropper;
  exports.AvatarGroup = AvatarGroup;
  exports.BackTop = BackTop;
  exports.Badge = Badge;
  exports.Barrage = Barrage;
  exports.Button = Button;
  exports.Calendar = Calendar;
  exports.CalendarCard = CalendarCard;
  exports.CalendarItem = CalendarItem;
  exports.Card = Card;
  exports.Cascader = Cascader;
  exports.Cell = Cell;
  exports.CellGroup = CellGroup;
  exports.Checkbox = InnerCheckbox;
  exports.CheckboxGroup = CheckboxGroup;
  exports.CircleProgress = CircleProgress;
  exports.Col = Col;
  exports.Collapse = Collapse;
  exports.CollapseItem = CollapseItem;
  exports.ComponentDefaults = ComponentDefaults;
  exports.ConfigProvider = ConfigProvider;
  exports.CountDown = CountDown;
  exports.DatePicker = DatePicker;
  exports.DatePickerView = DatePickerView;
  exports.Dialog = Dialog;
  exports.Divider = Divider;
  exports.Drag = Drag;
  exports.Elevator = Elevator;
  exports.Ellipsis = Ellipsis;
  exports.Empty = Empty;
  exports.FixedNav = FixedNav;
  exports.Form = InnerForm;
  exports.FormItem = FormItem;
  exports.Grid = Grid;
  exports.GridItem = GridItem;
  exports.HoverButton = HoverButton;
  exports.HoverButtonItem = HoverButtonItem;
  exports.Image = Image$1;
  exports.ImagePreview = ImagePreview;
  exports.Indicator = Indicator;
  exports.InfiniteLoading = InfiniteLoading;
  exports.Input = Input;
  exports.InputNumber = InputNumber;
  exports.Layout = Layout;
  exports.Loading = Loading;
  exports.Lottie = Lottie;
  exports.Menu = Menu;
  exports.MenuItem = MenuItem;
  exports.MiniLru = MiniLru;
  exports.NavBar = NavBar;
  exports.NoticeBar = NoticeBar;
  exports.Notify = Notify;
  exports.NumberKeyboard = NumberKeyboard;
  exports.Overlay = Overlay;
  exports.Pagination = Pagination;
  exports.Picker = Picker;
  exports.PickerView = PickerView;
  exports.Popover = Popover;
  exports.Popup = Popup;
  exports.Price = Price;
  exports.Progress = Progress;
  exports.PullToRefresh = PullToRefresh;
  exports.Radio = InnerRadio;
  exports.RadioGroup = RadioGroup;
  exports.Range = Range;
  exports.Rate = Rate;
  exports.ResultPage = ResultPage;
  exports.Row = Row;
  exports.SafeArea = SafeArea;
  exports.SearchBar = SearchBar;
  exports.Segmented = Segmented;
  exports.ShortPassword = ShortPassword;
  exports.SideBar = SideBar;
  exports.SideBarItem = SideBarItem;
  exports.Signature = Signature;
  exports.Skeleton = Skeleton;
  exports.Space = Space;
  exports.Step = Step;
  exports.Steps = Steps;
  exports.Sticky = Sticky;
  exports.Swipe = Swipe;
  exports.Swiper = InnerSwiper;
  exports.SwiperItem = SwiperItem;
  exports.Switch = Switch;
  exports.TabPane = TabPane;
  exports.Tabbar = Tabbar;
  exports.TabbarItem = TabbarItem;
  exports.Table = Table;
  exports.Tabs = Tabs;
  exports.Tag = Tag;
  exports.TextArea = TextArea;
  exports.TimeDetail = TimeDetail;
  exports.TimeSelect = TimeSelect;
  exports.Toast = Toast;
  exports.Tour = Tour;
  exports.TrendArrow = TrendArrow;
  exports.Uploader = Uploader;
  exports.Utils = Utils;
  exports.Video = Video;
  exports.VirtualList = VirtualList;
  exports.WaterMark = WaterMark;
  exports.bound = bound;
  exports.camelCase = camelCase;
  exports.canUseDom = canUseDom;
  exports.cancelRaf = cancelRaf;
  exports.clamp = clamp$2;
  exports.clone = clone;
  exports.destroyList = destroyList;
  exports.funcInterceptor = funcInterceptor;
  exports.getAllScrollableParents = getAllScrollableParents;
  exports.getCurrMonthData = getCurrMonthData;
  exports.getDaysStatus = getDaysStatus;
  exports.getDefaultConfig = getDefaultConfig;
  exports.getPreMonthDates = getPreMonthDates;
  exports.getRect = getRect;
  exports.getRefValue = getRefValue;
  exports.getScrollParent = getScrollParent;
  exports.inBrowser = inBrowser;
  exports.isDate = isDate;
  exports.isEmpty = isEmpty;
  exports.isForwardRefComponent = isForwardRefComponent;
  exports.isFunction = isFunction;
  exports.isObject = isObject;
  exports.isPlainObject = isPlainObject;
  exports.isPromise = isPromise;
  exports.isWindow = isWindow;
  exports.main = main;
  exports.merge = merge;
  exports.mergeProp = mergeProp;
  exports.mergeProps = mergeProps;
  exports.padZero = padZero;
  exports.preventDefault = preventDefault$1;
  exports.pxCheck = pxCheck;
  exports.recursive = recursive;
  exports.render = render;
  exports.rubberband = rubberband$1;
  exports.rubberbandIfOutOfBounds = rubberbandIfOutOfBounds$1;
  exports.setDefaultConfig = setDefaultConfig;
  exports.sleep = sleep;
  exports.toArray = toArray$1;
  exports.unmount = unmount;
  exports.upperCaseFirst = upperCaseFirst;
  exports.useConfig = useConfig;
  exports.useForceUpdate = useForceUpdate;
  exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
  exports.useLockScroll = useLockScroll;
  exports.useMemo = useMemo;
  exports.usePagination = usePagination;
  exports.usePropsValue = usePropsValue;
  exports.useRefState = useRefState;
  exports.useRefs = useRefs;
  exports.useRtl = useRtl;
  exports.useTouch = useTouch;
  exports.useUuid = useUuid;
  exports.useWatch = useWatch$1;
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
});
