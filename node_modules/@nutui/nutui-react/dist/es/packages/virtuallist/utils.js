// 缓存列表初始化信息
var initPositinoCache = function(reaItemSize) {
    var length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var index = 0;
    var positions = Array(length);
    while(index < length){
        positions[index] = {
            index: index,
            height: reaItemSize,
            width: reaItemSize,
            top: index * reaItemSize,
            bottom: (index + 1) * reaItemSize,
            left: index * reaItemSize,
            right: (index + 1) * reaItemSize
        };
        index++;
    }
    return positions;
};
// 获取列表总高度
var getListTotalSize = function(positions, horizontal) {
    var index = positions.length - 1;
    var size = 0;
    if (index < 0) {
        size = 0;
    } else {
        size = horizontal ? positions[index].right : positions[index].bottom;
    }
    return size;
};
// 通过二分法找到 scrollOffset 对应的值
var binarySearch = function(positionsList, horizontal) {
    var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var start = 0;
    var end = positionsList.length - 1;
    var tempIndex = null;
    var key = horizontal ? 'right' : 'bottom';
    while(start <= end){
        var midIndex = Math.floor((start + end) / 2);
        var midValue = positionsList[midIndex][key];
        // 相等则直接返回（因为是bottom, 因此startIndex应该是下一个节点）
        if (midValue === value) {
            return midIndex + 1;
        }
        // 中间值 < 传入值，则说明 value对应的节点 大于 start, start往后移动一位
        if (midValue < value) {
            start = midIndex + 1;
        } else if (midValue > value) {
            // tempIndex存放最靠近值为value的所有
            if (tempIndex === null || tempIndex > midIndex) {
                tempIndex = midIndex;
            }
            end = midIndex - 1;
        }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
};
var getEndIndex = function(param) {
    var list = param.list, startIndex = param.startIndex, visibleCount = param.visibleCount, _param_itemEqual = param.itemEqual, itemEqual = _param_itemEqual === void 0 ? true : _param_itemEqual, positions = param.positions, offSetSize = param.offSetSize, overscan = param.overscan, _param_sizeKey = param.sizeKey, sizeKey = _param_sizeKey === void 0 ? 'width' : _param_sizeKey;
    var dataLength = list.length;
    var tempIndex = null;
    if (itemEqual) {
        var endIndex = startIndex + visibleCount;
        tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex) : endIndex;
    } else {
        var sizeNum = 0;
        for(var i = startIndex; i < dataLength; i++){
            sizeNum += positions[i][sizeKey] || 0;
            if (sizeNum > offSetSize) {
                var endIndex1 = i + overscan;
                tempIndex = dataLength > 0 ? Math.min(dataLength, endIndex1) : endIndex1;
                break;
            }
        }
        if (sizeNum < offSetSize) {
            tempIndex = dataLength;
        }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
};
// 更新Item大小
var updateItemSize = function(positions, items, sizeKey, margin) {
    var newPos = positions.concat();
    Array.from(items).forEach(function(item) {
        var index = Number(item.getAttribute('data-index'));
        var styleVal = item.getAttribute('style');
        if (styleVal && styleVal.includes('none')) return;
        var nowSize = item.getBoundingClientRect()[sizeKey];
        if (margin) nowSize += margin;
        var oldSize = positions[index][sizeKey];
        // 存在差值, 更新该节点以后所有的节点
        var dValue = oldSize - nowSize;
        if (dValue) {
            if (sizeKey === 'width') {
                newPos[index].right -= dValue;
                newPos[index][sizeKey] = nowSize;
                for(var k = index + 1; k < positions.length; k++){
                    newPos[k].left = positions[k - 1].right;
                    newPos[k].right -= dValue;
                }
            } else if (sizeKey === 'height') {
                newPos[index].bottom -= dValue;
                newPos[index][sizeKey] = nowSize;
                for(var k1 = index + 1; k1 < positions.length; k1++){
                    newPos[k1].top = positions[k1 - 1].bottom;
                    newPos[k1].bottom -= dValue;
                }
            }
        }
    });
};
export { initPositinoCache, getListTotalSize, binarySearch, getEndIndex, updateItemSize,  };
