import { _ as _async_to_generator } from "@swc/helpers/_/_async_to_generator";
import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _type_of } from "@swc/helpers/_/_type_of";
import { _ as _ts_generator } from "@swc/helpers/_/_ts_generator";
import * as ReactDOM from "react-dom";
// Let compiler not to search module usage
var fullClone = _object_spread({}, ReactDOM);
var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
    var mainVersion = Number((version || '').split('.')[0]);
    if (mainVersion >= 18 && fullClone.createRoot) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        createRoot = fullClone.createRoot;
    }
} catch (e) {
// Do nothing;
}
function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && (typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "undefined" ? "undefined" : _type_of(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED)) === 'object') {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
}
var MARK = '__nutui_react_root__';
function legacyRender(node, container) {
    reactRender(node, container);
}
function concurrentRender(node, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node);
    container[MARK] = root;
}
export function render(node, container) {
    if (createRoot) {
        concurrentRender(node, container);
        return;
    }
    legacyRender(node, container);
}
// ========================== Unmount =========================
function legacyUnmount(container) {
    return unmountComponentAtNode(container);
}
function concurrentUnmount(container) {
    return _concurrentUnmount.apply(this, arguments);
}
function _concurrentUnmount() {
    _concurrentUnmount = _async_to_generator(function(container) {
        return _ts_generator(this, function(_state) {
            // Delay to unmount to avoid React 18 sync warning
            return [
                2,
                Promise.resolve().then(function() {
                    var _container_MARK;
                    (_container_MARK = container[MARK]) === null || _container_MARK === void 0 ? void 0 : _container_MARK.unmount();
                    delete container[MARK];
                })
            ];
        });
    });
    return _concurrentUnmount.apply(this, arguments);
}
export function unmount(container) {
    if (createRoot) {
        return concurrentUnmount(container);
    }
    return legacyUnmount(container);
}
